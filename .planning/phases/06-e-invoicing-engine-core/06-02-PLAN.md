---
phase: 06-e-invoicing-engine-core
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/src/utils/tlv-encoder.util.ts
  - backend/src/services/einvoice/qr-code.service.ts
  - backend/src/services/einvoice/__tests__/qr-code.service.test.ts
autonomous: true

must_haves:
  truths:
    - "TLV encoder produces correct binary format (tag + length + value)"
    - "QR code contains Base64 of TLV-encoded data"
    - "TLV decoder can reverse-encode to verify data"
    - "QR codes are generated within 100ms for typical invoices"
    - "Arabic seller names are properly UTF-8 encoded in TLV"
  artifacts:
    - path: "backend/src/utils/tlv-encoder.util.ts"
      provides: "TLV encoding/decoding utility functions"
      exports: ["encodeTlv", "decodeTlv", "TlvTag"]
    - path: "backend/src/services/einvoice/qr-code.service.ts"
      provides: "QR code generation service with TLV encoding"
      exports: ["QrCodeService"]
  key_links:
    - from: "qr-code.service.ts"
      to: "tlv-encoder.util.ts"
      via: "Import for TLV encoding"
      pattern: "encodeTlv|decodeTlv"
    - from: "qr-code.service.ts"
      to: "einvoice.types.ts"
      via: "Uses TlvQrInput interface"
      pattern: "TlvQrInput"
---

<objective>
Create the TLV (Tag-Length-Value) encoding utility and QR code generation service for e-invoices.

Purpose: EINV-03 requires QR codes with TLV-encoded data readable by FTA-approved scanners. This follows the ZATCA pattern adapted for UAE, encoding seller name, TRN, timestamp, invoice total, and VAT total.

Output:
- TLV encoder/decoder utility with proper UTF-8 handling
- QrCodeService with multiple output formats
- Unit tests for TLV encoding edge cases
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-e-invoicing-engine-core/06-RESEARCH.md

# Types from 06-01 (parallel execution - reference only)
# Types will be available: TlvQrInput, TlvTag, DecodedTlvData
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TLV Encoder Utility</name>
  <files>backend/src/utils/tlv-encoder.util.ts</files>
  <action>
Create the TLV encoding utility following ZATCA pattern:

```typescript
/**
 * TLV Encoder Utility
 * Phase: 06-e-invoicing-engine-core
 * Requirement: EINV-03 (QR code generation with TLV encoding)
 *
 * Implements Tag-Length-Value encoding for e-invoice QR codes.
 * Based on ZATCA QR Code Creation Guide adapted for UAE.
 *
 * TLV Format: Tag (1 byte) + Length (1 byte) + Value (variable bytes)
 * - Tag: Integer identifying the field (1-8)
 * - Length: Byte count of value (max 255)
 * - Value: UTF-8 encoded string
 */

/**
 * TLV Tag definitions (ZATCA-compatible)
 * UAE FTA hasn't published official tags; using ZATCA as baseline
 */
export enum TlvTag {
  SELLER_NAME = 1,
  SELLER_TRN = 2,
  INVOICE_TIMESTAMP = 3,
  INVOICE_TOTAL = 4,
  VAT_TOTAL = 5,
  // Extended tags (prepare for future UAE requirements)
  INVOICE_HASH = 6,
  DIGITAL_SIGNATURE = 7,
  PUBLIC_KEY = 8,
}

/**
 * Input for TLV encoding
 */
export interface TlvEncoderInput {
  sellerName: string;
  sellerTrn: string;
  timestamp: Date;
  invoiceTotal: string;
  vatTotal: string;
  invoiceHash?: string;
}

/**
 * Decoded TLV data structure
 */
export interface DecodedTlvData {
  sellerName?: string;
  sellerTrn?: string;
  timestamp?: Date;
  invoiceTotal?: string;
  vatTotal?: string;
  invoiceHash?: string;
  rawTags?: Map<number, string>;
}

/**
 * Encodes a single TLV field
 *
 * @param tag - Field identifier (1-8)
 * @param value - String value to encode (UTF-8)
 * @returns Buffer containing TLV-encoded field
 * @throws Error if value exceeds 255 bytes when UTF-8 encoded
 */
export function encodeTlvField(tag: TlvTag, value: string): Buffer {
  const valueBuffer = Buffer.from(value, 'utf-8');
  const length = valueBuffer.length;

  if (length > 255) {
    throw new Error(
      `TLV value for tag ${tag} exceeds maximum length (${length} > 255 bytes). ` +
      `Consider truncating the value.`
    );
  }

  // Allocate buffer: 1 byte tag + 1 byte length + value bytes
  const tlvBuffer = Buffer.alloc(2 + length);
  tlvBuffer.writeUInt8(tag, 0);
  tlvBuffer.writeUInt8(length, 1);
  valueBuffer.copy(tlvBuffer, 2);

  return tlvBuffer;
}

/**
 * Encodes invoice data to TLV format
 *
 * @param input - Invoice data to encode
 * @returns Buffer containing concatenated TLV fields
 *
 * @example
 * const tlvData = encodeTlv({
 *   sellerName: 'Vesla Motors LLC',
 *   sellerTrn: '100123456789012',
 *   timestamp: new Date(),
 *   invoiceTotal: '1050.00',
 *   vatTotal: '50.00',
 * });
 * const base64 = tlvData.toString('base64');
 */
export function encodeTlv(input: TlvEncoderInput): Buffer {
  const parts: Buffer[] = [];

  // Tag 1: Seller Name (UTF-8, supports Arabic)
  parts.push(encodeTlvField(TlvTag.SELLER_NAME, input.sellerName));

  // Tag 2: Seller TRN (15 digits starting with 100)
  parts.push(encodeTlvField(TlvTag.SELLER_TRN, input.sellerTrn));

  // Tag 3: Timestamp (ISO 8601 format)
  const timestamp = input.timestamp.toISOString();
  parts.push(encodeTlvField(TlvTag.INVOICE_TIMESTAMP, timestamp));

  // Tag 4: Invoice Total (decimal string with 2 decimals)
  parts.push(encodeTlvField(TlvTag.INVOICE_TOTAL, input.invoiceTotal));

  // Tag 5: VAT Total (decimal string with 2 decimals)
  parts.push(encodeTlvField(TlvTag.VAT_TOTAL, input.vatTotal));

  // Tag 6: Invoice Hash (optional, SHA-256 hex)
  if (input.invoiceHash) {
    parts.push(encodeTlvField(TlvTag.INVOICE_HASH, input.invoiceHash));
  }

  return Buffer.concat(parts);
}

/**
 * Decodes TLV data from Buffer
 *
 * @param buffer - TLV-encoded buffer
 * @returns Decoded data with parsed fields
 *
 * @example
 * const base64Data = qrCodeContent; // from QR scan
 * const buffer = Buffer.from(base64Data, 'base64');
 * const decoded = decodeTlv(buffer);
 * console.log(decoded.sellerName, decoded.sellerTrn);
 */
export function decodeTlv(buffer: Buffer): DecodedTlvData {
  const result: DecodedTlvData = {
    rawTags: new Map(),
  };

  let offset = 0;

  while (offset < buffer.length) {
    // Read tag (1 byte)
    const tag = buffer.readUInt8(offset);
    offset += 1;

    // Read length (1 byte)
    const length = buffer.readUInt8(offset);
    offset += 1;

    // Read value (variable bytes)
    const value = buffer.slice(offset, offset + length).toString('utf-8');
    offset += length;

    // Store raw tag
    result.rawTags?.set(tag, value);

    // Map to typed fields
    switch (tag) {
      case TlvTag.SELLER_NAME:
        result.sellerName = value;
        break;
      case TlvTag.SELLER_TRN:
        result.sellerTrn = value;
        break;
      case TlvTag.INVOICE_TIMESTAMP:
        result.timestamp = new Date(value);
        break;
      case TlvTag.INVOICE_TOTAL:
        result.invoiceTotal = value;
        break;
      case TlvTag.VAT_TOTAL:
        result.vatTotal = value;
        break;
      case TlvTag.INVOICE_HASH:
        result.invoiceHash = value;
        break;
      // Tags 7-8 reserved for digital signature (Phase 7)
    }
  }

  return result;
}

/**
 * Decodes TLV data from Base64 string
 *
 * @param base64Data - Base64-encoded TLV data (from QR code)
 * @returns Decoded data with parsed fields
 */
export function decodeTlvFromBase64(base64Data: string): DecodedTlvData {
  const buffer = Buffer.from(base64Data, 'base64');
  return decodeTlv(buffer);
}

/**
 * Validates TLV data contains required fields
 *
 * @param data - Decoded TLV data
 * @returns Validation result with any missing fields
 */
export function validateTlvData(data: DecodedTlvData): {
  valid: boolean;
  missingFields: string[];
} {
  const required = ['sellerName', 'sellerTrn', 'timestamp', 'invoiceTotal', 'vatTotal'];
  const missingFields: string[] = [];

  for (const field of required) {
    if (!(data as Record<string, unknown>)[field]) {
      missingFields.push(field);
    }
  }

  return {
    valid: missingFields.length === 0,
    missingFields,
  };
}

/**
 * Truncates string to fit within TLV max length
 * Useful for seller names that might exceed 255 bytes
 *
 * @param value - String to truncate
 * @param maxBytes - Maximum byte length (default 255)
 * @returns Truncated string that fits within maxBytes when UTF-8 encoded
 */
export function truncateForTlv(value: string, maxBytes: number = 255): string {
  const encoded = Buffer.from(value, 'utf-8');

  if (encoded.length <= maxBytes) {
    return value;
  }

  // Binary search for safe truncation point
  let left = 0;
  let right = value.length;

  while (left < right) {
    const mid = Math.ceil((left + right) / 2);
    const testEncoded = Buffer.from(value.slice(0, mid), 'utf-8');

    if (testEncoded.length <= maxBytes) {
      left = mid;
    } else {
      right = mid - 1;
    }
  }

  return value.slice(0, left);
}
```
  </action>
  <verify>Run `npx tsc --noEmit` to verify TypeScript compilation.</verify>
  <done>TLV encoder utility created with encodeTlv(), decodeTlv(), truncateForTlv() functions. Supports Arabic UTF-8 encoding.</done>
</task>

<task type="auto">
  <name>Task 2: Create QR Code Service</name>
  <files>backend/src/services/einvoice/qr-code.service.ts</files>
  <action>
Create the directory and QR code service:

```bash
mkdir -p backend/src/services/einvoice
```

```typescript
/**
 * QR Code Service
 * Phase: 06-e-invoicing-engine-core
 * Requirement: EINV-03 (QR code generation with TLV encoding)
 *
 * Generates QR codes with TLV-encoded e-invoice data for FTA compliance.
 * QR codes contain Base64 of TLV-encoded mandatory fields:
 * - Seller Name (Tag 1)
 * - Seller TRN (Tag 2)
 * - Invoice Timestamp (Tag 3)
 * - Invoice Total with VAT (Tag 4)
 * - VAT Total (Tag 5)
 */

import QRCode from 'qrcode';
import { injectable } from 'inversify';
import {
  encodeTlv,
  decodeTlvFromBase64,
  validateTlvData,
  truncateForTlv,
  TlvEncoderInput,
  DecodedTlvData,
} from '../../utils/tlv-encoder.util';
import logger from '../logger.service';

/**
 * QR code output format options
 */
export type QrOutputFormat = 'base64' | 'buffer' | 'dataUrl' | 'svg';

/**
 * QR code generation options
 */
export interface QrCodeOptions {
  format: QrOutputFormat;
  width?: number;
  margin?: number;
  errorCorrectionLevel?: 'L' | 'M' | 'Q' | 'H';
}

/**
 * QR code generation result
 */
export interface QrCodeResult {
  data: string | Buffer;
  format: QrOutputFormat;
  tlvBase64: string;
  contentSize: number;
}

/**
 * Input for QR code generation
 */
export interface QrCodeInput {
  sellerName: string;
  sellerTrn: string;
  timestamp: Date;
  invoiceTotal: string;
  vatTotal: string;
  invoiceHash?: string;
}

/**
 * Default QR code options
 */
const DEFAULT_OPTIONS: QrCodeOptions = {
  format: 'base64',
  width: 200,
  margin: 2,
  errorCorrectionLevel: 'M',
};

/**
 * Maximum QR content size in characters
 * Beyond this, QR becomes too dense for reliable scanning
 */
const MAX_QR_CONTENT_SIZE = 500;

@injectable()
export class QrCodeService {
  /**
   * Generates TLV-encoded QR code for e-invoice
   *
   * @param input - Invoice data for QR encoding
   * @param options - QR generation options
   * @returns QR code in requested format
   *
   * @example
   * const result = await qrCodeService.generateQrCode({
   *   sellerName: 'Vesla Motors LLC',
   *   sellerTrn: '100123456789012',
   *   timestamp: new Date(),
   *   invoiceTotal: '1050.00',
   *   vatTotal: '50.00',
   * });
   * // Use result.data for embedding in PDF/XML
   */
  async generateQrCode(
    input: QrCodeInput,
    options: Partial<QrCodeOptions> = {}
  ): Promise<QrCodeResult> {
    const opts = { ...DEFAULT_OPTIONS, ...options };

    try {
      // Validate input
      this.validateInput(input);

      // Prepare TLV input (truncate seller name if needed)
      const tlvInput: TlvEncoderInput = {
        sellerName: truncateForTlv(input.sellerName, 200), // Leave room for other fields
        sellerTrn: input.sellerTrn,
        timestamp: input.timestamp,
        invoiceTotal: this.formatDecimal(input.invoiceTotal),
        vatTotal: this.formatDecimal(input.vatTotal),
        invoiceHash: input.invoiceHash,
      };

      // Encode to TLV
      const tlvBuffer = encodeTlv(tlvInput);
      const tlvBase64 = tlvBuffer.toString('base64');

      // Check content size
      if (tlvBase64.length > MAX_QR_CONTENT_SIZE) {
        logger.warn('[QrCodeService] QR content exceeds recommended size', {
          size: tlvBase64.length,
          maxSize: MAX_QR_CONTENT_SIZE,
          sellerName: input.sellerName.substring(0, 20),
        });
      }

      // Generate QR code
      const qrData = await this.renderQrCode(tlvBase64, opts);

      logger.info('[QrCodeService] QR code generated', {
        format: opts.format,
        contentSize: tlvBase64.length,
        sellerTrn: input.sellerTrn,
      });

      return {
        data: qrData,
        format: opts.format,
        tlvBase64,
        contentSize: tlvBase64.length,
      };
    } catch (error) {
      logger.error('[QrCodeService] QR code generation failed', {
        error: error instanceof Error ? error.message : 'Unknown error',
        sellerTrn: input.sellerTrn,
      });
      throw error;
    }
  }

  /**
   * Validates and decodes QR code data
   *
   * @param base64Data - Base64 TLV data from QR code scan
   * @returns Decoded and validated data
   */
  decodeQrCode(base64Data: string): {
    data: DecodedTlvData;
    valid: boolean;
    missingFields: string[];
  } {
    try {
      const decoded = decodeTlvFromBase64(base64Data);
      const validation = validateTlvData(decoded);

      return {
        data: decoded,
        valid: validation.valid,
        missingFields: validation.missingFields,
      };
    } catch (error) {
      logger.error('[QrCodeService] QR decode failed', {
        error: error instanceof Error ? error.message : 'Unknown error',
      });
      throw new Error('Invalid QR code data format');
    }
  }

  /**
   * Generates QR code for embedding in PDF documents
   *
   * @param input - Invoice data
   * @returns Data URL suitable for img src
   */
  async generateQrCodeForPdf(input: QrCodeInput): Promise<string> {
    const result = await this.generateQrCode(input, {
      format: 'dataUrl',
      width: 150,
      margin: 1,
      errorCorrectionLevel: 'M',
    });
    return result.data as string;
  }

  /**
   * Generates QR code for embedding in XML
   *
   * @param input - Invoice data
   * @returns Base64-encoded PNG image
   */
  async generateQrCodeForXml(input: QrCodeInput): Promise<string> {
    const result = await this.generateQrCode(input, {
      format: 'base64',
      width: 200,
      margin: 2,
      errorCorrectionLevel: 'M',
    });
    return result.data as string;
  }

  /**
   * Validates QR input data
   */
  private validateInput(input: QrCodeInput): void {
    if (!input.sellerName || input.sellerName.trim().length === 0) {
      throw new Error('Seller name is required for QR code');
    }

    if (!input.sellerTrn || !/^100\d{12}$/.test(input.sellerTrn)) {
      throw new Error('Valid TRN (15 digits starting with 100) is required');
    }

    if (!input.timestamp || !(input.timestamp instanceof Date)) {
      throw new Error('Valid timestamp is required');
    }

    if (!input.invoiceTotal || isNaN(parseFloat(input.invoiceTotal))) {
      throw new Error('Valid invoice total is required');
    }

    if (!input.vatTotal || isNaN(parseFloat(input.vatTotal))) {
      throw new Error('Valid VAT total is required');
    }
  }

  /**
   * Formats decimal string to 2 decimal places
   */
  private formatDecimal(value: string): string {
    const num = parseFloat(value);
    if (isNaN(num)) {
      throw new Error(`Invalid decimal value: ${value}`);
    }
    return num.toFixed(2);
  }

  /**
   * Renders QR code in specified format
   */
  private async renderQrCode(
    content: string,
    options: QrCodeOptions
  ): Promise<string | Buffer> {
    const qrOptions = {
      errorCorrectionLevel: options.errorCorrectionLevel,
      width: options.width,
      margin: options.margin,
    };

    switch (options.format) {
      case 'buffer':
        return await QRCode.toBuffer(content, qrOptions);

      case 'dataUrl':
        return await QRCode.toDataURL(content, qrOptions);

      case 'svg':
        return await QRCode.toString(content, {
          ...qrOptions,
          type: 'svg',
        });

      case 'base64':
      default:
        const buffer = await QRCode.toBuffer(content, qrOptions);
        return buffer.toString('base64');
    }
  }
}

export default QrCodeService;
```

Also create the service index:

```typescript
// backend/src/services/einvoice/index.ts
export * from './qr-code.service';
```
  </action>
  <verify>Run `npx tsc --noEmit` to verify TypeScript compilation. Ensure qrcode package is installed.</verify>
  <done>QrCodeService created with generateQrCode(), decodeQrCode(), generateQrCodeForPdf(), generateQrCodeForXml() methods. Supports base64, buffer, dataUrl, svg formats.</done>
</task>

<task type="auto">
  <name>Task 3: Create QR Code Service Unit Tests</name>
  <files>backend/src/services/einvoice/__tests__/qr-code.service.test.ts</files>
  <action>
Create unit tests for TLV encoding and QR code generation:

```typescript
/**
 * QR Code Service Tests
 * Phase: 06-e-invoicing-engine-core
 * Requirement: EINV-03 (QR code generation with TLV encoding)
 */

import { QrCodeService, QrCodeInput } from '../qr-code.service';
import {
  encodeTlv,
  decodeTlv,
  decodeTlvFromBase64,
  validateTlvData,
  truncateForTlv,
  TlvTag,
  TlvEncoderInput,
} from '../../../utils/tlv-encoder.util';

describe('TLV Encoder Utility', () => {
  const validInput: TlvEncoderInput = {
    sellerName: 'Vesla Motors LLC',
    sellerTrn: '100123456789012',
    timestamp: new Date('2026-01-24T10:30:00.000Z'),
    invoiceTotal: '1050.00',
    vatTotal: '50.00',
  };

  describe('encodeTlv', () => {
    it('should encode all mandatory fields', () => {
      const buffer = encodeTlv(validInput);
      expect(buffer).toBeInstanceOf(Buffer);
      expect(buffer.length).toBeGreaterThan(0);
    });

    it('should encode fields in correct order (1-5)', () => {
      const buffer = encodeTlv(validInput);

      // First tag should be 1 (seller name)
      expect(buffer.readUInt8(0)).toBe(TlvTag.SELLER_NAME);
    });

    it('should include optional invoice hash when provided', () => {
      const inputWithHash = {
        ...validInput,
        invoiceHash: 'abc123def456',
      };
      const buffer = encodeTlv(inputWithHash);

      // Decode and verify hash is present
      const decoded = decodeTlv(buffer);
      expect(decoded.invoiceHash).toBe('abc123def456');
    });

    it('should handle Arabic seller names (UTF-8)', () => {
      const arabicInput = {
        ...validInput,
        sellerName: 'شركة فيسلا للسيارات',
      };
      const buffer = encodeTlv(arabicInput);
      const decoded = decodeTlv(buffer);

      expect(decoded.sellerName).toBe('شركة فيسلا للسيارات');
    });

    it('should throw error for value exceeding 255 bytes', () => {
      const longName = 'A'.repeat(300);
      const invalidInput = { ...validInput, sellerName: longName };

      expect(() => encodeTlv(invalidInput)).toThrow('exceeds maximum length');
    });
  });

  describe('decodeTlv', () => {
    it('should decode all fields correctly', () => {
      const buffer = encodeTlv(validInput);
      const decoded = decodeTlv(buffer);

      expect(decoded.sellerName).toBe(validInput.sellerName);
      expect(decoded.sellerTrn).toBe(validInput.sellerTrn);
      expect(decoded.invoiceTotal).toBe(validInput.invoiceTotal);
      expect(decoded.vatTotal).toBe(validInput.vatTotal);
      expect(decoded.timestamp).toBeInstanceOf(Date);
    });

    it('should handle empty buffer', () => {
      const decoded = decodeTlv(Buffer.alloc(0));
      expect(decoded.sellerName).toBeUndefined();
    });

    it('should preserve raw tags map', () => {
      const buffer = encodeTlv(validInput);
      const decoded = decodeTlv(buffer);

      expect(decoded.rawTags).toBeDefined();
      expect(decoded.rawTags?.get(TlvTag.SELLER_NAME)).toBe(validInput.sellerName);
    });
  });

  describe('decodeTlvFromBase64', () => {
    it('should decode Base64 TLV data', () => {
      const buffer = encodeTlv(validInput);
      const base64 = buffer.toString('base64');

      const decoded = decodeTlvFromBase64(base64);
      expect(decoded.sellerName).toBe(validInput.sellerName);
    });

    it('should throw on invalid Base64', () => {
      expect(() => decodeTlvFromBase64('!!!invalid!!!')).not.toThrow();
      // Invalid base64 results in empty/malformed buffer
    });
  });

  describe('validateTlvData', () => {
    it('should pass for complete data', () => {
      const buffer = encodeTlv(validInput);
      const decoded = decodeTlv(buffer);
      const result = validateTlvData(decoded);

      expect(result.valid).toBe(true);
      expect(result.missingFields).toHaveLength(0);
    });

    it('should fail for missing required fields', () => {
      const partial = { sellerName: 'Test' };
      const result = validateTlvData(partial);

      expect(result.valid).toBe(false);
      expect(result.missingFields).toContain('sellerTrn');
      expect(result.missingFields).toContain('timestamp');
    });
  });

  describe('truncateForTlv', () => {
    it('should not truncate short strings', () => {
      const short = 'Short name';
      expect(truncateForTlv(short)).toBe(short);
    });

    it('should truncate strings exceeding max bytes', () => {
      const long = 'A'.repeat(300);
      const truncated = truncateForTlv(long);

      expect(Buffer.from(truncated, 'utf-8').length).toBeLessThanOrEqual(255);
    });

    it('should handle multibyte UTF-8 characters correctly', () => {
      // Arabic characters are multi-byte
      const arabic = 'ش'.repeat(100); // Each char is 2 bytes
      const truncated = truncateForTlv(arabic, 100);

      expect(Buffer.from(truncated, 'utf-8').length).toBeLessThanOrEqual(100);
      // Should not cut in middle of character
      expect(truncated.includes('�')).toBe(false);
    });
  });
});

describe('QrCodeService', () => {
  let service: QrCodeService;

  const validInput: QrCodeInput = {
    sellerName: 'Vesla Motors LLC',
    sellerTrn: '100123456789012',
    timestamp: new Date('2026-01-24T10:30:00.000Z'),
    invoiceTotal: '1050.00',
    vatTotal: '50.00',
  };

  beforeEach(() => {
    service = new QrCodeService();
  });

  describe('generateQrCode', () => {
    it('should generate Base64 QR code by default', async () => {
      const result = await service.generateQrCode(validInput);

      expect(result.format).toBe('base64');
      expect(typeof result.data).toBe('string');
      expect(result.tlvBase64).toBeTruthy();
      expect(result.contentSize).toBeGreaterThan(0);
    });

    it('should generate data URL format', async () => {
      const result = await service.generateQrCode(validInput, { format: 'dataUrl' });

      expect(result.format).toBe('dataUrl');
      expect((result.data as string).startsWith('data:image/png;base64,')).toBe(true);
    });

    it('should generate buffer format', async () => {
      const result = await service.generateQrCode(validInput, { format: 'buffer' });

      expect(result.format).toBe('buffer');
      expect(result.data).toBeInstanceOf(Buffer);
    });

    it('should generate SVG format', async () => {
      const result = await service.generateQrCode(validInput, { format: 'svg' });

      expect(result.format).toBe('svg');
      expect((result.data as string).includes('<svg')).toBe(true);
    });

    it('should reject invalid TRN format', async () => {
      const invalidInput = { ...validInput, sellerTrn: '123456' };

      await expect(service.generateQrCode(invalidInput)).rejects.toThrow('Valid TRN');
    });

    it('should reject empty seller name', async () => {
      const invalidInput = { ...validInput, sellerName: '' };

      await expect(service.generateQrCode(invalidInput)).rejects.toThrow('Seller name is required');
    });

    it('should reject invalid invoice total', async () => {
      const invalidInput = { ...validInput, invoiceTotal: 'invalid' };

      await expect(service.generateQrCode(invalidInput)).rejects.toThrow('Invalid decimal');
    });

    it('should handle Arabic seller names', async () => {
      const arabicInput = {
        ...validInput,
        sellerName: 'شركة فيسلا للسيارات ذ.م.م',
      };
      const result = await service.generateQrCode(arabicInput);

      expect(result.tlvBase64).toBeTruthy();

      // Verify Arabic is preserved in TLV
      const decoded = service.decodeQrCode(result.tlvBase64);
      expect(decoded.data.sellerName).toBe('شركة فيسلا للسيارات ذ.م.م');
    });

    it('should include invoice hash when provided', async () => {
      const inputWithHash = {
        ...validInput,
        invoiceHash: 'abcdef1234567890',
      };
      const result = await service.generateQrCode(inputWithHash);

      const decoded = service.decodeQrCode(result.tlvBase64);
      expect(decoded.data.invoiceHash).toBe('abcdef1234567890');
    });

    it('should generate QR code within 100ms for typical invoices', async () => {
      const startTime = Date.now();
      await service.generateQrCode(validInput);
      const elapsed = Date.now() - startTime;

      expect(elapsed).toBeLessThan(100);
    });
  });

  describe('decodeQrCode', () => {
    it('should decode valid QR data', async () => {
      const generated = await service.generateQrCode(validInput);
      const decoded = service.decodeQrCode(generated.tlvBase64);

      expect(decoded.valid).toBe(true);
      expect(decoded.data.sellerName).toBe(validInput.sellerName);
      expect(decoded.data.sellerTrn).toBe(validInput.sellerTrn);
    });

    it('should report missing fields', () => {
      // Create minimal TLV with only seller name
      const minimal = Buffer.alloc(20);
      minimal.writeUInt8(1, 0); // Tag 1
      minimal.writeUInt8(4, 1); // Length 4
      minimal.write('Test', 2, 'utf-8');

      const decoded = service.decodeQrCode(minimal.toString('base64'));

      expect(decoded.valid).toBe(false);
      expect(decoded.missingFields).toContain('sellerTrn');
    });
  });

  describe('generateQrCodeForPdf', () => {
    it('should return data URL for PDF embedding', async () => {
      const dataUrl = await service.generateQrCodeForPdf(validInput);

      expect(dataUrl.startsWith('data:image/png;base64,')).toBe(true);
    });
  });

  describe('generateQrCodeForXml', () => {
    it('should return Base64 for XML embedding', async () => {
      const base64 = await service.generateQrCodeForXml(validInput);

      expect(typeof base64).toBe('string');
      // Should be valid Base64
      expect(() => Buffer.from(base64, 'base64')).not.toThrow();
    });
  });

  describe('TLV round-trip verification', () => {
    it('should preserve all data through encode/decode cycle', async () => {
      const result = await service.generateQrCode(validInput);
      const decoded = service.decodeQrCode(result.tlvBase64);

      expect(decoded.data.sellerName).toBe(validInput.sellerName);
      expect(decoded.data.sellerTrn).toBe(validInput.sellerTrn);
      expect(decoded.data.invoiceTotal).toBe('1050.00');
      expect(decoded.data.vatTotal).toBe('50.00');
      expect(decoded.data.timestamp?.toISOString()).toBe(
        validInput.timestamp.toISOString()
      );
    });
  });
});
```
  </action>
  <verify>Run `npm test -- --testPathPattern=qr-code.service.test.ts` - all tests should pass.</verify>
  <done>Unit tests created covering TLV encoding/decoding, QR code generation formats, Arabic UTF-8 support, validation, round-trip verification, and performance (100ms target).</done>
</task>

</tasks>

<verification>
1. TLV encoding: Manual test with known input produces expected binary output
2. QR generation: Generated QR codes scan correctly with mobile device
3. Round-trip: encodeTlv -> decodeTlv preserves all data exactly
4. Arabic: UTF-8 encoding handles Arabic seller names without corruption
5. Performance: QR code generation completes within 100ms
6. Tests: All unit tests pass
</verification>

<success_criteria>
1. TLV encoder produces correct tag-length-value format
2. QR codes generated in all four formats (base64, buffer, dataUrl, svg)
3. Arabic seller names properly UTF-8 encoded and decoded
4. TRN validation rejects invalid formats
5. QR code generation completes within 100ms for typical invoices
6. Unit tests achieve full coverage of TLV and QR functions
</success_criteria>

<output>
After completion, create `.planning/phases/06-e-invoicing-engine-core/06-02-SUMMARY.md`
</output>
