---
phase: 06-e-invoicing-engine-core
plan: 05
type: execute
wave: 3
depends_on: [06-01, 06-02]
files_modified:
  - backend/src/services/einvoice/einvoice-archive.service.ts
  - backend/src/services/einvoice/__tests__/einvoice-archive.service.test.ts
autonomous: true

must_haves:
  truths:
    - "Archives are created within Prisma transaction for atomicity"
    - "Sequence numbers are atomic and gap-free"
    - "Hash chain links each record to previous via SHA-256"
    - "Retention end date is automatically set to 7 years from creation"
    - "Archive integrity can be verified for any date range"
  artifacts:
    - path: "backend/src/services/einvoice/einvoice-archive.service.ts"
      provides: "E-invoice archive service with tamper-proof storage"
      exports: ["EInvoiceArchiveService"]
  key_links:
    - from: "einvoice-archive.service.ts"
      to: "prisma/schema.prisma"
      via: "Uses einvoice_archives model"
      pattern: "einvoice_archives\\.create|einvoice_archives\\.findMany"
    - from: "einvoice-archive.service.ts"
      to: "einvoice.types.ts"
      via: "Uses EInvoiceArchiveRecord interface"
      pattern: "EInvoiceArchiveRecord|EINVOICE_GENESIS_HASH"
---

<objective>
Create the e-invoice archive service with tamper-proof storage following Phase 2's hash chain pattern.

Purpose: EINV-05 requires 7-year retention with integrity verification. This service stores e-invoices with SHA-256 hash chains, atomic sequence numbering, and retention management.

Output:
- EInvoiceArchiveService with archiveEInvoice(), verifyIntegrity() methods
- Hash chain implementation extending Phase 2 patterns
- Retention management functions
- Unit tests for archive operations
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-e-invoicing-engine-core/06-RESEARCH.md

# Types from 06-01
@backend/src/types/einvoice.types.ts

# Phase 2 tamper-proof patterns
@backend/src/services/compliance/compliance-audit.service.ts
@backend/src/types/compliance/audit.types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create E-Invoice Archive Service</name>
  <files>backend/src/services/einvoice/einvoice-archive.service.ts</files>
  <action>
Create the archive service following Phase 2's tamper-proof patterns:

```typescript
/**
 * E-Invoice Archive Service
 * Phase: 06-e-invoicing-engine-core
 * Requirement: EINV-05 (7-year retention with integrity verification)
 *
 * Provides tamper-proof archival of e-invoices with:
 * - Atomic sequence numbering
 * - SHA-256 hash chain linking records
 * - 7-year retention management
 * - Integrity verification
 *
 * Extends Phase 2 tamper-proof patterns for FTA compliance.
 */

import { PrismaClient, Prisma, EInvoiceStatus } from '@prisma/client';
import { injectable, inject } from 'inversify';
import { createHash, randomUUID } from 'crypto';
import { TYPES } from '../../config/types';
import {
  EInvoiceArchiveRecord,
  EInvoiceValidationResult,
  TaxInvoiceData,
  EINVOICE_GENESIS_HASH,
  EINVOICE_HASH_ALGORITHM,
  EINVOICE_RETENTION_YEARS,
} from '../../types/einvoice.types';
import logger from '../logger.service';

/**
 * Archive creation input
 */
export interface ArchiveInput {
  invoice: TaxInvoiceData;
  xml: string;
  qrCodeData: string;
  validationResult?: EInvoiceValidationResult;
}

/**
 * Archive status update
 */
export interface StatusUpdate {
  status: EInvoiceStatus;
  aspSubmissionId?: string;
  aspSubmissionDate?: Date;
  aspResponseCode?: string;
  aspResponseMessage?: string;
  tddReference?: string;
  mlsStatus?: string;
}

/**
 * Integrity verification result
 */
export interface IntegrityResult {
  valid: boolean;
  totalRecords: number;
  verifiedRecords: number;
  invalidRecords: { sequenceNumber: number; reason: string }[];
  verifiedAt: Date;
}

/**
 * Retention check result
 */
export interface RetentionCheckResult {
  totalArchives: number;
  expiringSoon: number;  // Within 6 months
  expired: number;
  records: {
    id: string;
    einvoiceNumber: string;
    retentionEndDate: Date;
    status: 'active' | 'expiring' | 'expired';
  }[];
}

@injectable()
export class EInvoiceArchiveService {
  constructor(
    @inject(TYPES.PrismaClient) private readonly prisma: PrismaClient
  ) {}

  /**
   * Archives e-invoice with tamper-proof storage
   *
   * MUST be called within a Prisma transaction for atomicity.
   * The hash chain ensures any tampering is detectable.
   *
   * @param tx - Prisma transaction client
   * @param input - Archive input data
   * @returns Created archive record
   *
   * @example
   * const archive = await prisma.$transaction(async (tx) => {
   *   return archiveService.archiveEInvoice(tx, {
   *     invoice: taxInvoice,
   *     xml: xmlContent,
   *     qrCodeData: qrBase64,
   *   });
   * });
   */
  async archiveEInvoice(
    tx: Prisma.TransactionClient,
    input: ArchiveInput
  ): Promise<EInvoiceArchiveRecord> {
    const { invoice, xml, qrCodeData, validationResult } = input;

    logger.info('[EInvoiceArchive] Creating archive record', {
      invoiceNumber: invoice.invoiceNumber,
      companyId: invoice.companyId,
    });

    try {
      // Step 1: Calculate XML hash
      const xmlHash = this.calculateHash(xml);

      // Step 2: Get next sequence number (atomic via database sequence)
      const sequenceResult = await tx.$queryRaw<[{ nextval: bigint }]>`
        SELECT nextval('einvoice_archive_seq')
      `;
      const sequenceNumber = Number(sequenceResult[0].nextval);

      // Step 3: Get previous record's hash for chain
      const previousRecord = await tx.einvoice_archives.findFirst({
        where: { sequenceNumber: sequenceNumber - 1 },
        select: { recordHash: true },
      });
      const previousHash = previousRecord?.recordHash || EINVOICE_GENESIS_HASH;

      // Step 4: Calculate record hash (includes all critical fields)
      const recordData = {
        sequenceNumber,
        invoiceId: invoice.invoiceNumber,
        xmlHash,
        companyId: invoice.companyId,
        createdAt: new Date().toISOString(),
        previousHash,
      };
      const recordHash = this.calculateHash(JSON.stringify(recordData));

      // Step 5: Calculate retention end date (7 years from now)
      const retentionEndDate = new Date();
      retentionEndDate.setFullYear(retentionEndDate.getFullYear() + EINVOICE_RETENTION_YEARS);

      // Step 6: Generate e-invoice number
      const einvoiceNumber = this.generateEInvoiceNumber(invoice.invoiceNumber);

      // Step 7: Create archive record
      const archive = await tx.einvoice_archives.create({
        data: {
          id: randomUUID(),
          companyId: invoice.companyId,
          invoiceId: invoice.invoiceId,
          einvoiceNumber,
          format: 'PINT_AE',
          xmlContent: xml,
          xmlHash,
          qrCodeData,
          status: validationResult?.valid ? 'VALIDATED' : 'GENERATED',
          validationResult: validationResult ? JSON.parse(JSON.stringify(validationResult)) : null,
          validationErrors: validationResult?.errors ? JSON.parse(JSON.stringify(validationResult.errors)) : null,
          sequenceNumber,
          previousHash,
          recordHash,
          retentionEndDate,
          createdAt: new Date(),
          updatedAt: new Date(),
        },
      });

      logger.info('[EInvoiceArchive] Archive created', {
        archiveId: archive.id,
        einvoiceNumber,
        sequenceNumber,
        xmlHash: xmlHash.substring(0, 16) + '...',
      });

      return this.mapToArchiveRecord(archive);
    } catch (error) {
      logger.error('[EInvoiceArchive] Archive creation failed', {
        invoiceNumber: invoice.invoiceNumber,
        error: error instanceof Error ? error.message : 'Unknown error',
      });
      throw error;
    }
  }

  /**
   * Updates archive status (for ASP submission tracking)
   *
   * Only non-immutable fields can be updated.
   */
  async updateStatus(
    archiveId: string,
    update: StatusUpdate
  ): Promise<EInvoiceArchiveRecord> {
    logger.info('[EInvoiceArchive] Updating archive status', {
      archiveId,
      newStatus: update.status,
    });

    const archive = await this.prisma.einvoice_archives.update({
      where: { id: archiveId },
      data: {
        status: update.status,
        aspSubmissionId: update.aspSubmissionId,
        aspSubmissionDate: update.aspSubmissionDate,
        aspResponseCode: update.aspResponseCode,
        aspResponseMessage: update.aspResponseMessage,
        tddReference: update.tddReference,
        mlsStatus: update.mlsStatus,
        updatedAt: new Date(),
      },
    });

    return this.mapToArchiveRecord(archive);
  }

  /**
   * Verifies integrity of archive hash chain
   *
   * Checks that:
   * 1. Each record's previousHash matches prior record's recordHash
   * 2. Each record's recordHash can be recalculated from its data
   *
   * @param companyId - Company to verify
   * @param startDate - Optional start date filter
   * @param endDate - Optional end date filter
   * @returns Integrity verification result
   */
  async verifyIntegrity(
    companyId: string,
    startDate?: Date,
    endDate?: Date
  ): Promise<IntegrityResult> {
    logger.info('[EInvoiceArchive] Verifying integrity', {
      companyId,
      startDate,
      endDate,
    });

    const archives = await this.prisma.einvoice_archives.findMany({
      where: {
        companyId,
        ...(startDate && { createdAt: { gte: startDate } }),
        ...(endDate && { createdAt: { lte: endDate } }),
      },
      orderBy: { sequenceNumber: 'asc' },
      select: {
        sequenceNumber: true,
        invoiceId: true,
        xmlHash: true,
        companyId: true,
        createdAt: true,
        previousHash: true,
        recordHash: true,
      },
    });

    const invalidRecords: { sequenceNumber: number; reason: string }[] = [];
    let previousHash = EINVOICE_GENESIS_HASH;

    for (let i = 0; i < archives.length; i++) {
      const archive = archives[i];

      // Check chain continuity
      if (i > 0 && archive.previousHash !== previousHash) {
        invalidRecords.push({
          sequenceNumber: archive.sequenceNumber,
          reason: 'Chain break: previousHash does not match prior record',
        });
      }

      // Recalculate record hash
      const recordData = {
        sequenceNumber: archive.sequenceNumber,
        invoiceId: archive.invoiceId,
        xmlHash: archive.xmlHash,
        companyId: archive.companyId,
        createdAt: archive.createdAt.toISOString(),
        previousHash: archive.previousHash,
      };
      const expectedHash = this.calculateHash(JSON.stringify(recordData));

      if (archive.recordHash !== expectedHash) {
        invalidRecords.push({
          sequenceNumber: archive.sequenceNumber,
          reason: 'Hash mismatch: record may have been tampered with',
        });
      }

      previousHash = archive.recordHash;
    }

    const result: IntegrityResult = {
      valid: invalidRecords.length === 0,
      totalRecords: archives.length,
      verifiedRecords: archives.length - invalidRecords.length,
      invalidRecords,
      verifiedAt: new Date(),
    };

    logger.info('[EInvoiceArchive] Integrity verification complete', {
      companyId,
      valid: result.valid,
      totalRecords: result.totalRecords,
      invalidCount: invalidRecords.length,
    });

    return result;
  }

  /**
   * Retrieves archive by ID
   */
  async getArchive(archiveId: string): Promise<EInvoiceArchiveRecord | null> {
    const archive = await this.prisma.einvoice_archives.findUnique({
      where: { id: archiveId },
    });

    return archive ? this.mapToArchiveRecord(archive) : null;
  }

  /**
   * Retrieves archive by e-invoice number
   */
  async getArchiveByEInvoiceNumber(
    einvoiceNumber: string
  ): Promise<EInvoiceArchiveRecord | null> {
    const archive = await this.prisma.einvoice_archives.findUnique({
      where: { einvoiceNumber },
    });

    return archive ? this.mapToArchiveRecord(archive) : null;
  }

  /**
   * Lists archives for a company with pagination
   */
  async listArchives(
    companyId: string,
    options: {
      status?: EInvoiceStatus;
      page?: number;
      limit?: number;
      startDate?: Date;
      endDate?: Date;
    } = {}
  ): Promise<{ archives: EInvoiceArchiveRecord[]; total: number }> {
    const { status, page = 1, limit = 50, startDate, endDate } = options;

    const where: Prisma.einvoice_archivesWhereInput = {
      companyId,
      ...(status && { status }),
      ...(startDate && { createdAt: { gte: startDate } }),
      ...(endDate && { createdAt: { lte: endDate } }),
    };

    const [archives, total] = await Promise.all([
      this.prisma.einvoice_archives.findMany({
        where,
        orderBy: { createdAt: 'desc' },
        skip: (page - 1) * limit,
        take: limit,
      }),
      this.prisma.einvoice_archives.count({ where }),
    ]);

    return {
      archives: archives.map(a => this.mapToArchiveRecord(a)),
      total,
    };
  }

  /**
   * Checks retention status and returns expiring/expired records
   */
  async checkRetention(companyId: string): Promise<RetentionCheckResult> {
    const now = new Date();
    const sixMonthsFromNow = new Date();
    sixMonthsFromNow.setMonth(sixMonthsFromNow.getMonth() + 6);

    const archives = await this.prisma.einvoice_archives.findMany({
      where: { companyId },
      select: {
        id: true,
        einvoiceNumber: true,
        retentionEndDate: true,
        isRetentionExpired: true,
      },
      orderBy: { retentionEndDate: 'asc' },
    });

    const records = archives.map(archive => {
      let status: 'active' | 'expiring' | 'expired';

      if (archive.retentionEndDate < now) {
        status = 'expired';
      } else if (archive.retentionEndDate < sixMonthsFromNow) {
        status = 'expiring';
      } else {
        status = 'active';
      }

      return {
        id: archive.id,
        einvoiceNumber: archive.einvoiceNumber,
        retentionEndDate: archive.retentionEndDate,
        status,
      };
    });

    return {
      totalArchives: archives.length,
      expiringSoon: records.filter(r => r.status === 'expiring').length,
      expired: records.filter(r => r.status === 'expired').length,
      records,
    };
  }

  /**
   * Marks expired archives (for reporting only - does not delete)
   */
  async markExpiredArchives(companyId: string): Promise<number> {
    const now = new Date();

    const result = await this.prisma.einvoice_archives.updateMany({
      where: {
        companyId,
        retentionEndDate: { lt: now },
        isRetentionExpired: false,
      },
      data: {
        isRetentionExpired: true,
        updatedAt: now,
      },
    });

    logger.info('[EInvoiceArchive] Marked expired archives', {
      companyId,
      markedCount: result.count,
    });

    return result.count;
  }

  /**
   * Gets archive statistics for a company
   */
  async getStatistics(companyId: string): Promise<{
    total: number;
    byStatus: Record<string, number>;
    byMonth: { month: string; count: number }[];
  }> {
    const [total, statusCounts, monthCounts] = await Promise.all([
      this.prisma.einvoice_archives.count({ where: { companyId } }),

      this.prisma.einvoice_archives.groupBy({
        by: ['status'],
        where: { companyId },
        _count: { status: true },
      }),

      this.prisma.$queryRaw<{ month: string; count: bigint }[]>`
        SELECT
          TO_CHAR(created_at, 'YYYY-MM') as month,
          COUNT(*) as count
        FROM einvoice_archives
        WHERE company_id = ${companyId}
        GROUP BY TO_CHAR(created_at, 'YYYY-MM')
        ORDER BY month DESC
        LIMIT 12
      `,
    ]);

    const byStatus: Record<string, number> = {};
    for (const sc of statusCounts) {
      byStatus[sc.status] = sc._count.status;
    }

    return {
      total,
      byStatus,
      byMonth: monthCounts.map(m => ({
        month: m.month,
        count: Number(m.count),
      })),
    };
  }

  /**
   * Calculates SHA-256 hash
   */
  private calculateHash(data: string): string {
    return createHash(EINVOICE_HASH_ALGORITHM).update(data).digest('hex');
  }

  /**
   * Generates e-invoice number from source invoice number
   */
  private generateEInvoiceNumber(invoiceNumber: string): string {
    // Format: EI-{original}-{timestamp}
    const timestamp = Date.now().toString(36).toUpperCase();
    return `EI-${invoiceNumber}-${timestamp}`;
  }

  /**
   * Maps database record to typed interface
   */
  private mapToArchiveRecord(archive: any): EInvoiceArchiveRecord {
    return {
      id: archive.id,
      companyId: archive.companyId,
      invoiceId: archive.invoiceId,
      einvoiceNumber: archive.einvoiceNumber,
      format: archive.format,
      xmlContent: archive.xmlContent,
      xmlHash: archive.xmlHash,
      qrCodeData: archive.qrCodeData,
      status: archive.status,
      validationResult: archive.validationResult,
      validationErrors: archive.validationErrors,
      aspSubmissionId: archive.aspSubmissionId,
      aspSubmissionDate: archive.aspSubmissionDate,
      aspResponseCode: archive.aspResponseCode,
      aspResponseMessage: archive.aspResponseMessage,
      tddReference: archive.tddReference,
      mlsStatus: archive.mlsStatus,
      sequenceNumber: archive.sequenceNumber,
      previousHash: archive.previousHash,
      recordHash: archive.recordHash,
      retentionEndDate: archive.retentionEndDate,
      isRetentionExpired: archive.isRetentionExpired,
      createdAt: archive.createdAt,
      updatedAt: archive.updatedAt,
    };
  }
}

export default EInvoiceArchiveService;
```

Update the index file:

```typescript
// backend/src/services/einvoice/index.ts
export * from './qr-code.service';
export * from './pint-ae-builder.service';
export * from './ubl-validator.service';
export * from './einvoice-archive.service';
```
  </action>
  <verify>Run `npx tsc --noEmit` to verify TypeScript compilation.</verify>
  <done>EInvoiceArchiveService created with archiveEInvoice(), verifyIntegrity(), checkRetention() methods. Implements hash chain pattern from Phase 2.</done>
</task>

<task type="auto">
  <name>Task 2: Create Archive Service Unit Tests</name>
  <files>backend/src/services/einvoice/__tests__/einvoice-archive.service.test.ts</files>
  <action>
Create unit tests for archive operations:

```typescript
/**
 * E-Invoice Archive Service Tests
 * Phase: 06-e-invoicing-engine-core
 * Requirement: EINV-05 (7-year retention with integrity verification)
 */

import { EInvoiceArchiveService, ArchiveInput } from '../einvoice-archive.service';
import { TaxInvoiceData, EINVOICE_GENESIS_HASH, EINVOICE_RETENTION_YEARS } from '../../../types/einvoice.types';
import { createHash } from 'crypto';

// Mock Prisma client
const mockPrismaClient = {
  einvoice_archives: {
    create: jest.fn(),
    findUnique: jest.fn(),
    findFirst: jest.fn(),
    findMany: jest.fn(),
    update: jest.fn(),
    updateMany: jest.fn(),
    count: jest.fn(),
    groupBy: jest.fn(),
  },
  $queryRaw: jest.fn(),
  $transaction: jest.fn((callback: (tx: any) => Promise<any>) => callback(mockPrismaClient)),
};

// Mock transaction client (same methods as prisma)
const mockTxClient = {
  einvoice_archives: mockPrismaClient.einvoice_archives,
  $queryRaw: mockPrismaClient.$queryRaw,
};

describe('EInvoiceArchiveService', () => {
  let service: EInvoiceArchiveService;

  const createValidInvoice = (): TaxInvoiceData => ({
    invoiceId: 'inv-001',
    invoiceNumber: 'INV-2026-0001',
    companyId: 'company-001',
    invoiceDate: new Date('2026-01-24'),
    supplierName: 'Vesla Motors LLC',
    supplierTrn: '100123456789012',
    supplierAddress: 'Dubai',
    supplierCountry: 'AE',
    recipientName: 'ABC Trading',
    recipientAddress: 'Dubai',
    subtotal: 1000,
    vatAmount: 50,
    totalAmount: 1050,
    currency: 'AED',
    vatRate: 5,
    isReverseCharge: false,
    lineItems: [{
      lineNumber: 1,
      description: 'Test item',
      quantity: 1,
      unitCode: 'EA',
      unitPrice: 1000,
      lineTotal: 1000,
      vatRate: 5,
      vatAmount: 50,
    }],
    createdById: 'user-001',
  });

  const createArchiveInput = (): ArchiveInput => ({
    invoice: createValidInvoice(),
    xml: '<?xml version="1.0"?><Invoice>...</Invoice>',
    qrCodeData: 'base64encodedqrdata',
    validationResult: {
      valid: true,
      errors: [],
      warnings: [],
      validatedAt: new Date(),
    },
  });

  beforeEach(() => {
    jest.clearAllMocks();
    service = new EInvoiceArchiveService(mockPrismaClient as any);

    // Default mock implementations
    mockPrismaClient.$queryRaw.mockResolvedValue([{ nextval: BigInt(1) }]);
    mockPrismaClient.einvoice_archives.findFirst.mockResolvedValue(null);
    mockPrismaClient.einvoice_archives.create.mockImplementation(async (args) => ({
      ...args.data,
      id: 'archive-001',
    }));
  });

  describe('archiveEInvoice', () => {
    it('should create archive with correct hash chain', async () => {
      const input = createArchiveInput();

      const result = await service.archiveEInvoice(mockTxClient as any, input);

      expect(mockPrismaClient.einvoice_archives.create).toHaveBeenCalled();
      expect(result.sequenceNumber).toBe(1);
      expect(result.previousHash).toBe(EINVOICE_GENESIS_HASH);
      expect(result.recordHash).toBeDefined();
      expect(result.xmlHash).toBeDefined();
    });

    it('should link to previous record hash', async () => {
      const input = createArchiveInput();
      const previousHash = 'previousrecordhash123';

      mockPrismaClient.$queryRaw.mockResolvedValue([{ nextval: BigInt(2) }]);
      mockPrismaClient.einvoice_archives.findFirst.mockResolvedValue({
        recordHash: previousHash,
      });

      const result = await service.archiveEInvoice(mockTxClient as any, input);

      expect(result.sequenceNumber).toBe(2);
      expect(result.previousHash).toBe(previousHash);
    });

    it('should calculate correct XML hash', async () => {
      const input = createArchiveInput();
      const expectedXmlHash = createHash('sha256').update(input.xml).digest('hex');

      const result = await service.archiveEInvoice(mockTxClient as any, input);

      expect(result.xmlHash).toBe(expectedXmlHash);
    });

    it('should set retention end date 7 years from now', async () => {
      const input = createArchiveInput();
      const now = new Date();
      const expectedYear = now.getFullYear() + EINVOICE_RETENTION_YEARS;

      const result = await service.archiveEInvoice(mockTxClient as any, input);

      expect(result.retentionEndDate.getFullYear()).toBe(expectedYear);
    });

    it('should generate unique e-invoice number', async () => {
      const input = createArchiveInput();

      const result = await service.archiveEInvoice(mockTxClient as any, input);

      expect(result.einvoiceNumber).toContain('EI-');
      expect(result.einvoiceNumber).toContain(input.invoice.invoiceNumber);
    });

    it('should set status to VALIDATED when validation passes', async () => {
      const input = createArchiveInput();
      input.validationResult = { valid: true, errors: [], warnings: [], validatedAt: new Date() };

      const result = await service.archiveEInvoice(mockTxClient as any, input);

      expect(result.status).toBe('VALIDATED');
    });

    it('should set status to GENERATED when validation fails', async () => {
      const input = createArchiveInput();
      input.validationResult = {
        valid: false,
        errors: [{ code: 'ERR', message: 'Error', severity: 'error' }],
        warnings: [],
        validatedAt: new Date(),
      };

      const result = await service.archiveEInvoice(mockTxClient as any, input);

      expect(result.status).toBe('GENERATED');
    });
  });

  describe('updateStatus', () => {
    it('should update archive status', async () => {
      mockPrismaClient.einvoice_archives.update.mockResolvedValue({
        id: 'archive-001',
        status: 'SUBMITTED',
        aspSubmissionId: 'asp-123',
        aspSubmissionDate: new Date(),
      });

      const result = await service.updateStatus('archive-001', {
        status: 'SUBMITTED',
        aspSubmissionId: 'asp-123',
        aspSubmissionDate: new Date(),
      });

      expect(result.status).toBe('SUBMITTED');
      expect(result.aspSubmissionId).toBe('asp-123');
    });
  });

  describe('verifyIntegrity', () => {
    it('should return valid for correct hash chain', async () => {
      const records = [
        {
          sequenceNumber: 1,
          invoiceId: 'inv-001',
          xmlHash: 'hash1',
          companyId: 'company-001',
          createdAt: new Date('2026-01-01'),
          previousHash: EINVOICE_GENESIS_HASH,
          recordHash: '', // Will be calculated
        },
      ];

      // Calculate correct hash for first record
      const recordData = {
        sequenceNumber: 1,
        invoiceId: 'inv-001',
        xmlHash: 'hash1',
        companyId: 'company-001',
        createdAt: records[0].createdAt.toISOString(),
        previousHash: EINVOICE_GENESIS_HASH,
      };
      records[0].recordHash = createHash('sha256').update(JSON.stringify(recordData)).digest('hex');

      mockPrismaClient.einvoice_archives.findMany.mockResolvedValue(records);

      const result = await service.verifyIntegrity('company-001');

      expect(result.valid).toBe(true);
      expect(result.totalRecords).toBe(1);
      expect(result.verifiedRecords).toBe(1);
      expect(result.invalidRecords).toHaveLength(0);
    });

    it('should detect broken chain', async () => {
      const records = [
        {
          sequenceNumber: 1,
          invoiceId: 'inv-001',
          xmlHash: 'hash1',
          companyId: 'company-001',
          createdAt: new Date('2026-01-01'),
          previousHash: EINVOICE_GENESIS_HASH,
          recordHash: 'correcthash1',
        },
        {
          sequenceNumber: 2,
          invoiceId: 'inv-002',
          xmlHash: 'hash2',
          companyId: 'company-001',
          createdAt: new Date('2026-01-02'),
          previousHash: 'WRONG_HASH', // Should be 'correcthash1'
          recordHash: 'somehash',
        },
      ];

      mockPrismaClient.einvoice_archives.findMany.mockResolvedValue(records);

      const result = await service.verifyIntegrity('company-001');

      expect(result.valid).toBe(false);
      expect(result.invalidRecords.length).toBeGreaterThan(0);
      expect(result.invalidRecords.some(r => r.reason.includes('Chain break'))).toBe(true);
    });

    it('should detect tampered record hash', async () => {
      const records = [
        {
          sequenceNumber: 1,
          invoiceId: 'inv-001',
          xmlHash: 'hash1',
          companyId: 'company-001',
          createdAt: new Date('2026-01-01'),
          previousHash: EINVOICE_GENESIS_HASH,
          recordHash: 'TAMPERED_HASH', // Should fail recalculation
        },
      ];

      mockPrismaClient.einvoice_archives.findMany.mockResolvedValue(records);

      const result = await service.verifyIntegrity('company-001');

      expect(result.valid).toBe(false);
      expect(result.invalidRecords.some(r => r.reason.includes('Hash mismatch'))).toBe(true);
    });

    it('should support date range filtering', async () => {
      const startDate = new Date('2026-01-01');
      const endDate = new Date('2026-12-31');

      mockPrismaClient.einvoice_archives.findMany.mockResolvedValue([]);

      await service.verifyIntegrity('company-001', startDate, endDate);

      expect(mockPrismaClient.einvoice_archives.findMany).toHaveBeenCalledWith(
        expect.objectContaining({
          where: expect.objectContaining({
            createdAt: { gte: startDate, lte: endDate },
          }),
        })
      );
    });
  });

  describe('checkRetention', () => {
    it('should identify expiring archives', async () => {
      const now = new Date();
      const threeMonthsFromNow = new Date();
      threeMonthsFromNow.setMonth(now.getMonth() + 3);

      mockPrismaClient.einvoice_archives.findMany.mockResolvedValue([
        {
          id: 'archive-001',
          einvoiceNumber: 'EI-001',
          retentionEndDate: threeMonthsFromNow,
          isRetentionExpired: false,
        },
      ]);

      const result = await service.checkRetention('company-001');

      expect(result.expiringSoon).toBe(1);
      expect(result.records[0].status).toBe('expiring');
    });

    it('should identify expired archives', async () => {
      const pastDate = new Date();
      pastDate.setMonth(pastDate.getMonth() - 1);

      mockPrismaClient.einvoice_archives.findMany.mockResolvedValue([
        {
          id: 'archive-001',
          einvoiceNumber: 'EI-001',
          retentionEndDate: pastDate,
          isRetentionExpired: true,
        },
      ]);

      const result = await service.checkRetention('company-001');

      expect(result.expired).toBe(1);
      expect(result.records[0].status).toBe('expired');
    });
  });

  describe('listArchives', () => {
    it('should return paginated archives', async () => {
      mockPrismaClient.einvoice_archives.findMany.mockResolvedValue([
        { id: 'archive-001', einvoiceNumber: 'EI-001' },
      ]);
      mockPrismaClient.einvoice_archives.count.mockResolvedValue(10);

      const result = await service.listArchives('company-001', { page: 1, limit: 5 });

      expect(result.archives).toHaveLength(1);
      expect(result.total).toBe(10);
    });

    it('should filter by status', async () => {
      mockPrismaClient.einvoice_archives.findMany.mockResolvedValue([]);
      mockPrismaClient.einvoice_archives.count.mockResolvedValue(0);

      await service.listArchives('company-001', { status: 'SUBMITTED' });

      expect(mockPrismaClient.einvoice_archives.findMany).toHaveBeenCalledWith(
        expect.objectContaining({
          where: expect.objectContaining({
            status: 'SUBMITTED',
          }),
        })
      );
    });
  });

  describe('getStatistics', () => {
    it('should return archive statistics', async () => {
      mockPrismaClient.einvoice_archives.count.mockResolvedValue(100);
      mockPrismaClient.einvoice_archives.groupBy.mockResolvedValue([
        { status: 'VALIDATED', _count: { status: 50 } },
        { status: 'SUBMITTED', _count: { status: 30 } },
        { status: 'ACCEPTED', _count: { status: 20 } },
      ]);
      mockPrismaClient.$queryRaw.mockResolvedValue([
        { month: '2026-01', count: BigInt(25) },
        { month: '2025-12', count: BigInt(20) },
      ]);

      const result = await service.getStatistics('company-001');

      expect(result.total).toBe(100);
      expect(result.byStatus['VALIDATED']).toBe(50);
      expect(result.byMonth).toHaveLength(2);
    });
  });
});
```
  </action>
  <verify>Run `npm test -- --testPathPattern=einvoice-archive.service.test.ts` - all tests should pass.</verify>
  <done>Unit tests created covering archive creation, hash chain verification, retention checking, pagination, and statistics.</done>
</task>

</tasks>

<verification>
1. Archive creation: Uses Prisma transaction with atomic sequence
2. Hash chain: Previous record's hash linked to next
3. Integrity check: Detects both chain breaks and hash tampering
4. Retention: 7-year end date calculated correctly
5. Tests: All unit tests pass
</verification>

<success_criteria>
1. archiveEInvoice() creates record with hash chain within transaction
2. verifyIntegrity() detects chain breaks and hash tampering
3. Sequence numbers are atomic and gap-free
4. Retention end date automatically set to 7 years
5. Status updates preserve immutable fields
</success_criteria>

<output>
After completion, create `.planning/phases/06-e-invoicing-engine-core/06-05-SUMMARY.md`
</output>
