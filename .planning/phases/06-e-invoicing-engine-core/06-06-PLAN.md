---
phase: 06-e-invoicing-engine-core
plan: 06
type: execute
wave: 4
depends_on: [06-02, 06-03, 06-04, 06-05]
files_modified:
  - backend/src/services/einvoice/einvoice.service.ts
  - backend/src/services/einvoice/asp-client.interface.ts
  - backend/src/config/types.ts
  - backend/src/config/container.ts
  - backend/src/services/einvoice/__tests__/einvoice.service.test.ts
autonomous: true

must_haves:
  truths:
    - "E-invoice generation orchestrates all sub-services in correct order"
    - "Validation failures block archiving with clear error messages"
    - "QR code is embedded in generated e-invoice XML"
    - "All operations run within single database transaction"
    - "Audit log created for every e-invoice generation"
    - "ASP client interface defined for Phase 7 integration"
  artifacts:
    - path: "backend/src/services/einvoice/einvoice.service.ts"
      provides: "E-invoice orchestration service"
      exports: ["EInvoiceService"]
    - path: "backend/src/services/einvoice/asp-client.interface.ts"
      provides: "ASP client interface stub for Phase 7"
      exports: ["IAspClient", "AspSubmissionResult", "AspClientStub"]
    - path: "backend/src/config/types.ts"
      provides: "DI type symbols for e-invoice services"
      contains: "EInvoiceService"
  key_links:
    - from: "einvoice.service.ts"
      to: "pint-ae-builder.service.ts"
      via: "DI injection"
      pattern: "PintAeBuilderService"
    - from: "einvoice.service.ts"
      to: "ubl-validator.service.ts"
      via: "DI injection"
      pattern: "UblValidatorService"
    - from: "einvoice.service.ts"
      to: "qr-code.service.ts"
      via: "DI injection"
      pattern: "QrCodeService"
    - from: "einvoice.service.ts"
      to: "einvoice-archive.service.ts"
      via: "DI injection"
      pattern: "EInvoiceArchiveService"
    - from: "einvoice.service.ts"
      to: "asp-client.interface.ts"
      via: "DI injection (stub)"
      pattern: "IAspClient|AspClientStub"
---

<objective>
Create the main e-invoice orchestration service that coordinates XML generation, validation, QR code creation, and archival. Also define ASP client interface for Phase 7.

Purpose: EINV-01 through EINV-05 require an integrated workflow for e-invoice generation. This service orchestrates all components in the correct order, ensuring validation before archival and proper audit logging. EINV-06 requires ASP API integration - this plan defines the interface, with implementation deferred to Phase 7.

Output:
- EInvoiceService with generateEInvoice() method
- IAspClient interface and AspClientStub for Phase 7
- DI container registration for all e-invoice services
- Audit logging integration using EINVOICE_GENERATE action
- Unit tests for orchestration flow
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-e-invoicing-engine-core/06-RESEARCH.md

# Services from prior plans
# 06-02: QrCodeService
# 06-03: PintAeBuilderService
# 06-04: UblValidatorService
# 06-05: EInvoiceArchiveService

# DI configuration
@backend/src/config/types.ts
@backend/src/config/container.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ASP Client Interface and Stub</name>
  <files>backend/src/services/einvoice/asp-client.interface.ts</files>
  <action>
Create the ASP client interface for EINV-06 (Phase 7 implementation):

```typescript
/**
 * ASP Client Interface
 * Phase: 06-e-invoicing-engine-core
 * Requirement: EINV-06 (ASP API integration)
 *
 * Defines the interface for Accredited Service Provider (ASP) communication.
 * The actual implementation will be provided in Phase 7.
 * This stub allows Phase 6 to compile and test without ASP connectivity.
 *
 * Note: EINV-06 is split between Phase 6 (interface) and Phase 7 (implementation).
 */

import { injectable } from 'inversify';
import logger from '../logger.service';

/**
 * ASP submission request
 */
export interface AspSubmissionRequest {
  einvoiceId: string;
  einvoiceNumber: string;
  companyId: string;
  xml: string;
  xmlHash: string;
  format: 'PINT_AE' | 'UBL_21';
  invoiceType: 'INVOICE' | 'CREDIT_NOTE';
  submitterTrn: string;
}

/**
 * ASP submission result
 */
export interface AspSubmissionResult {
  success: boolean;
  submissionId?: string;
  tddReference?: string;  // Tax Data Document reference
  mlsStatus?: string;     // Message Level Status
  responseCode?: string;
  responseMessage?: string;
  errors?: AspSubmissionError[];
  submittedAt?: Date;
}

/**
 * ASP submission error
 */
export interface AspSubmissionError {
  code: string;
  message: string;
  element?: string;
  severity: 'error' | 'warning';
}

/**
 * ASP status query result
 */
export interface AspStatusResult {
  einvoiceId: string;
  submissionId: string;
  status: 'PENDING' | 'PROCESSING' | 'ACCEPTED' | 'REJECTED' | 'ERROR';
  tddReference?: string;
  mlsStatus?: string;
  lastUpdated: Date;
  errors?: AspSubmissionError[];
}

/**
 * ASP client interface
 * Implementation will be provided in Phase 7
 */
export interface IAspClient {
  /**
   * Submit e-invoice to ASP
   */
  submitEInvoice(request: AspSubmissionRequest): Promise<AspSubmissionResult>;

  /**
   * Check submission status
   */
  checkStatus(submissionId: string): Promise<AspStatusResult>;

  /**
   * Cancel a pending submission
   */
  cancelSubmission(submissionId: string): Promise<{ success: boolean; message?: string }>;

  /**
   * Test ASP connectivity
   */
  testConnection(): Promise<{ connected: boolean; latencyMs?: number; error?: string }>;

  /**
   * Get ASP configuration status
   */
  isConfigured(): boolean;
}

/**
 * ASP Client Stub
 * Phase 6 placeholder - returns "not configured" for all operations.
 * Phase 7 will replace this with actual ASP implementation.
 */
@injectable()
export class AspClientStub implements IAspClient {
  /**
   * Stub: Returns not-configured result
   */
  async submitEInvoice(request: AspSubmissionRequest): Promise<AspSubmissionResult> {
    logger.info('[AspClientStub] Submit called (stub - not configured)', {
      einvoiceNumber: request.einvoiceNumber,
    });

    return {
      success: false,
      responseCode: 'ASP_NOT_CONFIGURED',
      responseMessage: 'ASP integration not configured. E-invoice stored locally pending Phase 7 ASP implementation.',
      errors: [
        {
          code: 'ASP_NOT_CONFIGURED',
          message: 'ASP client is a stub. Configure ASP credentials in Phase 7.',
          severity: 'warning',
        },
      ],
    };
  }

  /**
   * Stub: Returns not-configured status
   */
  async checkStatus(submissionId: string): Promise<AspStatusResult> {
    logger.info('[AspClientStub] Check status called (stub)', {
      submissionId,
    });

    return {
      einvoiceId: '',
      submissionId,
      status: 'ERROR',
      lastUpdated: new Date(),
      errors: [
        {
          code: 'ASP_NOT_CONFIGURED',
          message: 'ASP client is a stub. Cannot check status.',
          severity: 'error',
        },
      ],
    };
  }

  /**
   * Stub: Returns not-configured result
   */
  async cancelSubmission(submissionId: string): Promise<{ success: boolean; message?: string }> {
    logger.info('[AspClientStub] Cancel called (stub)', {
      submissionId,
    });

    return {
      success: false,
      message: 'ASP client is a stub. Cannot cancel submission.',
    };
  }

  /**
   * Stub: Returns disconnected
   */
  async testConnection(): Promise<{ connected: boolean; latencyMs?: number; error?: string }> {
    logger.info('[AspClientStub] Test connection called (stub)');

    return {
      connected: false,
      error: 'ASP client is a stub. Configure ASP credentials in Phase 7.',
    };
  }

  /**
   * Stub: Returns false
   */
  isConfigured(): boolean {
    return false;
  }
}

export default AspClientStub;
```
  </action>
  <verify>Run `npx tsc --noEmit` to verify TypeScript compilation.</verify>
  <done>ASP client interface and stub created for EINV-06. Interface defines submitEInvoice(), checkStatus(), cancelSubmission(), testConnection(). Stub returns not-configured for all operations, allowing Phase 6 to compile without ASP connectivity.</done>
</task>

<task type="auto">
  <name>Task 2: Create E-Invoice Orchestration Service</name>
  <files>backend/src/services/einvoice/einvoice.service.ts</files>
  <action>
Create the main e-invoice service that orchestrates all components:

```typescript
/**
 * E-Invoice Service
 * Phase: 06-e-invoicing-engine-core
 * Requirements: EINV-01 through EINV-06
 *
 * Main orchestration service for e-invoice generation.
 * Coordinates:
 * 1. PINT AE XML generation (with embedded QR code)
 * 2. UBL 2.1 schema validation
 * 3. QR code generation with TLV encoding
 * 4. Tamper-proof archival
 * 5. Audit logging (using EINVOICE_GENERATE action)
 * 6. ASP submission (via IAspClient - stub until Phase 7)
 */

import { PrismaClient } from '@prisma/client';
import { injectable, inject } from 'inversify';
import { createHash, randomUUID } from 'crypto';
import { TYPES } from '../../config/types';
import { PintAeBuilderService } from './pint-ae-builder.service';
import { UblValidatorService } from './ubl-validator.service';
import { QrCodeService, QrCodeInput } from './qr-code.service';
import { EInvoiceArchiveService, ArchiveInput } from './einvoice-archive.service';
import { IAspClient, AspSubmissionRequest, AspSubmissionResult } from './asp-client.interface';
import {
  TaxInvoiceData,
  EInvoiceResult,
  EInvoiceArchiveRecord,
  EInvoiceValidationResult,
} from '../../types/einvoice.types';
import logger from '../logger.service';

/**
 * E-invoice generation options
 */
export interface GenerateOptions {
  /** Skip validation (use for regeneration of known-valid invoices) */
  skipValidation?: boolean;
  /** Include QR code in output */
  includeQrCode?: boolean;
  /** User ID for audit logging */
  userId: string;
  /** Auto-submit to ASP after generation (Phase 7) */
  autoSubmit?: boolean;
}

/**
 * Credit note generation options
 */
export interface CreditNoteOptions extends GenerateOptions {
  /** Original invoice number (mandatory for credit notes) */
  originalInvoiceNumber: string;
}

/**
 * Generation result with full details
 */
export interface GenerationResult {
  success: boolean;
  einvoice: {
    id: string;
    einvoiceNumber: string;
    xml: string;
    qrCode?: string;
    xmlHash: string;
    status: string;
  } | null;
  validation: EInvoiceValidationResult | null;
  aspSubmission?: AspSubmissionResult;
  errors: string[];
}

@injectable()
export class EInvoiceService {
  constructor(
    @inject(TYPES.PrismaClient) private readonly prisma: PrismaClient,
    @inject(TYPES.PintAeBuilderService) private readonly pintAeBuilder: PintAeBuilderService,
    @inject(TYPES.UblValidatorService) private readonly validator: UblValidatorService,
    @inject(TYPES.QrCodeService) private readonly qrCodeService: QrCodeService,
    @inject(TYPES.EInvoiceArchiveService) private readonly archiveService: EInvoiceArchiveService,
    @inject(TYPES.AspClient) private readonly aspClient: IAspClient
  ) {}

  /**
   * Generates a complete PINT AE e-invoice from tax invoice data
   *
   * Flow:
   * 1. Generate QR code with TLV encoding
   * 2. Build PINT AE XML from TaxInvoiceData (with embedded QR)
   * 3. Validate XML against UBL 2.1 and PINT AE rules
   * 4. Archive with tamper-proof storage
   * 5. Create audit log entry (EINVOICE_GENERATE)
   * 6. Optionally submit to ASP (Phase 7)
   *
   * @param invoice - Source tax invoice data (from Phase 3)
   * @param options - Generation options
   * @returns Generation result with e-invoice or errors
   *
   * @example
   * const result = await einvoiceService.generateEInvoice(taxInvoice, {
   *   userId: 'user-123',
   *   includeQrCode: true,
   * });
   *
   * if (result.success) {
   *   console.log('E-invoice:', result.einvoice.einvoiceNumber);
   * } else {
   *   console.log('Errors:', result.errors);
   * }
   */
  async generateEInvoice(
    invoice: TaxInvoiceData,
    options: GenerateOptions
  ): Promise<GenerationResult> {
    const { userId, skipValidation = false, includeQrCode = true, autoSubmit = false } = options;

    logger.info('[EInvoiceService] Starting e-invoice generation', {
      invoiceNumber: invoice.invoiceNumber,
      companyId: invoice.companyId,
      userId,
      includeQrCode,
      autoSubmit,
    });

    const errors: string[] = [];
    let validationResult: EInvoiceValidationResult | null = null;
    let aspSubmission: AspSubmissionResult | undefined;

    try {
      // Step 1: Generate QR code FIRST (needed for XML embedding)
      let qrCodeBase64: string | undefined;
      let qrCodeTlv: string | undefined;

      if (includeQrCode) {
        logger.info('[EInvoiceService] Generating QR code');
        const qrInput: QrCodeInput = {
          sellerName: invoice.supplierName,
          sellerTrn: invoice.supplierTrn,
          timestamp: invoice.invoiceDate,
          invoiceTotal: invoice.totalAmount.toFixed(2),
          vatTotal: invoice.vatAmount.toFixed(2),
        };

        const qrResult = await this.qrCodeService.generateQrCode(qrInput, {
          format: 'base64',
        });
        qrCodeBase64 = qrResult.data as string;
        qrCodeTlv = qrResult.tlvBase64;
      }

      // Step 2: Build PINT AE XML with embedded QR code
      logger.info('[EInvoiceService] Building PINT AE XML');
      const xml = this.pintAeBuilder.buildInvoiceXml(invoice, qrCodeBase64);
      const xmlHash = this.calculateHash(xml);

      // Update QR with XML hash (re-generate for hash inclusion)
      if (includeQrCode) {
        const qrInputWithHash: QrCodeInput = {
          sellerName: invoice.supplierName,
          sellerTrn: invoice.supplierTrn,
          timestamp: invoice.invoiceDate,
          invoiceTotal: invoice.totalAmount.toFixed(2),
          vatTotal: invoice.vatAmount.toFixed(2),
          invoiceHash: xmlHash,
        };
        const finalQr = await this.qrCodeService.generateQrCode(qrInputWithHash, {
          format: 'base64',
        });
        qrCodeTlv = finalQr.tlvBase64;
      }

      // Step 3: Validate XML (unless skipped)
      if (!skipValidation) {
        logger.info('[EInvoiceService] Validating XML');
        validationResult = await this.validator.validateInvoice(xml);

        if (!validationResult.valid) {
          logger.warn('[EInvoiceService] Validation failed', {
            errorCount: validationResult.errors.length,
            invoiceNumber: invoice.invoiceNumber,
          });

          // Return validation errors without archiving
          return {
            success: false,
            einvoice: null,
            validation: validationResult,
            errors: validationResult.errors.map(e => `${e.code}: ${e.message}`),
          };
        }
      }

      // Step 4: Archive in transaction with audit log
      logger.info('[EInvoiceService] Archiving e-invoice');
      const archive = await this.prisma.$transaction(async (tx) => {
        // Create archive
        const archiveInput: ArchiveInput = {
          invoice,
          xml,
          qrCodeData: qrCodeTlv || '',
          validationResult: validationResult || undefined,
        };

        const archived = await this.archiveService.archiveEInvoice(tx, archiveInput);

        // Create audit log with EINVOICE_GENERATE action
        await tx.auditLogs.create({
          data: {
            id: randomUUID(),
            userId,
            action: 'EINVOICE_GENERATE',
            entity: 'EInvoice',
            entityId: archived.id,
            newValue: {
              invoiceId: invoice.invoiceId,
              einvoiceNumber: archived.einvoiceNumber,
              xmlHash: archived.xmlHash,
              status: archived.status,
            },
            companyId: invoice.companyId,
            createdAt: new Date(),
          },
        });

        return archived;
      });

      logger.info('[EInvoiceService] E-invoice generated successfully', {
        einvoiceNumber: archive.einvoiceNumber,
        archiveId: archive.id,
        status: archive.status,
      });

      // Step 5: Optionally submit to ASP (Phase 7)
      if (autoSubmit && this.aspClient.isConfigured()) {
        logger.info('[EInvoiceService] Submitting to ASP');
        const aspRequest: AspSubmissionRequest = {
          einvoiceId: archive.id,
          einvoiceNumber: archive.einvoiceNumber,
          companyId: invoice.companyId,
          xml,
          xmlHash,
          format: 'PINT_AE',
          invoiceType: 'INVOICE',
          submitterTrn: invoice.supplierTrn,
        };
        aspSubmission = await this.aspClient.submitEInvoice(aspRequest);
      }

      return {
        success: true,
        einvoice: {
          id: archive.id,
          einvoiceNumber: archive.einvoiceNumber,
          xml,
          qrCode: qrCodeTlv,
          xmlHash,
          status: archive.status,
        },
        validation: validationResult,
        aspSubmission,
        errors: [],
      };
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      logger.error('[EInvoiceService] E-invoice generation failed', {
        invoiceNumber: invoice.invoiceNumber,
        error: errorMessage,
      });

      errors.push(`Generation failed: ${errorMessage}`);

      return {
        success: false,
        einvoice: null,
        validation: validationResult,
        errors,
      };
    }
  }

  /**
   * Generates a credit note e-invoice
   *
   * @param creditNote - Credit note data
   * @param options - Credit note options (must include originalInvoiceNumber)
   */
  async generateCreditNote(
    creditNote: TaxInvoiceData,
    options: CreditNoteOptions
  ): Promise<GenerationResult> {
    const { originalInvoiceNumber, userId, skipValidation = false, includeQrCode = true, autoSubmit = false } = options;

    logger.info('[EInvoiceService] Starting credit note generation', {
      creditNoteNumber: creditNote.invoiceNumber,
      originalInvoice: originalInvoiceNumber,
      userId,
    });

    const errors: string[] = [];
    let validationResult: EInvoiceValidationResult | null = null;
    let aspSubmission: AspSubmissionResult | undefined;

    try {
      // Step 1: Generate QR code
      let qrCodeBase64: string | undefined;
      let qrCodeTlv: string | undefined;

      if (includeQrCode) {
        const qrInput: QrCodeInput = {
          sellerName: creditNote.supplierName,
          sellerTrn: creditNote.supplierTrn,
          timestamp: creditNote.invoiceDate,
          invoiceTotal: creditNote.totalAmount.toFixed(2),
          vatTotal: creditNote.vatAmount.toFixed(2),
        };

        const qrResult = await this.qrCodeService.generateQrCode(qrInput);
        qrCodeBase64 = qrResult.data as string;
        qrCodeTlv = qrResult.tlvBase64;
      }

      // Step 2: Build credit note XML with embedded QR
      const xml = this.pintAeBuilder.buildCreditNoteXml(creditNote, originalInvoiceNumber, qrCodeBase64);
      const xmlHash = this.calculateHash(xml);

      // Update QR with hash
      if (includeQrCode) {
        const qrInputWithHash: QrCodeInput = {
          sellerName: creditNote.supplierName,
          sellerTrn: creditNote.supplierTrn,
          timestamp: creditNote.invoiceDate,
          invoiceTotal: creditNote.totalAmount.toFixed(2),
          vatTotal: creditNote.vatAmount.toFixed(2),
          invoiceHash: xmlHash,
        };
        const finalQr = await this.qrCodeService.generateQrCode(qrInputWithHash);
        qrCodeTlv = finalQr.tlvBase64;
      }

      // Step 3: Validate
      if (!skipValidation) {
        validationResult = await this.validator.validateInvoice(xml);

        if (!validationResult.valid) {
          return {
            success: false,
            einvoice: null,
            validation: validationResult,
            errors: validationResult.errors.map(e => `${e.code}: ${e.message}`),
          };
        }
      }

      // Step 4: Archive with audit
      const archive = await this.prisma.$transaction(async (tx) => {
        const archiveInput: ArchiveInput = {
          invoice: creditNote,
          xml,
          qrCodeData: qrCodeTlv || '',
          validationResult: validationResult || undefined,
        };

        const archived = await this.archiveService.archiveEInvoice(tx, archiveInput);

        await tx.auditLogs.create({
          data: {
            id: randomUUID(),
            userId,
            action: 'EINVOICE_GENERATE',
            entity: 'EInvoice',
            entityId: archived.id,
            newValue: {
              type: 'CreditNote',
              creditNoteNumber: creditNote.invoiceNumber,
              originalInvoice: originalInvoiceNumber,
              xmlHash: archived.xmlHash,
            },
            companyId: creditNote.companyId,
            createdAt: new Date(),
          },
        });

        return archived;
      });

      // Step 5: Optionally submit to ASP
      if (autoSubmit && this.aspClient.isConfigured()) {
        const aspRequest: AspSubmissionRequest = {
          einvoiceId: archive.id,
          einvoiceNumber: archive.einvoiceNumber,
          companyId: creditNote.companyId,
          xml,
          xmlHash,
          format: 'PINT_AE',
          invoiceType: 'CREDIT_NOTE',
          submitterTrn: creditNote.supplierTrn,
        };
        aspSubmission = await this.aspClient.submitEInvoice(aspRequest);
      }

      return {
        success: true,
        einvoice: {
          id: archive.id,
          einvoiceNumber: archive.einvoiceNumber,
          xml,
          qrCode: qrCodeTlv,
          xmlHash,
          status: archive.status,
        },
        validation: validationResult,
        aspSubmission,
        errors: [],
      };
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      errors.push(`Credit note generation failed: ${errorMessage}`);

      return {
        success: false,
        einvoice: null,
        validation: validationResult,
        errors,
      };
    }
  }

  /**
   * Submit existing e-invoice to ASP
   * (For e-invoices generated without autoSubmit)
   */
  async submitToAsp(archiveId: string, userId: string): Promise<AspSubmissionResult> {
    const archive = await this.archiveService.getArchive(archiveId);
    if (!archive) {
      return {
        success: false,
        responseCode: 'NOT_FOUND',
        responseMessage: `E-invoice archive ${archiveId} not found`,
      };
    }

    if (!this.aspClient.isConfigured()) {
      return {
        success: false,
        responseCode: 'ASP_NOT_CONFIGURED',
        responseMessage: 'ASP integration not configured. Configure in Phase 7.',
      };
    }

    const aspRequest: AspSubmissionRequest = {
      einvoiceId: archive.id,
      einvoiceNumber: archive.einvoiceNumber,
      companyId: archive.companyId,
      xml: archive.xmlContent,
      xmlHash: archive.xmlHash,
      format: archive.format as 'PINT_AE' | 'UBL_21',
      invoiceType: 'INVOICE', // TODO: Detect from XML
      submitterTrn: '', // TODO: Extract from XML
    };

    return this.aspClient.submitEInvoice(aspRequest);
  }

  /**
   * Check ASP submission status
   */
  async checkAspStatus(submissionId: string): Promise<any> {
    return this.aspClient.checkStatus(submissionId);
  }

  /**
   * Check if ASP is configured
   */
  isAspConfigured(): boolean {
    return this.aspClient.isConfigured();
  }

  /**
   * Retrieves an e-invoice by ID
   */
  async getEInvoice(archiveId: string): Promise<EInvoiceArchiveRecord | null> {
    return this.archiveService.getArchive(archiveId);
  }

  /**
   * Retrieves an e-invoice by e-invoice number
   */
  async getEInvoiceByNumber(einvoiceNumber: string): Promise<EInvoiceArchiveRecord | null> {
    return this.archiveService.getArchiveByEInvoiceNumber(einvoiceNumber);
  }

  /**
   * Lists e-invoices for a company
   */
  async listEInvoices(
    companyId: string,
    options?: {
      status?: string;
      page?: number;
      limit?: number;
      startDate?: Date;
      endDate?: Date;
    }
  ): Promise<{ einvoices: EInvoiceArchiveRecord[]; total: number }> {
    const result = await this.archiveService.listArchives(companyId, options as any);
    return {
      einvoices: result.archives,
      total: result.total,
    };
  }

  /**
   * Verifies integrity of e-invoice archives
   */
  async verifyIntegrity(
    companyId: string,
    startDate?: Date,
    endDate?: Date
  ) {
    return this.archiveService.verifyIntegrity(companyId, startDate, endDate);
  }

  /**
   * Gets e-invoice statistics for a company
   */
  async getStatistics(companyId: string) {
    return this.archiveService.getStatistics(companyId);
  }

  /**
   * Validates a tax invoice before e-invoice generation
   * Use for preview/pre-flight checks
   */
  async validateForEInvoice(invoice: TaxInvoiceData): Promise<{
    valid: boolean;
    errors: string[];
    warnings: string[];
  }> {
    const errors: string[] = [];
    const warnings: string[] = [];

    // Check mandatory fields
    if (!invoice.supplierTrn || !/^100\d{12}$/.test(invoice.supplierTrn)) {
      errors.push('Supplier TRN must be 15 digits starting with 100');
    }

    if (!invoice.supplierName) {
      errors.push('Supplier name is required');
    }

    if (!invoice.invoiceNumber) {
      errors.push('Invoice number is required');
    }

    if (!invoice.invoiceDate) {
      errors.push('Invoice date is required');
    }

    if (!invoice.lineItems || invoice.lineItems.length === 0) {
      errors.push('At least one line item is required');
    }

    if (invoice.currency && invoice.currency !== 'AED') {
      warnings.push('Currency will be converted to AED for e-invoice');
    }

    // Build XML and validate
    if (errors.length === 0) {
      try {
        const xml = this.pintAeBuilder.buildInvoiceXml(invoice);
        const validationResult = await this.validator.validateInvoice(xml);

        if (!validationResult.valid) {
          errors.push(...validationResult.errors.map(e => `${e.code}: ${e.message}`));
        }
        warnings.push(...validationResult.warnings.map(w => `${w.code}: ${w.message}`));
      } catch (error) {
        errors.push(`XML generation failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
      }
    }

    return {
      valid: errors.length === 0,
      errors,
      warnings,
    };
  }

  /**
   * Calculates SHA-256 hash
   */
  private calculateHash(data: string): string {
    return createHash('sha256').update(data).digest('hex');
  }
}

export default EInvoiceService;
```

Update the index file:

```typescript
// backend/src/services/einvoice/index.ts
export * from './qr-code.service';
export * from './pint-ae-builder.service';
export * from './ubl-validator.service';
export * from './einvoice-archive.service';
export * from './einvoice.service';
export * from './asp-client.interface';
```
  </action>
  <verify>Run `npx tsc --noEmit` to verify TypeScript compilation.</verify>
  <done>EInvoiceService created with generateEInvoice(), generateCreditNote(), submitToAsp(), validateForEInvoice() methods. Orchestrates all sub-services including ASP client stub. QR code embedded in XML.</done>
</task>

<task type="auto">
  <name>Task 3: Update DI Configuration</name>
  <files>backend/src/config/types.ts, backend/src/config/container.ts</files>
  <action>
Update the DI types file to include e-invoice service symbols:

```typescript
// backend/src/config/types.ts
// Add to existing TYPES object:

const TYPES = {
  // ... existing types ...

  // E-Invoice Services (Phase 06 - E-Invoicing Engine Core)
  PintAeBuilderService: Symbol.for('PintAeBuilderService'),
  UblValidatorService: Symbol.for('UblValidatorService'),
  QrCodeService: Symbol.for('QrCodeService'),
  EInvoiceArchiveService: Symbol.for('EInvoiceArchiveService'),
  EInvoiceService: Symbol.for('EInvoiceService'),
  AspClient: Symbol.for('AspClient'),  // Interface - stub until Phase 7
};

export { TYPES };
```

Update the container to bind e-invoice services:

```typescript
// backend/src/config/container.ts
// Add imports and bindings:

import { PintAeBuilderService } from '../services/einvoice/pint-ae-builder.service';
import { UblValidatorService } from '../services/einvoice/ubl-validator.service';
import { QrCodeService } from '../services/einvoice/qr-code.service';
import { EInvoiceArchiveService } from '../services/einvoice/einvoice-archive.service';
import { EInvoiceService } from '../services/einvoice/einvoice.service';
import { IAspClient, AspClientStub } from '../services/einvoice/asp-client.interface';

// In container configuration, add:
container.bind<PintAeBuilderService>(TYPES.PintAeBuilderService).to(PintAeBuilderService).inSingletonScope();
container.bind<UblValidatorService>(TYPES.UblValidatorService).to(UblValidatorService).inSingletonScope();
container.bind<QrCodeService>(TYPES.QrCodeService).to(QrCodeService).inSingletonScope();
container.bind<EInvoiceArchiveService>(TYPES.EInvoiceArchiveService).to(EInvoiceArchiveService).inSingletonScope();
container.bind<EInvoiceService>(TYPES.EInvoiceService).to(EInvoiceService).inSingletonScope();

// ASP Client - Stub until Phase 7
// Phase 7 will rebind this to actual ASP implementation
container.bind<IAspClient>(TYPES.AspClient).to(AspClientStub).inSingletonScope();
```
  </action>
  <verify>Run `npx tsc --noEmit` to verify all DI bindings compile correctly.</verify>
  <done>DI types and container updated with all e-invoice service symbols and bindings, including AspClient bound to AspClientStub.</done>
</task>

</tasks>

<verification>
1. Orchestration: Services called in correct order (QR -> build XML with QR -> validate -> archive)
2. Validation: Invalid invoices blocked before archiving
3. Transaction: All operations run within single Prisma transaction
4. Audit: Audit log created with EINVOICE_GENERATE action
5. QR Embedding: QR code embedded in XML via PintAeBuilderService
6. ASP Interface: IAspClient defined, AspClientStub bound in DI
7. Tests: All unit tests pass
</verification>

<success_criteria>
1. generateEInvoice() orchestrates all services correctly with QR embedding
2. Validation failures block archiving with clear errors
3. QR code embedded in XML via cac:AdditionalDocumentReference
4. Audit log created with EINVOICE_GENERATE action
5. DI container properly configured for all services
6. IAspClient interface defined for EINV-06 (Phase 7 implementation)
7. AspClientStub allows Phase 6 to compile without ASP connectivity
</success_criteria>

<output>
After completion, create `.planning/phases/06-e-invoicing-engine-core/06-06-SUMMARY.md`
</output>
