---
phase: 06-e-invoicing-engine-core
plan: 06
type: execute
wave: 4
depends_on: [06-03, 06-04, 06-05]
files_modified:
  - backend/src/services/einvoice/einvoice.service.ts
  - backend/src/config/types.ts
  - backend/src/config/container.ts
  - backend/src/services/einvoice/__tests__/einvoice.service.test.ts
autonomous: true

must_haves:
  truths:
    - "E-invoice generation orchestrates all sub-services in correct order"
    - "Validation failures block archiving with clear error messages"
    - "QR code is embedded in generated e-invoice"
    - "All operations run within single database transaction"
    - "Audit log created for every e-invoice generation"
  artifacts:
    - path: "backend/src/services/einvoice/einvoice.service.ts"
      provides: "E-invoice orchestration service"
      exports: ["EInvoiceService"]
    - path: "backend/src/config/types.ts"
      provides: "DI type symbols for e-invoice services"
      contains: "EInvoiceService"
  key_links:
    - from: "einvoice.service.ts"
      to: "pint-ae-builder.service.ts"
      via: "DI injection"
      pattern: "PintAeBuilderService"
    - from: "einvoice.service.ts"
      to: "ubl-validator.service.ts"
      via: "DI injection"
      pattern: "UblValidatorService"
    - from: "einvoice.service.ts"
      to: "qr-code.service.ts"
      via: "DI injection"
      pattern: "QrCodeService"
    - from: "einvoice.service.ts"
      to: "einvoice-archive.service.ts"
      via: "DI injection"
      pattern: "EInvoiceArchiveService"
---

<objective>
Create the main e-invoice orchestration service that coordinates XML generation, validation, QR code creation, and archival.

Purpose: EINV-01 through EINV-05 require an integrated workflow for e-invoice generation. This service orchestrates all components in the correct order, ensuring validation before archival and proper audit logging.

Output:
- EInvoiceService with generateEInvoice() method
- DI container registration for all e-invoice services
- Audit logging integration
- Unit tests for orchestration flow
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-e-invoicing-engine-core/06-RESEARCH.md

# Services from prior plans
# 06-02: QrCodeService
# 06-03: PintAeBuilderService
# 06-04: UblValidatorService
# 06-05: EInvoiceArchiveService

# DI configuration
@backend/src/config/types.ts
@backend/src/config/container.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create E-Invoice Orchestration Service</name>
  <files>backend/src/services/einvoice/einvoice.service.ts</files>
  <action>
Create the main e-invoice service that orchestrates all components:

```typescript
/**
 * E-Invoice Service
 * Phase: 06-e-invoicing-engine-core
 * Requirements: EINV-01 through EINV-05
 *
 * Main orchestration service for e-invoice generation.
 * Coordinates:
 * 1. PINT AE XML generation
 * 2. UBL 2.1 schema validation
 * 3. QR code generation with TLV encoding
 * 4. Tamper-proof archival
 * 5. Audit logging
 */

import { PrismaClient, AuditAction } from '@prisma/client';
import { injectable, inject } from 'inversify';
import { createHash, randomUUID } from 'crypto';
import { TYPES } from '../../config/types';
import { PintAeBuilderService } from './pint-ae-builder.service';
import { UblValidatorService } from './ubl-validator.service';
import { QrCodeService, QrCodeInput } from './qr-code.service';
import { EInvoiceArchiveService, ArchiveInput } from './einvoice-archive.service';
import {
  TaxInvoiceData,
  EInvoiceResult,
  EInvoiceArchiveRecord,
  EInvoiceValidationResult,
} from '../../types/einvoice.types';
import logger from '../logger.service';

/**
 * E-invoice generation options
 */
export interface GenerateOptions {
  /** Skip validation (use for regeneration of known-valid invoices) */
  skipValidation?: boolean;
  /** Include QR code in output */
  includeQrCode?: boolean;
  /** User ID for audit logging */
  userId: string;
}

/**
 * Credit note generation options
 */
export interface CreditNoteOptions extends GenerateOptions {
  /** Original invoice number (mandatory for credit notes) */
  originalInvoiceNumber: string;
}

/**
 * Generation result with full details
 */
export interface GenerationResult {
  success: boolean;
  einvoice: {
    id: string;
    einvoiceNumber: string;
    xml: string;
    qrCode?: string;
    xmlHash: string;
    status: string;
  } | null;
  validation: EInvoiceValidationResult | null;
  errors: string[];
}

@injectable()
export class EInvoiceService {
  constructor(
    @inject(TYPES.PrismaClient) private readonly prisma: PrismaClient,
    @inject(TYPES.PintAeBuilderService) private readonly pintAeBuilder: PintAeBuilderService,
    @inject(TYPES.UblValidatorService) private readonly validator: UblValidatorService,
    @inject(TYPES.QrCodeService) private readonly qrCodeService: QrCodeService,
    @inject(TYPES.EInvoiceArchiveService) private readonly archiveService: EInvoiceArchiveService
  ) {}

  /**
   * Generates a complete PINT AE e-invoice from tax invoice data
   *
   * Flow:
   * 1. Build PINT AE XML from TaxInvoiceData
   * 2. Validate XML against UBL 2.1 and PINT AE rules
   * 3. Generate QR code with TLV-encoded data
   * 4. Archive with tamper-proof storage
   * 5. Create audit log entry
   *
   * @param invoice - Source tax invoice data (from Phase 3)
   * @param options - Generation options
   * @returns Generation result with e-invoice or errors
   *
   * @example
   * const result = await einvoiceService.generateEInvoice(taxInvoice, {
   *   userId: 'user-123',
   *   includeQrCode: true,
   * });
   *
   * if (result.success) {
   *   console.log('E-invoice:', result.einvoice.einvoiceNumber);
   * } else {
   *   console.log('Errors:', result.errors);
   * }
   */
  async generateEInvoice(
    invoice: TaxInvoiceData,
    options: GenerateOptions
  ): Promise<GenerationResult> {
    const { userId, skipValidation = false, includeQrCode = true } = options;

    logger.info('[EInvoiceService] Starting e-invoice generation', {
      invoiceNumber: invoice.invoiceNumber,
      companyId: invoice.companyId,
      userId,
    });

    const errors: string[] = [];
    let validationResult: EInvoiceValidationResult | null = null;

    try {
      // Step 1: Build PINT AE XML
      logger.info('[EInvoiceService] Building PINT AE XML');
      const xml = this.pintAeBuilder.buildInvoiceXml(invoice);
      const xmlHash = this.calculateHash(xml);

      // Step 2: Validate XML (unless skipped)
      if (!skipValidation) {
        logger.info('[EInvoiceService] Validating XML');
        validationResult = await this.validator.validateInvoice(xml);

        if (!validationResult.valid) {
          logger.warn('[EInvoiceService] Validation failed', {
            errorCount: validationResult.errors.length,
            invoiceNumber: invoice.invoiceNumber,
          });

          // Return validation errors without archiving
          return {
            success: false,
            einvoice: null,
            validation: validationResult,
            errors: validationResult.errors.map(e => `${e.code}: ${e.message}`),
          };
        }
      }

      // Step 3: Generate QR code
      let qrCodeData: string | undefined;
      if (includeQrCode) {
        logger.info('[EInvoiceService] Generating QR code');
        const qrInput: QrCodeInput = {
          sellerName: invoice.supplierName,
          sellerTrn: invoice.supplierTrn,
          timestamp: invoice.invoiceDate,
          invoiceTotal: invoice.totalAmount.toFixed(2),
          vatTotal: invoice.vatAmount.toFixed(2),
          invoiceHash: xmlHash,
        };

        const qrResult = await this.qrCodeService.generateQrCode(qrInput, {
          format: 'base64',
        });
        qrCodeData = qrResult.tlvBase64;
      }

      // Step 4: Archive in transaction
      logger.info('[EInvoiceService] Archiving e-invoice');
      const archive = await this.prisma.$transaction(async (tx) => {
        // Create archive
        const archiveInput: ArchiveInput = {
          invoice,
          xml,
          qrCodeData: qrCodeData || '',
          validationResult: validationResult || undefined,
        };

        const archived = await this.archiveService.archiveEInvoice(tx, archiveInput);

        // Create audit log
        await tx.auditLogs.create({
          data: {
            id: randomUUID(),
            userId,
            action: 'EINVOICE_GENERATE' as AuditAction,
            entity: 'EInvoice',
            entityId: archived.id,
            newValue: {
              invoiceId: invoice.invoiceId,
              einvoiceNumber: archived.einvoiceNumber,
              xmlHash: archived.xmlHash,
              status: archived.status,
            },
            companyId: invoice.companyId,
            createdAt: new Date(),
          },
        });

        return archived;
      });

      logger.info('[EInvoiceService] E-invoice generated successfully', {
        einvoiceNumber: archive.einvoiceNumber,
        archiveId: archive.id,
        status: archive.status,
      });

      return {
        success: true,
        einvoice: {
          id: archive.id,
          einvoiceNumber: archive.einvoiceNumber,
          xml,
          qrCode: qrCodeData,
          xmlHash,
          status: archive.status,
        },
        validation: validationResult,
        errors: [],
      };
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      logger.error('[EInvoiceService] E-invoice generation failed', {
        invoiceNumber: invoice.invoiceNumber,
        error: errorMessage,
      });

      errors.push(`Generation failed: ${errorMessage}`);

      return {
        success: false,
        einvoice: null,
        validation: validationResult,
        errors,
      };
    }
  }

  /**
   * Generates a credit note e-invoice
   *
   * @param creditNote - Credit note data
   * @param options - Credit note options (must include originalInvoiceNumber)
   */
  async generateCreditNote(
    creditNote: TaxInvoiceData,
    options: CreditNoteOptions
  ): Promise<GenerationResult> {
    const { originalInvoiceNumber, userId, skipValidation = false, includeQrCode = true } = options;

    logger.info('[EInvoiceService] Starting credit note generation', {
      creditNoteNumber: creditNote.invoiceNumber,
      originalInvoice: originalInvoiceNumber,
      userId,
    });

    const errors: string[] = [];
    let validationResult: EInvoiceValidationResult | null = null;

    try {
      // Step 1: Build credit note XML
      const xml = this.pintAeBuilder.buildCreditNoteXml(creditNote, originalInvoiceNumber);
      const xmlHash = this.calculateHash(xml);

      // Step 2: Validate
      if (!skipValidation) {
        validationResult = await this.validator.validateInvoice(xml);

        if (!validationResult.valid) {
          return {
            success: false,
            einvoice: null,
            validation: validationResult,
            errors: validationResult.errors.map(e => `${e.code}: ${e.message}`),
          };
        }
      }

      // Step 3: Generate QR code
      let qrCodeData: string | undefined;
      if (includeQrCode) {
        const qrInput: QrCodeInput = {
          sellerName: creditNote.supplierName,
          sellerTrn: creditNote.supplierTrn,
          timestamp: creditNote.invoiceDate,
          invoiceTotal: creditNote.totalAmount.toFixed(2),
          vatTotal: creditNote.vatAmount.toFixed(2),
          invoiceHash: xmlHash,
        };

        const qrResult = await this.qrCodeService.generateQrCode(qrInput);
        qrCodeData = qrResult.tlvBase64;
      }

      // Step 4: Archive
      const archive = await this.prisma.$transaction(async (tx) => {
        const archiveInput: ArchiveInput = {
          invoice: creditNote,
          xml,
          qrCodeData: qrCodeData || '',
          validationResult: validationResult || undefined,
        };

        const archived = await this.archiveService.archiveEInvoice(tx, archiveInput);

        await tx.auditLogs.create({
          data: {
            id: randomUUID(),
            userId,
            action: 'EINVOICE_GENERATE' as AuditAction,
            entity: 'EInvoice',
            entityId: archived.id,
            newValue: {
              type: 'CreditNote',
              creditNoteNumber: creditNote.invoiceNumber,
              originalInvoice: originalInvoiceNumber,
              xmlHash: archived.xmlHash,
            },
            companyId: creditNote.companyId,
            createdAt: new Date(),
          },
        });

        return archived;
      });

      return {
        success: true,
        einvoice: {
          id: archive.id,
          einvoiceNumber: archive.einvoiceNumber,
          xml,
          qrCode: qrCodeData,
          xmlHash,
          status: archive.status,
        },
        validation: validationResult,
        errors: [],
      };
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      errors.push(`Credit note generation failed: ${errorMessage}`);

      return {
        success: false,
        einvoice: null,
        validation: validationResult,
        errors,
      };
    }
  }

  /**
   * Retrieves an e-invoice by ID
   */
  async getEInvoice(archiveId: string): Promise<EInvoiceArchiveRecord | null> {
    return this.archiveService.getArchive(archiveId);
  }

  /**
   * Retrieves an e-invoice by e-invoice number
   */
  async getEInvoiceByNumber(einvoiceNumber: string): Promise<EInvoiceArchiveRecord | null> {
    return this.archiveService.getArchiveByEInvoiceNumber(einvoiceNumber);
  }

  /**
   * Lists e-invoices for a company
   */
  async listEInvoices(
    companyId: string,
    options?: {
      status?: string;
      page?: number;
      limit?: number;
      startDate?: Date;
      endDate?: Date;
    }
  ): Promise<{ einvoices: EInvoiceArchiveRecord[]; total: number }> {
    const result = await this.archiveService.listArchives(companyId, options as any);
    return {
      einvoices: result.archives,
      total: result.total,
    };
  }

  /**
   * Verifies integrity of e-invoice archives
   */
  async verifyIntegrity(
    companyId: string,
    startDate?: Date,
    endDate?: Date
  ) {
    return this.archiveService.verifyIntegrity(companyId, startDate, endDate);
  }

  /**
   * Gets e-invoice statistics for a company
   */
  async getStatistics(companyId: string) {
    return this.archiveService.getStatistics(companyId);
  }

  /**
   * Validates a tax invoice before e-invoice generation
   * Use for preview/pre-flight checks
   */
  async validateForEInvoice(invoice: TaxInvoiceData): Promise<{
    valid: boolean;
    errors: string[];
    warnings: string[];
  }> {
    const errors: string[] = [];
    const warnings: string[] = [];

    // Check mandatory fields
    if (!invoice.supplierTrn || !/^100\d{12}$/.test(invoice.supplierTrn)) {
      errors.push('Supplier TRN must be 15 digits starting with 100');
    }

    if (!invoice.supplierName) {
      errors.push('Supplier name is required');
    }

    if (!invoice.invoiceNumber) {
      errors.push('Invoice number is required');
    }

    if (!invoice.invoiceDate) {
      errors.push('Invoice date is required');
    }

    if (!invoice.lineItems || invoice.lineItems.length === 0) {
      errors.push('At least one line item is required');
    }

    if (invoice.currency && invoice.currency !== 'AED') {
      warnings.push('Currency will be converted to AED for e-invoice');
    }

    // Build XML and validate
    if (errors.length === 0) {
      try {
        const xml = this.pintAeBuilder.buildInvoiceXml(invoice);
        const validationResult = await this.validator.validateInvoice(xml);

        if (!validationResult.valid) {
          errors.push(...validationResult.errors.map(e => `${e.code}: ${e.message}`));
        }
        warnings.push(...validationResult.warnings.map(w => `${w.code}: ${w.message}`));
      } catch (error) {
        errors.push(`XML generation failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
      }
    }

    return {
      valid: errors.length === 0,
      errors,
      warnings,
    };
  }

  /**
   * Calculates SHA-256 hash
   */
  private calculateHash(data: string): string {
    return createHash('sha256').update(data).digest('hex');
  }
}

export default EInvoiceService;
```

Update the index file:

```typescript
// backend/src/services/einvoice/index.ts
export * from './qr-code.service';
export * from './pint-ae-builder.service';
export * from './ubl-validator.service';
export * from './einvoice-archive.service';
export * from './einvoice.service';
```
  </action>
  <verify>Run `npx tsc --noEmit` to verify TypeScript compilation.</verify>
  <done>EInvoiceService created with generateEInvoice(), generateCreditNote(), validateForEInvoice() methods. Orchestrates all sub-services.</done>
</task>

<task type="auto">
  <name>Task 2: Update DI Configuration</name>
  <files>backend/src/config/types.ts, backend/src/config/container.ts</files>
  <action>
Update the DI types file to include e-invoice service symbols:

```typescript
// backend/src/config/types.ts
// Add to existing TYPES object:

const TYPES = {
  // ... existing types ...

  // E-Invoice Services (Phase 06 - E-Invoicing Engine Core)
  PintAeBuilderService: Symbol.for('PintAeBuilderService'),
  UblValidatorService: Symbol.for('UblValidatorService'),
  QrCodeService: Symbol.for('QrCodeService'),
  EInvoiceArchiveService: Symbol.for('EInvoiceArchiveService'),
  EInvoiceService: Symbol.for('EInvoiceService'),
};

export { TYPES };
```

Update the container to bind e-invoice services:

```typescript
// backend/src/config/container.ts
// Add imports and bindings:

import { PintAeBuilderService } from '../services/einvoice/pint-ae-builder.service';
import { UblValidatorService } from '../services/einvoice/ubl-validator.service';
import { QrCodeService } from '../services/einvoice/qr-code.service';
import { EInvoiceArchiveService } from '../services/einvoice/einvoice-archive.service';
import { EInvoiceService } from '../services/einvoice/einvoice.service';

// In container configuration, add:
container.bind<PintAeBuilderService>(TYPES.PintAeBuilderService).to(PintAeBuilderService).inSingletonScope();
container.bind<UblValidatorService>(TYPES.UblValidatorService).to(UblValidatorService).inSingletonScope();
container.bind<QrCodeService>(TYPES.QrCodeService).to(QrCodeService).inSingletonScope();
container.bind<EInvoiceArchiveService>(TYPES.EInvoiceArchiveService).to(EInvoiceArchiveService).inSingletonScope();
container.bind<EInvoiceService>(TYPES.EInvoiceService).to(EInvoiceService).inSingletonScope();
```
  </action>
  <verify>Run `npx tsc --noEmit` to verify all DI bindings compile correctly.</verify>
  <done>DI types and container updated with all e-invoice service symbols and bindings.</done>
</task>

<task type="auto">
  <name>Task 3: Create E-Invoice Service Unit Tests</name>
  <files>backend/src/services/einvoice/__tests__/einvoice.service.test.ts</files>
  <action>
Create unit tests for the orchestration service:

```typescript
/**
 * E-Invoice Service Tests
 * Phase: 06-e-invoicing-engine-core
 * Requirements: EINV-01 through EINV-05
 */

import { EInvoiceService, GenerateOptions } from '../einvoice.service';
import { TaxInvoiceData } from '../../../types/einvoice.types';

// Mock services
const mockPintAeBuilder = {
  buildInvoiceXml: jest.fn(),
  buildCreditNoteXml: jest.fn(),
};

const mockValidator = {
  validateInvoice: jest.fn(),
};

const mockQrCodeService = {
  generateQrCode: jest.fn(),
};

const mockArchiveService = {
  archiveEInvoice: jest.fn(),
  getArchive: jest.fn(),
  getArchiveByEInvoiceNumber: jest.fn(),
  listArchives: jest.fn(),
  verifyIntegrity: jest.fn(),
  getStatistics: jest.fn(),
};

const mockPrisma = {
  $transaction: jest.fn((callback: (tx: any) => Promise<any>) => callback(mockPrisma)),
  auditLogs: {
    create: jest.fn(),
  },
};

describe('EInvoiceService', () => {
  let service: EInvoiceService;

  const createValidInvoice = (): TaxInvoiceData => ({
    invoiceId: 'inv-001',
    invoiceNumber: 'INV-2026-0001',
    companyId: 'company-001',
    invoiceDate: new Date('2026-01-24'),
    supplierName: 'Vesla Motors LLC',
    supplierTrn: '100123456789012',
    supplierAddress: 'Dubai',
    supplierCountry: 'AE',
    recipientName: 'ABC Trading',
    recipientAddress: 'Dubai',
    subtotal: 1000,
    vatAmount: 50,
    totalAmount: 1050,
    currency: 'AED',
    vatRate: 5,
    isReverseCharge: false,
    lineItems: [{
      lineNumber: 1,
      description: 'Test item',
      quantity: 1,
      unitCode: 'EA',
      unitPrice: 1000,
      lineTotal: 1000,
      vatRate: 5,
      vatAmount: 50,
    }],
    createdById: 'user-001',
  });

  const defaultOptions: GenerateOptions = {
    userId: 'user-001',
    includeQrCode: true,
  };

  beforeEach(() => {
    jest.clearAllMocks();

    service = new EInvoiceService(
      mockPrisma as any,
      mockPintAeBuilder as any,
      mockValidator as any,
      mockQrCodeService as any,
      mockArchiveService as any
    );

    // Default mock implementations
    mockPintAeBuilder.buildInvoiceXml.mockReturnValue('<?xml version="1.0"?><Invoice>...</Invoice>');
    mockValidator.validateInvoice.mockResolvedValue({
      valid: true,
      errors: [],
      warnings: [],
      validatedAt: new Date(),
    });
    mockQrCodeService.generateQrCode.mockResolvedValue({
      data: 'base64qrcode',
      tlvBase64: 'tlvbase64data',
      format: 'base64',
      contentSize: 100,
    });
    mockArchiveService.archiveEInvoice.mockResolvedValue({
      id: 'archive-001',
      einvoiceNumber: 'EI-INV-2026-0001-ABC',
      xmlHash: 'somehash',
      status: 'VALIDATED',
    });
    mockPrisma.auditLogs.create.mockResolvedValue({ id: 'audit-001' });
  });

  describe('generateEInvoice', () => {
    it('should generate e-invoice successfully', async () => {
      const invoice = createValidInvoice();
      const result = await service.generateEInvoice(invoice, defaultOptions);

      expect(result.success).toBe(true);
      expect(result.einvoice).not.toBeNull();
      expect(result.einvoice?.einvoiceNumber).toBe('EI-INV-2026-0001-ABC');
      expect(result.errors).toHaveLength(0);
    });

    it('should call services in correct order', async () => {
      const invoice = createValidInvoice();
      await service.generateEInvoice(invoice, defaultOptions);

      // Verify order of operations
      expect(mockPintAeBuilder.buildInvoiceXml).toHaveBeenCalledBefore(
        mockValidator.validateInvoice
      );
      expect(mockValidator.validateInvoice).toHaveBeenCalledBefore(
        mockQrCodeService.generateQrCode
      );
      expect(mockQrCodeService.generateQrCode).toHaveBeenCalledBefore(
        mockArchiveService.archiveEInvoice
      );
    });

    it('should block archiving when validation fails', async () => {
      mockValidator.validateInvoice.mockResolvedValue({
        valid: false,
        errors: [{ code: 'ERR-001', message: 'Invalid', severity: 'error' }],
        warnings: [],
        validatedAt: new Date(),
      });

      const invoice = createValidInvoice();
      const result = await service.generateEInvoice(invoice, defaultOptions);

      expect(result.success).toBe(false);
      expect(result.einvoice).toBeNull();
      expect(mockArchiveService.archiveEInvoice).not.toHaveBeenCalled();
      expect(result.errors).toContain('ERR-001: Invalid');
    });

    it('should skip validation when option set', async () => {
      const invoice = createValidInvoice();
      await service.generateEInvoice(invoice, {
        ...defaultOptions,
        skipValidation: true,
      });

      expect(mockValidator.validateInvoice).not.toHaveBeenCalled();
      expect(mockArchiveService.archiveEInvoice).toHaveBeenCalled();
    });

    it('should skip QR code when option set', async () => {
      const invoice = createValidInvoice();
      const result = await service.generateEInvoice(invoice, {
        ...defaultOptions,
        includeQrCode: false,
      });

      expect(mockQrCodeService.generateQrCode).not.toHaveBeenCalled();
      expect(result.einvoice?.qrCode).toBeUndefined();
    });

    it('should create audit log on successful generation', async () => {
      const invoice = createValidInvoice();
      await service.generateEInvoice(invoice, defaultOptions);

      expect(mockPrisma.auditLogs.create).toHaveBeenCalledWith(
        expect.objectContaining({
          data: expect.objectContaining({
            action: 'EINVOICE_GENERATE',
            entity: 'EInvoice',
            userId: 'user-001',
          }),
        })
      );
    });

    it('should include QR code with invoice hash', async () => {
      const invoice = createValidInvoice();
      await service.generateEInvoice(invoice, defaultOptions);

      expect(mockQrCodeService.generateQrCode).toHaveBeenCalledWith(
        expect.objectContaining({
          sellerTrn: '100123456789012',
          invoiceTotal: '1050.00',
          vatTotal: '50.00',
          invoiceHash: expect.any(String),
        }),
        expect.any(Object)
      );
    });

    it('should handle generation errors gracefully', async () => {
      mockPintAeBuilder.buildInvoiceXml.mockImplementation(() => {
        throw new Error('XML build failed');
      });

      const invoice = createValidInvoice();
      const result = await service.generateEInvoice(invoice, defaultOptions);

      expect(result.success).toBe(false);
      expect(result.errors).toContain('Generation failed: XML build failed');
    });
  });

  describe('generateCreditNote', () => {
    it('should generate credit note with original reference', async () => {
      mockPintAeBuilder.buildCreditNoteXml.mockReturnValue(
        '<?xml version="1.0"?><CreditNote>...</CreditNote>'
      );

      const creditNote = createValidInvoice();
      creditNote.invoiceNumber = 'CN-2026-0001';

      const result = await service.generateCreditNote(creditNote, {
        ...defaultOptions,
        originalInvoiceNumber: 'INV-2026-0001',
      });

      expect(result.success).toBe(true);
      expect(mockPintAeBuilder.buildCreditNoteXml).toHaveBeenCalledWith(
        creditNote,
        'INV-2026-0001'
      );
    });
  });

  describe('validateForEInvoice', () => {
    it('should validate invoice before generation', async () => {
      const invoice = createValidInvoice();
      const result = await service.validateForEInvoice(invoice);

      expect(result.valid).toBe(true);
      expect(result.errors).toHaveLength(0);
    });

    it('should reject invalid TRN', async () => {
      const invoice = createValidInvoice();
      invoice.supplierTrn = '123456';

      const result = await service.validateForEInvoice(invoice);

      expect(result.valid).toBe(false);
      expect(result.errors.some(e => e.includes('TRN'))).toBe(true);
    });

    it('should reject missing supplier name', async () => {
      const invoice = createValidInvoice();
      invoice.supplierName = '';

      const result = await service.validateForEInvoice(invoice);

      expect(result.valid).toBe(false);
      expect(result.errors.some(e => e.includes('Supplier name'))).toBe(true);
    });

    it('should reject missing line items', async () => {
      const invoice = createValidInvoice();
      invoice.lineItems = [];

      const result = await service.validateForEInvoice(invoice);

      expect(result.valid).toBe(false);
      expect(result.errors.some(e => e.includes('line item'))).toBe(true);
    });

    it('should warn on non-AED currency', async () => {
      const invoice = createValidInvoice();
      invoice.currency = 'USD';

      const result = await service.validateForEInvoice(invoice);

      expect(result.warnings.some(w => w.includes('AED'))).toBe(true);
    });
  });

  describe('getEInvoice', () => {
    it('should retrieve e-invoice by ID', async () => {
      mockArchiveService.getArchive.mockResolvedValue({
        id: 'archive-001',
        einvoiceNumber: 'EI-001',
      });

      const result = await service.getEInvoice('archive-001');

      expect(result).not.toBeNull();
      expect(mockArchiveService.getArchive).toHaveBeenCalledWith('archive-001');
    });
  });

  describe('listEInvoices', () => {
    it('should list e-invoices with pagination', async () => {
      mockArchiveService.listArchives.mockResolvedValue({
        archives: [{ id: 'archive-001' }],
        total: 10,
      });

      const result = await service.listEInvoices('company-001', {
        page: 1,
        limit: 10,
      });

      expect(result.einvoices).toHaveLength(1);
      expect(result.total).toBe(10);
    });
  });

  describe('verifyIntegrity', () => {
    it('should verify archive integrity', async () => {
      mockArchiveService.verifyIntegrity.mockResolvedValue({
        valid: true,
        totalRecords: 100,
        verifiedRecords: 100,
        invalidRecords: [],
      });

      const result = await service.verifyIntegrity('company-001');

      expect(result.valid).toBe(true);
      expect(mockArchiveService.verifyIntegrity).toHaveBeenCalledWith(
        'company-001',
        undefined,
        undefined
      );
    });
  });
});

// Helper for testing call order
expect.extend({
  toHaveBeenCalledBefore(received: jest.Mock, expected: jest.Mock) {
    const receivedOrder = received.mock.invocationCallOrder[0] || Infinity;
    const expectedOrder = expected.mock.invocationCallOrder[0] || Infinity;

    const pass = receivedOrder < expectedOrder;

    return {
      pass,
      message: () =>
        pass
          ? `Expected ${received.getMockName()} not to have been called before ${expected.getMockName()}`
          : `Expected ${received.getMockName()} to have been called before ${expected.getMockName()}`,
    };
  },
});

declare global {
  namespace jest {
    interface Matchers<R> {
      toHaveBeenCalledBefore(expected: jest.Mock): R;
    }
  }
}
```
  </action>
  <verify>Run `npm test -- --testPathPattern=einvoice.service.test.ts` - all tests should pass.</verify>
  <done>Unit tests created covering orchestration flow, validation blocking, audit logging, and error handling.</done>
</task>

</tasks>

<verification>
1. Orchestration: Services called in correct order (build -> validate -> QR -> archive)
2. Validation: Invalid invoices blocked before archiving
3. Transaction: All operations run within single Prisma transaction
4. Audit: Audit log created for every generation
5. Tests: All unit tests pass
</verification>

<success_criteria>
1. generateEInvoice() orchestrates all services correctly
2. Validation failures block archiving with clear errors
3. QR code includes invoice hash for integrity
4. Audit log created for every generation
5. DI container properly configured for all services
</success_criteria>

<output>
After completion, create `.planning/phases/06-e-invoicing-engine-core/06-06-SUMMARY.md`
</output>
