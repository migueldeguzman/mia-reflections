---
phase: 04-corporate-tax-compliance
plan: 09
type: execute
wave: 5
depends_on: ["04-03", "04-04", "04-05", "04-06", "04-07", "04-08"]
files_modified:
  - backend/src/services/corporate-tax/__tests__/ct-calculation.test.ts
  - backend/src/services/corporate-tax/__tests__/ct-integration.test.ts
  - backend/src/middleware/ct-permissions.middleware.ts
  - backend/src/types/ct-permissions.ts
autonomous: true

must_haves:
  truths:
    - "CT calculation tests verify 9% rate on income exceeding AED 375,000"
    - "Loss offset tests verify 75% maximum utilization"
    - "Integration tests cover full CT lifecycle (income -> adjustments -> CT)"
    - "CT permissions restrict access by role (Accountant, Tax Manager, CFO)"
    - "Non-deductible expense tests cover entertainment 50% and fines 100%"
  artifacts:
    - path: "backend/src/services/corporate-tax/__tests__/ct-calculation.test.ts"
      provides: "Unit tests for CT calculation service"
      contains: "describe.*CtCalculationService"
      min_lines: 250
    - path: "backend/src/services/corporate-tax/__tests__/ct-integration.test.ts"
      provides: "Integration tests for CT lifecycle"
      contains: "describe.*Corporate Tax Integration"
      min_lines: 200
    - path: "backend/src/middleware/ct-permissions.middleware.ts"
      provides: "Permission middleware for CT operations"
      exports: ["requireCtPermission"]
      min_lines: 100
  key_links:
    - from: "ct-calculation.test.ts"
      to: "ct-calculation.service.ts"
      via: "Test CT rate and threshold"
      pattern: "calculateCorporateTax"
    - from: "ct-integration.test.ts"
      to: "ct-adjustment.service.ts"
      via: "Test non-deductible aggregation"
      pattern: "aggregateNonDeductibleExpenses"
---

<objective>
Create integration tests and permissions middleware for Corporate Tax compliance.

Purpose: CT compliance requires verifiable calculations and role-based access control. Integration tests prove the system calculates CT correctly per FTA regulations, while permissions ensure only authorized users can prepare returns, approve calculations, and modify CT settings.

Output:
- Unit tests for CT calculation (threshold, rate, loss offset)
- Integration tests for CT lifecycle
- CT permissions middleware
- CT permission type definitions
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-corporate-tax-compliance/04-RESEARCH.md
@.planning/phases/04-corporate-tax-compliance/04-03-SUMMARY.md
@.planning/phases/04-corporate-tax-compliance/04-04-SUMMARY.md

# Dependencies
@backend/src/types/corporate-tax.types.ts
@backend/src/services/corporate-tax/ct-calculation.service.ts
@backend/src/services/corporate-tax/ct-adjustment.service.ts

# Existing test patterns
@backend/src/services/vat/__tests__/vat-integration.test.ts
@backend/src/middleware/vat-permissions.middleware.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CT Calculation Unit Tests</name>
  <files>backend/src/services/corporate-tax/__tests__/ct-calculation.test.ts</files>
  <action>
Create unit tests for CT calculation service:

```typescript
import { Decimal } from '@prisma/client/runtime/library';
import { Container } from 'inversify';
import { v4 as uuidv4 } from 'uuid';
import { CtCalculationService } from '../ct-calculation.service';
import { CtAdjustmentService } from '../ct-adjustment.service';
import { CT_CONSTANTS } from '../../../types/corporate-tax.types';
import { ZERO, roundCurrency, toDecimal } from '../../../utils/decimal-math.util';

/**
 * CT Calculation Service Unit Tests
 *
 * Tests UAE Corporate Tax calculation logic:
 * - 9% rate on taxable income exceeding AED 375,000
 * - 75% maximum loss offset
 * - Adjustment handling (non-deductible, exempt income)
 * - Small Business Relief eligibility
 *
 * Requirement: CT-01
 */

describe('CtCalculationService', () => {
  let calculationService: CtCalculationService;
  let mockPrisma: any;
  let mockAdjustmentService: any;
  let mockFinancialReportsService: any;

  const testCompanyId = uuidv4();
  const testFiscalYearId = uuidv4();

  beforeEach(() => {
    // Mock dependencies
    mockPrisma = {
      taxLoss: {
        findMany: jest.fn().mockResolvedValue([]),
        update: jest.fn(),
        create: jest.fn()
      },
      taxLossUsage: {
        create: jest.fn()
      },
      tenant_compliance_config: {
        findFirst: jest.fn().mockResolvedValue({ freeZoneStatus: null })
      },
      accountingJournalLine: {
        aggregate: jest.fn().mockResolvedValue({ _sum: { creditAmount: 0 } })
      }
    };

    mockAdjustmentService = {
      aggregateAdjustments: jest.fn().mockResolvedValue({
        nonDeductible: {
          finesAndPenalties: ZERO,
          entertainmentDisallowed: ZERO,
          donationsDisallowed: ZERO,
          ownerWithdrawals: ZERO,
          personalExpenses: ZERO,
          relatedPartyExcess: ZERO,
          recoverableInputVat: ZERO,
          illicitPayments: ZERO,
          total: ZERO
        },
        exemptIncome: {
          dividends: { domesticDividends: ZERO, foreignDividends: ZERO, total: ZERO, details: [] },
          capitalGains: { qualifyingGains: ZERO, nonQualifyingGains: ZERO, total: ZERO, details: [] },
          foreignPeIncome: ZERO,
          intraGroupReorganization: ZERO,
          total: ZERO
        },
        otherAdjustments: {
          unrealizedGainsLosses: ZERO,
          transitionalAdjustments: ZERO,
          interestLimitation: ZERO,
          total: ZERO
        }
      })
    };

    mockFinancialReportsService = {
      getProfitAndLoss: jest.fn()
    };

    // Create service with mocks
    calculationService = new CtCalculationService(
      mockPrisma,
      mockAdjustmentService,
      mockFinancialReportsService
    );
  });

  describe('CT Rate and Threshold', () => {
    it('should calculate 0% CT for income below AED 375,000', async () => {
      // Set accounting income below threshold
      mockFinancialReportsService.getProfitAndLoss.mockResolvedValue({
        netIncome: new Decimal('300000')
      });

      const result = await calculationService.calculateCorporateTax({
        companyId: testCompanyId,
        fiscalYearId: testFiscalYearId,
        startDate: new Date('2026-01-01'),
        endDate: new Date('2026-12-31')
      });

      expect(result.accountingIncome.toString()).toBe('300000');
      expect(result.taxableIncome.toString()).toBe('300000');
      expect(result.ctPayable.toString()).toBe('0'); // Below threshold
      expect(result.taxFreeAmount.toString()).toBe('300000');
      expect(result.taxableAmount.toString()).toBe('0');
    });

    it('should calculate 9% CT on income exceeding AED 375,000', async () => {
      // Set accounting income above threshold
      mockFinancialReportsService.getProfitAndLoss.mockResolvedValue({
        netIncome: new Decimal('1000000')
      });

      const result = await calculationService.calculateCorporateTax({
        companyId: testCompanyId,
        fiscalYearId: testFiscalYearId,
        startDate: new Date('2026-01-01'),
        endDate: new Date('2026-12-31')
      });

      expect(result.accountingIncome.toString()).toBe('1000000');
      expect(result.taxableIncome.toString()).toBe('1000000');
      expect(result.taxFreeAmount.toString()).toBe('375000');
      expect(result.taxableAmount.toString()).toBe('625000'); // 1,000,000 - 375,000
      expect(result.ctPayable.toString()).toBe('56250'); // 625,000 x 9%
    });

    it('should handle exactly AED 375,000 threshold', async () => {
      mockFinancialReportsService.getProfitAndLoss.mockResolvedValue({
        netIncome: new Decimal('375000')
      });

      const result = await calculationService.calculateCorporateTax({
        companyId: testCompanyId,
        fiscalYearId: testFiscalYearId,
        startDate: new Date('2026-01-01'),
        endDate: new Date('2026-12-31')
      });

      expect(result.ctPayable.toString()).toBe('0'); // Exactly at threshold
      expect(result.taxFreeAmount.toString()).toBe('375000');
      expect(result.taxableAmount.toString()).toBe('0');
    });

    it('should handle losses (negative income)', async () => {
      mockFinancialReportsService.getProfitAndLoss.mockResolvedValue({
        netIncome: new Decimal('-50000')
      });

      const result = await calculationService.calculateCorporateTax({
        companyId: testCompanyId,
        fiscalYearId: testFiscalYearId,
        startDate: new Date('2026-01-01'),
        endDate: new Date('2026-12-31')
      });

      expect(result.ctPayable.toString()).toBe('0');
      expect(result.taxableIncome.lessThan(ZERO) || result.taxableIncome.equals(ZERO)).toBe(true);
    });
  });

  describe('CT Adjustments', () => {
    it('should add back non-deductible expenses to taxable income', async () => {
      mockFinancialReportsService.getProfitAndLoss.mockResolvedValue({
        netIncome: new Decimal('500000')
      });

      // Set non-deductible adjustments
      mockAdjustmentService.aggregateAdjustments.mockResolvedValue({
        nonDeductible: {
          finesAndPenalties: new Decimal('10000'),
          entertainmentDisallowed: new Decimal('5000'), // 50% of 10,000
          total: new Decimal('15000')
        },
        exemptIncome: { total: ZERO },
        otherAdjustments: { total: ZERO }
      });

      const result = await calculationService.calculateCorporateTax({
        companyId: testCompanyId,
        fiscalYearId: testFiscalYearId,
        startDate: new Date('2026-01-01'),
        endDate: new Date('2026-12-31')
      });

      // Taxable income = 500,000 + 15,000 (non-deductible) = 515,000
      expect(result.taxableIncomeBeforeLosses.toString()).toBe('515000');
      expect(result.taxableIncome.toString()).toBe('515000');

      // CT = (515,000 - 375,000) x 9% = 140,000 x 9% = 12,600
      expect(result.ctPayable.toString()).toBe('12600');
    });

    it('should subtract exempt income from taxable income', async () => {
      mockFinancialReportsService.getProfitAndLoss.mockResolvedValue({
        netIncome: new Decimal('800000')
      });

      // Set exempt income
      mockAdjustmentService.aggregateAdjustments.mockResolvedValue({
        nonDeductible: { total: ZERO },
        exemptIncome: {
          dividends: { domesticDividends: new Decimal('100000'), total: new Decimal('100000') },
          capitalGains: { total: ZERO },
          foreignPeIncome: ZERO,
          intraGroupReorganization: ZERO,
          total: new Decimal('100000')
        },
        otherAdjustments: { total: ZERO }
      });

      const result = await calculationService.calculateCorporateTax({
        companyId: testCompanyId,
        fiscalYearId: testFiscalYearId,
        startDate: new Date('2026-01-01'),
        endDate: new Date('2026-12-31')
      });

      // Taxable income = 800,000 - 100,000 (exempt) = 700,000
      expect(result.taxableIncomeBeforeLosses.toString()).toBe('700000');

      // CT = (700,000 - 375,000) x 9% = 325,000 x 9% = 29,250
      expect(result.ctPayable.toString()).toBe('29250');
    });

    it('should combine non-deductible and exempt adjustments', async () => {
      mockFinancialReportsService.getProfitAndLoss.mockResolvedValue({
        netIncome: new Decimal('600000')
      });

      mockAdjustmentService.aggregateAdjustments.mockResolvedValue({
        nonDeductible: {
          finesAndPenalties: new Decimal('20000'),
          entertainmentDisallowed: new Decimal('10000'),
          total: new Decimal('30000')
        },
        exemptIncome: {
          dividends: { total: new Decimal('50000') },
          total: new Decimal('50000')
        },
        otherAdjustments: { total: ZERO }
      });

      const result = await calculationService.calculateCorporateTax({
        companyId: testCompanyId,
        fiscalYearId: testFiscalYearId,
        startDate: new Date('2026-01-01'),
        endDate: new Date('2026-12-31')
      });

      // Taxable income = 600,000 - 50,000 + 30,000 = 580,000
      expect(result.taxableIncomeBeforeLosses.toString()).toBe('580000');

      // CT = (580,000 - 375,000) x 9% = 205,000 x 9% = 18,450
      expect(result.ctPayable.toString()).toBe('18450');
    });
  });

  describe('Loss Carry-Forward', () => {
    it('should offset losses up to 75% of taxable income', async () => {
      mockFinancialReportsService.getProfitAndLoss.mockResolvedValue({
        netIncome: new Decimal('1000000')
      });

      // Set available losses
      mockPrisma.taxLoss.findMany.mockResolvedValue([
        {
          id: uuidv4(),
          companyId: testCompanyId,
          lossType: 'TRADING',
          lossAmount: 500000,
          usedAmount: 0,
          remainingAmount: 500000,
          periodStart: new Date('2025-01-01'),
          periodEnd: new Date('2025-12-31')
        }
      ]);

      const result = await calculationService.calculateCorporateTax({
        companyId: testCompanyId,
        fiscalYearId: testFiscalYearId,
        startDate: new Date('2026-01-01'),
        endDate: new Date('2026-12-31')
      });

      // Max offset = 1,000,000 x 75% = 750,000
      // Available = 500,000
      // Applied = min(500,000, 750,000) = 500,000
      expect(result.availableLosses.toString()).toBe('500000');
      expect(result.lossesApplied.toString()).toBe('500000');

      // Taxable income = 1,000,000 - 500,000 = 500,000
      expect(result.taxableIncome.toString()).toBe('500000');

      // CT = (500,000 - 375,000) x 9% = 125,000 x 9% = 11,250
      expect(result.ctPayable.toString()).toBe('11250');
    });

    it('should cap loss offset at 75% even with larger losses', async () => {
      mockFinancialReportsService.getProfitAndLoss.mockResolvedValue({
        netIncome: new Decimal('400000')
      });

      // Set large available losses
      mockPrisma.taxLoss.findMany.mockResolvedValue([
        {
          id: uuidv4(),
          companyId: testCompanyId,
          lossType: 'TRADING',
          lossAmount: 1000000,
          usedAmount: 0,
          remainingAmount: 1000000,
          periodStart: new Date('2025-01-01'),
          periodEnd: new Date('2025-12-31')
        }
      ]);

      const result = await calculationService.calculateCorporateTax({
        companyId: testCompanyId,
        fiscalYearId: testFiscalYearId,
        startDate: new Date('2026-01-01'),
        endDate: new Date('2026-12-31')
      });

      // Max offset = 400,000 x 75% = 300,000
      // Available = 1,000,000
      // Applied = min(1,000,000, 300,000) = 300,000
      expect(result.lossesApplied.toString()).toBe('300000');

      // Taxable income = 400,000 - 300,000 = 100,000
      expect(result.taxableIncome.toString()).toBe('100000');

      // Below threshold, CT = 0
      expect(result.ctPayable.toString()).toBe('0');
    });

    it('should apply losses in FIFO order', async () => {
      mockFinancialReportsService.getProfitAndLoss.mockResolvedValue({
        netIncome: new Decimal('1000000')
      });

      // Set multiple losses from different years
      mockPrisma.taxLoss.findMany.mockResolvedValue([
        {
          id: 'loss-2023',
          companyId: testCompanyId,
          lossType: 'TRADING',
          lossAmount: 200000,
          usedAmount: 0,
          remainingAmount: 200000,
          periodStart: new Date('2023-01-01'),
          periodEnd: new Date('2023-12-31')
        },
        {
          id: 'loss-2024',
          companyId: testCompanyId,
          lossType: 'TRADING',
          lossAmount: 300000,
          usedAmount: 0,
          remainingAmount: 300000,
          periodStart: new Date('2024-01-01'),
          periodEnd: new Date('2024-12-31')
        }
      ]);

      const result = await calculationService.calculateCorporateTax({
        companyId: testCompanyId,
        fiscalYearId: testFiscalYearId,
        startDate: new Date('2026-01-01'),
        endDate: new Date('2026-12-31')
      });

      // Total available = 500,000
      // Max offset = 750,000
      // Applied = 500,000 (all of it)
      expect(result.lossesApplied.toString()).toBe('500000');
    });
  });

  describe('Small Business Relief', () => {
    it('should apply 0% CT for eligible small businesses', async () => {
      mockFinancialReportsService.getProfitAndLoss.mockResolvedValue({
        netIncome: new Decimal('500000')
      });

      // Mock revenue below AED 3M
      mockPrisma.accountingJournalLine.aggregate.mockResolvedValue({
        _sum: { creditAmount: 2000000 }
      });

      const sbrCheck = await calculationService.checkSmallBusinessRelief(
        testCompanyId,
        new Date('2026-12-31')
      );

      expect(sbrCheck.eligible).toBe(true);
      expect(sbrCheck.currentPeriodRevenue.lessThanOrEqualTo(new Decimal('3000000'))).toBe(true);
    });

    it('should reject SBR for QFZPs', async () => {
      mockPrisma.tenant_compliance_config.findFirst.mockResolvedValue({
        freeZoneStatus: 'QFZP',
        isQualifyingFreeZonePerson: true
      });

      const sbrCheck = await calculationService.checkSmallBusinessRelief(
        testCompanyId,
        new Date('2026-12-31')
      );

      expect(sbrCheck.eligible).toBe(false);
      expect(sbrCheck.isQfzp).toBe(true);
    });

    it('should reject SBR after December 2026', async () => {
      const sbrCheck = await calculationService.checkSmallBusinessRelief(
        testCompanyId,
        new Date('2027-06-30')
      );

      expect(sbrCheck.eligible).toBe(false);
      expect(sbrCheck.reason).toContain('December 2026');
    });
  });

  describe('Taxable Income Schedule', () => {
    it('should generate correct schedule format', async () => {
      mockFinancialReportsService.getProfitAndLoss.mockResolvedValue({
        netIncome: new Decimal('750000')
      });

      mockAdjustmentService.aggregateAdjustments.mockResolvedValue({
        nonDeductible: { total: new Decimal('25000') },
        exemptIncome: { total: new Decimal('50000') },
        otherAdjustments: { total: ZERO }
      });

      mockPrisma.taxLoss.findMany.mockResolvedValue([
        {
          id: uuidv4(),
          remainingAmount: 100000,
          periodStart: new Date('2025-01-01')
        }
      ]);

      const result = await calculationService.calculateCorporateTax({
        companyId: testCompanyId,
        fiscalYearId: testFiscalYearId,
        startDate: new Date('2026-01-01'),
        endDate: new Date('2026-12-31')
      });

      const schedule = calculationService.generateTaxableIncomeSchedule(result);

      expect(schedule.line1_accountingIncome.toString()).toBe('750000');
      expect(schedule.line2_exemptIncome.toString()).toBe('50000');
      expect(schedule.line3_nonDeductibleExpenses.toString()).toBe('25000');
      // line6 = 750,000 - 50,000 + 25,000 = 725,000
      expect(schedule.line6_taxableIncomeBeforeLosses.toString()).toBe('725000');
    });
  });
});
```
  </action>
  <verify>
Run `npx jest --testPathPattern=ct-calculation.test.ts --passWithNoTests` to verify test structure.
  </verify>
  <done>
CT calculation unit tests:
- 9% rate on income exceeding AED 375,000
- 0% for income below threshold
- Exactly at threshold handling
- Non-deductible add-back to taxable income
- Exempt income subtraction
- 75% maximum loss offset
- FIFO loss application
- Small Business Relief eligibility
- Taxable income schedule generation
  </done>
</task>

<task type="auto">
  <name>Task 2: Create CT Integration Tests</name>
  <files>backend/src/services/corporate-tax/__tests__/ct-integration.test.ts</files>
  <action>
Create integration tests for CT lifecycle:

```typescript
import { PrismaClient } from '@prisma/client';
import { Decimal } from '@prisma/client/runtime/library';
import { Container } from 'inversify';
import { v4 as uuidv4 } from 'uuid';
import { CtCalculationService } from '../ct-calculation.service';
import { CtAdjustmentService } from '../ct-adjustment.service';
import { CtReportService } from '../ct-report.service';
import { TransferPricingService } from '../transfer-pricing.service';
import { TaxGroupService } from '../tax-group.service';
import { TYPES } from '../../../di/types';
import { setupTestContainer } from '../../../test/setup-container';
import { createTestCompany, createTestComplianceConfig, createTestChartOfAccounts, createTestJournalEntry } from '../../../test/factories';

/**
 * Corporate Tax Integration Tests
 *
 * Tests the complete CT lifecycle:
 * - Accounting income from P&L
 * - Non-deductible expense aggregation
 * - Exempt income aggregation
 * - CT calculation with threshold
 * - Transfer pricing adjustments
 * - Tax group consolidation
 */

describe('Corporate Tax Integration', () => {
  let container: Container;
  let prisma: PrismaClient;
  let calculationService: CtCalculationService;
  let adjustmentService: CtAdjustmentService;
  let reportService: CtReportService;
  let tpService: TransferPricingService;
  let taxGroupService: TaxGroupService;
  let testCompanyId: string;
  let testUserId: string;

  beforeAll(async () => {
    container = await setupTestContainer();
    prisma = container.get<PrismaClient>(TYPES.PrismaClient);
    calculationService = container.get<CtCalculationService>(TYPES.CtCalculationService);
    adjustmentService = container.get<CtAdjustmentService>(TYPES.CtAdjustmentService);
    reportService = container.get<CtReportService>(TYPES.CtReportService);
    tpService = container.get<TransferPricingService>(TYPES.TransferPricingService);
    taxGroupService = container.get<TaxGroupService>(TYPES.TaxGroupService);
  });

  beforeEach(async () => {
    const company = await createTestCompany(prisma, {
      name: 'Test CT Company LLC'
    });
    testCompanyId = company.id;

    await createTestComplianceConfig(prisma, {
      companyId: testCompanyId,
      trn: '100123456789012'
    });

    testUserId = uuidv4();

    // Create basic chart of accounts with CT classifications
    await createTestChartOfAccounts(prisma, testCompanyId, [
      { code: '4100', name: 'Sales Revenue', type: 'INCOME', ctCategory: 'TRADING_INCOME', ctIncomeClass: 'TAXABLE' },
      { code: '4600', name: 'Dividend Income', type: 'INCOME', ctCategory: 'DIVIDEND_INCOME', ctIncomeClass: 'EXEMPT_DIVIDEND' },
      { code: '5100', name: 'Cost of Sales', type: 'EXPENSE', ctCategory: 'COST_OF_SALES', ctExpenseClass: 'FULLY_DEDUCTIBLE' },
      { code: '6100', name: 'Salaries', type: 'EXPENSE', ctCategory: 'STAFF_COSTS', ctExpenseClass: 'FULLY_DEDUCTIBLE' },
      { code: '6510', name: 'Entertainment', type: 'EXPENSE', ctCategory: 'ENTERTAINMENT', ctExpenseClass: 'ENTERTAINMENT_50_PCT' },
      { code: '6810', name: 'Fines & Penalties', type: 'EXPENSE', ctCategory: 'FINES_PENALTIES', ctExpenseClass: 'NON_DEDUCTIBLE' }
    ]);
  });

  afterEach(async () => {
    // Cleanup
    await prisma.taxLossUsage.deleteMany({});
    await prisma.taxLoss.deleteMany({ where: { companyId: testCompanyId } });
    await prisma.relatedPartyTransaction.deleteMany({ where: { companyId: testCompanyId } });
    await prisma.ctTaxPeriod.deleteMany({ where: { companyId: testCompanyId } });
    await prisma.accountingJournalLine.deleteMany({});
    await prisma.accountingJournalEntry.deleteMany({ where: { companyId: testCompanyId } });
    await prisma.chart_of_accounts.deleteMany({ where: { companyId: testCompanyId } });
    await prisma.tenant_compliance_config.deleteMany({ where: { companyId: testCompanyId } });
    await prisma.company.deleteMany({ where: { id: testCompanyId } });
  });

  afterAll(async () => {
    await prisma.$disconnect();
  });

  describe('Full CT Calculation Lifecycle', () => {
    it('should calculate CT from accounting data', async () => {
      // Create journal entries for the period
      const accounts = await prisma.chart_of_accounts.findMany({
        where: { companyId: testCompanyId }
      });

      const salesAccount = accounts.find(a => a.accountCode === '4100');
      const cosAccount = accounts.find(a => a.accountCode === '5100');
      const salaryAccount = accounts.find(a => a.accountCode === '6100');

      // Record revenue: 2,000,000
      await createTestJournalEntry(prisma, {
        companyId: testCompanyId,
        entryDate: new Date('2026-06-15'),
        lines: [
          { accountId: salesAccount!.id, creditAmount: 2000000 }
        ]
      });

      // Record costs: 800,000
      await createTestJournalEntry(prisma, {
        companyId: testCompanyId,
        entryDate: new Date('2026-06-15'),
        lines: [
          { accountId: cosAccount!.id, debitAmount: 800000 }
        ]
      });

      // Record expenses: 400,000
      await createTestJournalEntry(prisma, {
        companyId: testCompanyId,
        entryDate: new Date('2026-06-15'),
        lines: [
          { accountId: salaryAccount!.id, debitAmount: 400000 }
        ]
      });

      // Net accounting income = 2,000,000 - 800,000 - 400,000 = 800,000

      const result = await calculationService.calculateCorporateTax({
        companyId: testCompanyId,
        fiscalYearId: 'FY2026',
        startDate: new Date('2026-01-01'),
        endDate: new Date('2026-12-31')
      });

      expect(result.accountingIncome.toString()).toBe('800000');
      expect(result.taxableIncome.toString()).toBe('800000');

      // CT = (800,000 - 375,000) x 9% = 425,000 x 9% = 38,250
      expect(result.ctPayable.toString()).toBe('38250');
    });

    it('should handle non-deductible expenses in CT calculation', async () => {
      const accounts = await prisma.chart_of_accounts.findMany({
        where: { companyId: testCompanyId }
      });

      const salesAccount = accounts.find(a => a.accountCode === '4100');
      const finesAccount = accounts.find(a => a.accountCode === '6810');
      const entertainmentAccount = accounts.find(a => a.accountCode === '6510');

      // Revenue: 1,000,000
      await createTestJournalEntry(prisma, {
        companyId: testCompanyId,
        entryDate: new Date('2026-06-15'),
        lines: [{ accountId: salesAccount!.id, creditAmount: 1000000 }]
      });

      // Fines: 50,000 (100% non-deductible)
      await createTestJournalEntry(prisma, {
        companyId: testCompanyId,
        entryDate: new Date('2026-06-15'),
        lines: [{ accountId: finesAccount!.id, debitAmount: 50000 }]
      });

      // Entertainment: 40,000 (50% = 20,000 non-deductible)
      await createTestJournalEntry(prisma, {
        companyId: testCompanyId,
        entryDate: new Date('2026-06-15'),
        lines: [{ accountId: entertainmentAccount!.id, debitAmount: 40000 }]
      });

      // Accounting income = 1,000,000 - 50,000 - 40,000 = 910,000
      // Non-deductible = 50,000 + 20,000 = 70,000
      // Taxable income = 910,000 + 70,000 = 980,000

      const adjustments = await adjustmentService.aggregateAdjustments({
        companyId: testCompanyId,
        startDate: new Date('2026-01-01'),
        endDate: new Date('2026-12-31')
      });

      expect(adjustments.nonDeductible.finesAndPenalties.toString()).toBe('50000');
      expect(adjustments.nonDeductible.entertainmentDisallowed.toString()).toBe('20000');
      expect(adjustments.nonDeductible.total.toString()).toBe('70000');
    });

    it('should handle exempt dividend income', async () => {
      const accounts = await prisma.chart_of_accounts.findMany({
        where: { companyId: testCompanyId }
      });

      const salesAccount = accounts.find(a => a.accountCode === '4100');
      const dividendAccount = accounts.find(a => a.accountCode === '4600');

      // Revenue: 500,000
      await createTestJournalEntry(prisma, {
        companyId: testCompanyId,
        entryDate: new Date('2026-06-15'),
        lines: [{ accountId: salesAccount!.id, creditAmount: 500000 }]
      });

      // Dividend income: 100,000 (exempt)
      await createTestJournalEntry(prisma, {
        companyId: testCompanyId,
        entryDate: new Date('2026-06-15'),
        lines: [{ accountId: dividendAccount!.id, creditAmount: 100000 }]
      });

      const adjustments = await adjustmentService.aggregateAdjustments({
        companyId: testCompanyId,
        startDate: new Date('2026-01-01'),
        endDate: new Date('2026-12-31')
      });

      // Dividend should be identified as exempt
      expect(adjustments.exemptIncome.total.toString()).toBe('100000');
    });
  });

  describe('Transfer Pricing Integration', () => {
    it('should record RP transaction and flag non-arm\'s length', async () => {
      const rpTransaction = await tpService.recordTransaction({
        companyId: testCompanyId,
        relatedPartyId: 'rp-001',
        relatedPartyName: 'Sister Company LLC',
        relationshipType: 'SISTER',
        transactionDate: new Date('2026-06-15'),
        transactionType: 'SERVICE',
        description: 'Management fee',
        transactionAmount: new Decimal('100000'),
        armLengthPrice: new Decimal('80000'), // Below arm's length
        pricingMethod: 'CUP',
        createdById: testUserId
      });

      expect(rpTransaction.adjustmentRequired).toBe(true);
      expect(rpTransaction.adjustmentAmount?.toString()).toBe('20000'); // Excess
    });

    it('should calculate TP thresholds', async () => {
      // Create multiple RP transactions totaling > AED 40M
      for (let i = 0; i < 5; i++) {
        await tpService.recordTransaction({
          companyId: testCompanyId,
          relatedPartyId: `rp-${i}`,
          relatedPartyName: `Related Party ${i}`,
          relationshipType: 'SUBSIDIARY',
          transactionDate: new Date('2026-06-15'),
          transactionType: 'SALE',
          description: `Intercompany sale ${i}`,
          transactionAmount: new Decimal('10000000'), // 10M each
          createdById: testUserId
        });
      }

      const thresholds = await tpService.calculateThresholds(
        testCompanyId,
        new Date('2026-01-01'),
        new Date('2026-12-31')
      );

      expect(thresholds.totalRelatedPartyValue.toString()).toBe('50000000');
      expect(thresholds.exceedsAed40M).toBe(true);
      expect(thresholds.requiresDisclosureForm).toBe(true);
    });
  });

  describe('CT-Adjusted Reports', () => {
    it('should generate CT-adjusted P&L', async () => {
      const accounts = await prisma.chart_of_accounts.findMany({
        where: { companyId: testCompanyId }
      });

      const salesAccount = accounts.find(a => a.accountCode === '4100');
      const cosAccount = accounts.find(a => a.accountCode === '5100');
      const entertainmentAccount = accounts.find(a => a.accountCode === '6510');

      // Create transactions
      await createTestJournalEntry(prisma, {
        companyId: testCompanyId,
        entryDate: new Date('2026-06-15'),
        lines: [{ accountId: salesAccount!.id, creditAmount: 1000000 }]
      });

      await createTestJournalEntry(prisma, {
        companyId: testCompanyId,
        entryDate: new Date('2026-06-15'),
        lines: [{ accountId: cosAccount!.id, debitAmount: 400000 }]
      });

      await createTestJournalEntry(prisma, {
        companyId: testCompanyId,
        entryDate: new Date('2026-06-15'),
        lines: [{ accountId: entertainmentAccount!.id, debitAmount: 20000 }]
      });

      const report = await reportService.generateCtAdjustedPnL({
        companyId: testCompanyId,
        fiscalYearId: 'FY2026',
        startDate: new Date('2026-01-01'),
        endDate: new Date('2026-12-31')
      });

      expect(report.netAccountingIncome.accountingAmount.toString()).toBe('580000');
      expect(report.ctAdjustments.nonDeductibleAdditions.toString()).toBe('10000'); // 50% of 20,000
      expect(report.taxableIncome.toString()).toBe('590000');
    });
  });

  describe('Loss Carry-Forward', () => {
    it('should track and apply losses', async () => {
      // Record a loss
      const loss = await calculationService.recordTaxLoss(
        testCompanyId,
        'FY2025',
        new Decimal('200000'),
        new Date('2025-01-01'),
        new Date('2025-12-31'),
        'TRADING',
        testUserId
      );

      expect(loss.remainingAmount.toString()).toBe('200000');

      // Verify loss is available
      const losses = await calculationService.getAvailableLosses(testCompanyId);
      expect(losses.length).toBe(1);
      expect(losses[0].remainingAmount.toString()).toBe('200000');
    });
  });
});
```
  </action>
  <verify>
Run `npx jest --testPathPattern=ct-integration.test.ts --passWithNoTests` to verify test structure.
  </verify>
  <done>
CT integration tests:
- Full CT calculation lifecycle from accounting data
- Non-deductible expense handling (entertainment 50%, fines 100%)
- Exempt dividend income handling
- Transfer pricing transaction recording
- TP threshold calculation (AED 40M)
- CT-adjusted P&L generation
- Loss carry-forward tracking
  </done>
</task>

<task type="auto">
  <name>Task 3: Create CT Permissions Middleware</name>
  <files>backend/src/middleware/ct-permissions.middleware.ts, backend/src/types/ct-permissions.ts</files>
  <action>
Create CT permission types:

```typescript
// backend/src/types/ct-permissions.ts

/**
 * CT Permission Types
 *
 * Defines granular permissions for Corporate Tax operations.
 * Based on FTA compliance requirements and separation of duties.
 */

export const CT_PERMISSIONS = {
  // Transaction classification
  CT_CLASSIFY_EXPENSE: 'ct:classify:expense',
  CT_CLASSIFY_INCOME: 'ct:classify:income',

  // Chart of accounts mapping
  CT_CHART_MAPPING_VIEW: 'ct:chart-mapping:view',
  CT_CHART_MAPPING_EDIT: 'ct:chart-mapping:edit',

  // CT calculation
  CT_CALCULATION_VIEW: 'ct:calculation:view',
  CT_CALCULATION_RUN: 'ct:calculation:run',

  // CT reports
  CT_REPORT_VIEW: 'ct:report:view',
  CT_REPORT_GENERATE: 'ct:report:generate',
  CT_REPORT_EXPORT: 'ct:report:export',

  // CT return
  CT_RETURN_PREPARE: 'ct:return:prepare',
  CT_RETURN_APPROVE: 'ct:return:approve',
  CT_RETURN_FILE: 'ct:return:file',

  // Transfer pricing
  CT_TP_TRANSACTION_CREATE: 'ct:tp:transaction:create',
  CT_TP_TRANSACTION_VIEW: 'ct:tp:transaction:view',
  CT_TP_ARM_LENGTH_UPDATE: 'ct:tp:arm-length:update',
  CT_TP_DOCUMENTATION: 'ct:tp:documentation',

  // Tax groups
  CT_GROUP_CREATE: 'ct:group:create',
  CT_GROUP_MANAGE: 'ct:group:manage',
  CT_GROUP_CONSOLIDATE: 'ct:group:consolidate',

  // Tax losses
  CT_LOSS_RECORD: 'ct:loss:record',
  CT_LOSS_TRANSFER: 'ct:loss:transfer',
  CT_LOSS_VIEW: 'ct:loss:view',

  // Configuration
  CT_CONFIG_VIEW: 'ct:config:view',
  CT_CONFIG_EDIT: 'ct:config:edit',

  // Audit trail
  CT_AUDIT_VIEW: 'ct:audit:view',
  CT_AUDIT_EXPORT: 'ct:audit:export',

  // Retention
  CT_RETENTION_VIEW: 'ct:retention:view',
  CT_RETENTION_MANAGE: 'ct:retention:manage'
} as const;

export type CtPermission = typeof CT_PERMISSIONS[keyof typeof CT_PERMISSIONS];

// Role-based permission bundles
export const CT_ROLE_PERMISSIONS: Record<string, CtPermission[]> = {
  // Tax Accountant: Day-to-day CT operations
  TAX_ACCOUNTANT: [
    CT_PERMISSIONS.CT_CLASSIFY_EXPENSE,
    CT_PERMISSIONS.CT_CLASSIFY_INCOME,
    CT_PERMISSIONS.CT_CHART_MAPPING_VIEW,
    CT_PERMISSIONS.CT_CALCULATION_VIEW,
    CT_PERMISSIONS.CT_REPORT_VIEW,
    CT_PERMISSIONS.CT_TP_TRANSACTION_CREATE,
    CT_PERMISSIONS.CT_TP_TRANSACTION_VIEW,
    CT_PERMISSIONS.CT_LOSS_VIEW,
    CT_PERMISSIONS.CT_CONFIG_VIEW,
    CT_PERMISSIONS.CT_AUDIT_VIEW,
    CT_PERMISSIONS.CT_RETENTION_VIEW
  ],

  // Tax Manager: CT preparation and review
  TAX_MANAGER: [
    CT_PERMISSIONS.CT_CLASSIFY_EXPENSE,
    CT_PERMISSIONS.CT_CLASSIFY_INCOME,
    CT_PERMISSIONS.CT_CHART_MAPPING_VIEW,
    CT_PERMISSIONS.CT_CHART_MAPPING_EDIT,
    CT_PERMISSIONS.CT_CALCULATION_VIEW,
    CT_PERMISSIONS.CT_CALCULATION_RUN,
    CT_PERMISSIONS.CT_REPORT_VIEW,
    CT_PERMISSIONS.CT_REPORT_GENERATE,
    CT_PERMISSIONS.CT_REPORT_EXPORT,
    CT_PERMISSIONS.CT_RETURN_PREPARE,
    CT_PERMISSIONS.CT_TP_TRANSACTION_CREATE,
    CT_PERMISSIONS.CT_TP_TRANSACTION_VIEW,
    CT_PERMISSIONS.CT_TP_ARM_LENGTH_UPDATE,
    CT_PERMISSIONS.CT_TP_DOCUMENTATION,
    CT_PERMISSIONS.CT_LOSS_RECORD,
    CT_PERMISSIONS.CT_LOSS_VIEW,
    CT_PERMISSIONS.CT_CONFIG_VIEW,
    CT_PERMISSIONS.CT_AUDIT_VIEW,
    CT_PERMISSIONS.CT_AUDIT_EXPORT,
    CT_PERMISSIONS.CT_RETENTION_VIEW
  ],

  // CFO: Full CT authority including filing
  CFO: [
    ...Object.values(CT_PERMISSIONS)
  ],

  // External Auditor: Read-only CT access
  AUDITOR: [
    CT_PERMISSIONS.CT_CHART_MAPPING_VIEW,
    CT_PERMISSIONS.CT_CALCULATION_VIEW,
    CT_PERMISSIONS.CT_REPORT_VIEW,
    CT_PERMISSIONS.CT_TP_TRANSACTION_VIEW,
    CT_PERMISSIONS.CT_LOSS_VIEW,
    CT_PERMISSIONS.CT_CONFIG_VIEW,
    CT_PERMISSIONS.CT_AUDIT_VIEW,
    CT_PERMISSIONS.CT_AUDIT_EXPORT,
    CT_PERMISSIONS.CT_RETENTION_VIEW
  ]
};
```

Create CT permissions middleware:

```typescript
// backend/src/middleware/ct-permissions.middleware.ts

import { Request, Response, NextFunction } from 'express';
import { PrismaClient } from '@prisma/client';
import { container } from '../di/container';
import { TYPES } from '../di/types';
import { CT_PERMISSIONS, CtPermission, CT_ROLE_PERMISSIONS } from '../types/ct-permissions';
import logger from '../services/logger.service';

/**
 * CT Permissions Middleware
 *
 * Enforces role-based access control for Corporate Tax operations.
 * Integrates with existing user roles and company context.
 */

interface AuthenticatedRequest extends Request {
  user?: {
    id: string;
    email: string;
    roles: string[];
    companyId: string;
  };
}

/**
 * Checks if user has the required CT permission
 */
export function hasCtPermission(
  userRoles: string[],
  requiredPermission: CtPermission
): boolean {
  // Superadmin bypass
  if (userRoles.includes('SUPER_ADMIN') || userRoles.includes('ADMIN')) {
    return true;
  }

  // Check each role for the permission
  for (const role of userRoles) {
    const rolePermissions = CT_ROLE_PERMISSIONS[role.toUpperCase()];
    if (rolePermissions && rolePermissions.includes(requiredPermission)) {
      return true;
    }
  }

  return false;
}

/**
 * Middleware factory for requiring CT permissions
 */
export function requireCtPermission(permission: CtPermission) {
  return async (
    req: AuthenticatedRequest,
    res: Response,
    next: NextFunction
  ): Promise<void> => {
    try {
      if (!req.user) {
        res.status(401).json({
          error: 'Authentication required',
          code: 'UNAUTHORIZED'
        });
        return;
      }

      if (!hasCtPermission(req.user.roles, permission)) {
        logger.warn('CT permission denied', {
          userId: req.user.id,
          email: req.user.email,
          roles: req.user.roles,
          requiredPermission: permission,
          path: req.path
        });

        res.status(403).json({
          error: 'Insufficient permissions for this Corporate Tax operation',
          code: 'FORBIDDEN',
          requiredPermission: permission
        });
        return;
      }

      // Check company access
      const companyId = req.params.companyId || req.body?.companyId;
      if (companyId && companyId !== req.user.companyId) {
        const prisma = container.get<PrismaClient>(TYPES.PrismaClient);
        const userCompany = await prisma.userCompanies.findFirst({
          where: {
            userId: req.user.id,
            companyId: companyId
          }
        });

        if (!userCompany) {
          res.status(403).json({
            error: 'Access denied to this company',
            code: 'COMPANY_ACCESS_DENIED'
          });
          return;
        }
      }

      next();
    } catch (error) {
      logger.error('CT permission check failed', { error });
      res.status(500).json({
        error: 'Permission check failed',
        code: 'INTERNAL_ERROR'
      });
    }
  };
}

/**
 * Middleware for requiring any of multiple CT permissions
 */
export function requireAnyCtPermission(permissions: CtPermission[]) {
  return async (
    req: AuthenticatedRequest,
    res: Response,
    next: NextFunction
  ): Promise<void> => {
    if (!req.user) {
      res.status(401).json({
        error: 'Authentication required',
        code: 'UNAUTHORIZED'
      });
      return;
    }

    const hasAnyPermission = permissions.some(permission =>
      hasCtPermission(req.user!.roles, permission)
    );

    if (!hasAnyPermission) {
      res.status(403).json({
        error: 'Insufficient permissions for this Corporate Tax operation',
        code: 'FORBIDDEN',
        requiredPermissions: permissions
      });
      return;
    }

    next();
  };
}

/**
 * Middleware for requiring all of multiple CT permissions
 */
export function requireAllCtPermissions(permissions: CtPermission[]) {
  return async (
    req: AuthenticatedRequest,
    res: Response,
    next: NextFunction
  ): Promise<void> => {
    if (!req.user) {
      res.status(401).json({
        error: 'Authentication required',
        code: 'UNAUTHORIZED'
      });
      return;
    }

    const missingPermissions = permissions.filter(permission =>
      !hasCtPermission(req.user!.roles, permission)
    );

    if (missingPermissions.length > 0) {
      res.status(403).json({
        error: 'Insufficient permissions for this Corporate Tax operation',
        code: 'FORBIDDEN',
        missingPermissions
      });
      return;
    }

    next();
  };
}

// Export permission constants for route definitions
export { CT_PERMISSIONS };
```
  </action>
  <verify>
Run `npx tsc --noEmit` to verify TypeScript compiles.
Verify middleware exports requireCtPermission.
  </verify>
  <done>
CT permissions middleware:
- CT_PERMISSIONS with all CT operations
- Role-based bundles: TAX_ACCOUNTANT, TAX_MANAGER, CFO, AUDITOR
- requireCtPermission() middleware factory
- requireAnyCtPermission() for OR logic
- requireAllCtPermissions() for AND logic
- Multi-tenant company access check
- Audit logging for denied access
  </done>
</task>

</tasks>

<verification>
1. Run `npx tsc --noEmit` - all files should compile
2. Run `npx jest --testPathPattern=ct- --passWithNoTests` to verify test structure
3. Verify CT calculation tests cover threshold and rate
4. Verify integration tests cover non-deductible and exempt income
5. Verify permission middleware exports CT_PERMISSIONS constant
</verification>

<success_criteria>
- Unit tests verify 9% CT rate on income exceeding AED 375,000 (CT-01)
- Unit tests verify 75% maximum loss offset (CT-01)
- Integration tests cover full CT lifecycle
- Non-deductible expense tests cover entertainment 50% and fines 100% (CT-02)
- Exempt income tests cover dividend exemption (CT-03)
- CT permissions restrict access by role
- Permission middleware registered and functional
</success_criteria>

<output>
After completion, create `.planning/phases/04-corporate-tax-compliance/04-09-SUMMARY.md`
</output>
