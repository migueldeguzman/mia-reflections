---
phase: 04-corporate-tax-compliance
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/src/services/corporate-tax/ct-chart-mapping.service.ts
  - backend/prisma/seed/ct-chart-mappings.ts
  - backend/src/di/container.ts
autonomous: true

must_haves:
  truths:
    - "Chart of accounts can be mapped to CT categories for auto-classification"
    - "Entertainment accounts automatically flag 50% non-deductible"
    - "Fines/Penalties accounts automatically flag 100% non-deductible"
    - "Dividend income accounts can be flagged for participation exemption check"
    - "Default CT mappings provided for common UAE chart of accounts"
  artifacts:
    - path: "backend/src/services/corporate-tax/ct-chart-mapping.service.ts"
      provides: "Service for managing CT chart of accounts mappings"
      exports: ["CtChartMappingService"]
      min_lines: 200
    - path: "backend/prisma/seed/ct-chart-mappings.ts"
      provides: "Default CT category mappings for common accounts"
      contains: "ENTERTAINMENT"
  key_links:
    - from: "ct-chart-mapping.service.ts"
      to: "prisma.chartOfAccounts"
      via: "Update CT classification fields"
      pattern: "prisma.chart_of_accounts"
---

<objective>
Create the CT chart of accounts mapping service and default mappings for automatic expense/income classification.

Purpose: CT-04 requires mapping chart of accounts to CT categories so transactions can be automatically classified as deductible, non-deductible (fines), partially deductible (entertainment 50%), or exempt income (dividends). This avoids manual classification of every transaction.

Output:
- CtChartMappingService for managing CT mappings
- Default mappings for common UAE chart of accounts
- Auto-classification rules for common scenarios
- Bulk mapping import capability
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-corporate-tax-compliance/04-RESEARCH.md

# Existing codebase patterns
@backend/prisma/schema.prisma
@backend/src/services/finance/chart-of-accounts.service.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CT Chart Mapping Service</name>
  <files>backend/src/services/corporate-tax/ct-chart-mapping.service.ts</files>
  <action>
Create the CT chart of accounts mapping service:

```typescript
import { PrismaClient, CtAccountCategory, CtExpenseClassification, CtIncomeClassification } from '@prisma/client';
import { injectable, inject } from 'inversify';
import { TYPES } from '../../di/types';
import logger from '../logger.service';

/**
 * CT Chart Mapping Service
 *
 * Manages Corporate Tax classification mappings for chart of accounts.
 * Enables automatic classification of transactions for CT purposes.
 *
 * Key mappings:
 * - Expense accounts → CtExpenseClassification (deductible, non-deductible, 50% entertainment)
 * - Income accounts → CtIncomeClassification (taxable, exempt dividends, etc.)
 * - Account categories → CtAccountCategory (for reporting grouping)
 *
 * Requirement: CT-04
 */

// ============================================================================
// Types
// ============================================================================

export interface CtMappingInput {
  accountId: string;
  ctCategory: CtAccountCategory;
  ctExpenseClass?: CtExpenseClassification;
  ctIncomeClass?: CtIncomeClassification;
  isQualifyingPBE?: boolean;
}

export interface CtMappingRule {
  accountCodePattern: string;  // Regex pattern for account codes
  accountNamePattern?: string; // Optional name pattern
  ctCategory: CtAccountCategory;
  ctExpenseClass?: CtExpenseClassification;
  ctIncomeClass?: CtIncomeClassification;
  description: string;
}

export interface BulkMappingResult {
  total: number;
  updated: number;
  skipped: number;
  errors: Array<{ accountId: string; error: string }>;
}

export interface CtMappingSummary {
  totalAccounts: number;
  mappedAccounts: number;
  unmappedAccounts: number;
  byCategory: Record<string, number>;
  byExpenseClass: Record<string, number>;
  byIncomeClass: Record<string, number>;
}

// ============================================================================
// Default Mapping Rules
// ============================================================================

/**
 * Default CT mapping rules based on common UAE chart of accounts patterns.
 * These are applied during initial setup or when auto-mapping is run.
 */
export const DEFAULT_CT_MAPPING_RULES: CtMappingRule[] = [
  // Revenue accounts (4xxx or 7xxx typically)
  {
    accountCodePattern: '^4[0-3]',
    ctCategory: 'TRADING_INCOME',
    ctIncomeClass: 'TAXABLE',
    description: 'Trading/sales revenue - fully taxable'
  },
  {
    accountCodePattern: '^4[4-5]',
    accountNamePattern: '(interest|finance)',
    ctCategory: 'INVESTMENT_INCOME',
    ctIncomeClass: 'TAXABLE',
    description: 'Interest and finance income'
  },
  {
    accountCodePattern: '^4[6-7]',
    accountNamePattern: '(dividend)',
    ctCategory: 'DIVIDEND_INCOME',
    ctIncomeClass: 'EXEMPT_DIVIDEND',
    description: 'Dividend income - check participation exemption'
  },
  {
    accountCodePattern: '^4[8-9]',
    accountNamePattern: '(gain|disposal)',
    ctCategory: 'CAPITAL_GAINS',
    ctIncomeClass: 'TAXABLE',
    description: 'Capital gains - check participation exemption'
  },

  // Cost of sales (5xxx)
  {
    accountCodePattern: '^5',
    ctCategory: 'COST_OF_SALES',
    ctExpenseClass: 'FULLY_DEDUCTIBLE',
    description: 'Cost of goods sold - fully deductible'
  },

  // Staff costs (6[0-1]xx)
  {
    accountCodePattern: '^6[0-1]',
    ctCategory: 'STAFF_COSTS',
    ctExpenseClass: 'FULLY_DEDUCTIBLE',
    description: 'Salaries and employee benefits - fully deductible'
  },

  // Admin expenses (6[2-4]xx)
  {
    accountCodePattern: '^6[2-4]',
    ctCategory: 'ADMIN_EXPENSES',
    ctExpenseClass: 'FULLY_DEDUCTIBLE',
    description: 'General admin expenses - fully deductible'
  },

  // Entertainment (specific accounts)
  {
    accountCodePattern: '^65',
    accountNamePattern: '(entertainment|hospitality|client.*meal|business.*lunch)',
    ctCategory: 'ENTERTAINMENT',
    ctExpenseClass: 'ENTERTAINMENT_50_PCT',
    description: 'Entertainment expenses - 50% deductible per FTA Article 33(2)'
  },

  // Depreciation
  {
    accountCodePattern: '^66',
    accountNamePattern: '(depreciation|amortization)',
    ctCategory: 'DEPRECIATION',
    ctExpenseClass: 'FULLY_DEDUCTIBLE',
    description: 'Depreciation and amortization - follow accounting treatment'
  },

  // Finance costs
  {
    accountCodePattern: '^67',
    accountNamePattern: '(interest|finance.*cost|bank.*charge)',
    ctCategory: 'FINANCE_COSTS',
    ctExpenseClass: 'FULLY_DEDUCTIBLE',
    description: 'Finance costs - deductible (subject to limitations for related party)'
  },

  // Fines and penalties (NON-DEDUCTIBLE)
  {
    accountCodePattern: '^68[0-2]',
    accountNamePattern: '(fine|penalty|penalt|violation)',
    ctCategory: 'FINES_PENALTIES',
    ctExpenseClass: 'NON_DEDUCTIBLE',
    description: 'Fines and penalties - 0% deductible per FTA Article 33'
  },

  // Donations
  {
    accountCodePattern: '^68[3-5]',
    accountNamePattern: '(donation|charity|charitable)',
    ctCategory: 'DONATIONS',
    ctExpenseClass: 'FULLY_DEDUCTIBLE', // Default to deductible, flag non-QPBE separately
    description: 'Donations - deductible only if to qualifying public benefit entity'
  },

  // Related party expenses
  {
    accountCodePattern: '^69',
    accountNamePattern: '(intercompany|related.*party|management.*fee)',
    ctCategory: 'RELATED_PARTY_EXPENSE',
    ctExpenseClass: 'RELATED_PARTY',
    description: 'Related party expenses - subject to arm\'s length test'
  },

  // Fixed assets (1xxx)
  {
    accountCodePattern: '^1[0-4]',
    ctCategory: 'FIXED_ASSETS',
    description: 'Property, plant, and equipment'
  },

  // Investments (1[5-7]xx)
  {
    accountCodePattern: '^1[5-7]',
    ctCategory: 'INVESTMENTS',
    description: 'Investment holdings'
  },

  // Related party receivables
  {
    accountCodePattern: '^1[8-9]',
    accountNamePattern: '(intercompany|related.*party|due.*from.*affiliate)',
    ctCategory: 'RELATED_PARTY_RECEIVABLES',
    description: 'Amounts due from related parties'
  },

  // Related party payables
  {
    accountCodePattern: '^2[8-9]',
    accountNamePattern: '(intercompany|related.*party|due.*to.*affiliate)',
    ctCategory: 'RELATED_PARTY_PAYABLES',
    description: 'Amounts due to related parties'
  }
];

// ============================================================================
// Service
// ============================================================================

@injectable()
export class CtChartMappingService {
  constructor(
    @inject(TYPES.PrismaClient)
    private readonly prisma: PrismaClient
  ) {}

  /**
   * Updates CT mapping for a single account
   */
  async updateAccountMapping(
    companyId: string,
    input: CtMappingInput,
    userId: string
  ): Promise<void> {
    const account = await this.prisma.chart_of_accounts.findFirst({
      where: {
        id: input.accountId,
        companyId
      }
    });

    if (!account) {
      throw new Error('Account not found or access denied');
    }

    await this.prisma.chart_of_accounts.update({
      where: { id: input.accountId },
      data: {
        ctCategory: input.ctCategory,
        ctExpenseClass: input.ctExpenseClass,
        ctIncomeClass: input.ctIncomeClass,
        isQualifyingPBE: input.isQualifyingPBE ?? false,
        updatedAt: new Date()
      }
    });

    // Audit log
    await this.prisma.auditLogs.create({
      data: {
        userId,
        action: 'CT_MAPPING_UPDATE',
        entity: 'ChartOfAccounts',
        entityId: input.accountId,
        newValue: {
          ctCategory: input.ctCategory,
          ctExpenseClass: input.ctExpenseClass,
          ctIncomeClass: input.ctIncomeClass,
          isQualifyingPBE: input.isQualifyingPBE
        }
      }
    });

    logger.info('CT mapping updated', {
      accountId: input.accountId,
      ctCategory: input.ctCategory,
      userId
    });
  }

  /**
   * Applies default CT mapping rules to all unmapped accounts
   */
  async applyDefaultMappings(
    companyId: string,
    userId: string,
    overwriteExisting: boolean = false
  ): Promise<BulkMappingResult> {
    const whereClause = overwriteExisting
      ? { companyId }
      : { companyId, ctCategory: null };

    const accounts = await this.prisma.chart_of_accounts.findMany({
      where: whereClause,
      select: {
        id: true,
        accountCode: true,
        accountName: true
      }
    });

    const result: BulkMappingResult = {
      total: accounts.length,
      updated: 0,
      skipped: 0,
      errors: []
    };

    for (const account of accounts) {
      try {
        const mapping = this.findMatchingRule(account.accountCode, account.accountName);

        if (mapping) {
          await this.prisma.chart_of_accounts.update({
            where: { id: account.id },
            data: {
              ctCategory: mapping.ctCategory,
              ctExpenseClass: mapping.ctExpenseClass,
              ctIncomeClass: mapping.ctIncomeClass,
              updatedAt: new Date()
            }
          });
          result.updated++;
        } else {
          result.skipped++;
        }
      } catch (error) {
        result.errors.push({
          accountId: account.id,
          error: error instanceof Error ? error.message : 'Unknown error'
        });
      }
    }

    // Audit log for bulk operation
    await this.prisma.auditLogs.create({
      data: {
        userId,
        action: 'CT_MAPPING_BULK_APPLY',
        entity: 'ChartOfAccounts',
        entityId: companyId,
        newValue: {
          total: result.total,
          updated: result.updated,
          skipped: result.skipped,
          errorCount: result.errors.length
        }
      }
    });

    logger.info('Default CT mappings applied', {
      companyId,
      result,
      userId
    });

    return result;
  }

  /**
   * Finds matching CT rule for an account
   */
  private findMatchingRule(
    accountCode: string,
    accountName: string
  ): CtMappingRule | null {
    const normalizedName = accountName.toLowerCase();

    for (const rule of DEFAULT_CT_MAPPING_RULES) {
      const codeMatches = new RegExp(rule.accountCodePattern, 'i').test(accountCode);

      if (codeMatches) {
        // If rule has name pattern, check that too
        if (rule.accountNamePattern) {
          const nameMatches = new RegExp(rule.accountNamePattern, 'i').test(normalizedName);
          if (nameMatches) {
            return rule;
          }
        } else {
          // Code pattern only, return match
          return rule;
        }
      }
    }

    return null;
  }

  /**
   * Gets CT mapping summary for a company
   */
  async getMappingSummary(companyId: string): Promise<CtMappingSummary> {
    const accounts = await this.prisma.chart_of_accounts.findMany({
      where: { companyId },
      select: {
        id: true,
        ctCategory: true,
        ctExpenseClass: true,
        ctIncomeClass: true
      }
    });

    const summary: CtMappingSummary = {
      totalAccounts: accounts.length,
      mappedAccounts: accounts.filter(a => a.ctCategory !== null).length,
      unmappedAccounts: accounts.filter(a => a.ctCategory === null).length,
      byCategory: {},
      byExpenseClass: {},
      byIncomeClass: {}
    };

    // Count by category
    for (const account of accounts) {
      if (account.ctCategory) {
        summary.byCategory[account.ctCategory] = (summary.byCategory[account.ctCategory] || 0) + 1;
      }
      if (account.ctExpenseClass) {
        summary.byExpenseClass[account.ctExpenseClass] = (summary.byExpenseClass[account.ctExpenseClass] || 0) + 1;
      }
      if (account.ctIncomeClass) {
        summary.byIncomeClass[account.ctIncomeClass] = (summary.byIncomeClass[account.ctIncomeClass] || 0) + 1;
      }
    }

    return summary;
  }

  /**
   * Gets accounts by CT expense classification
   */
  async getAccountsByExpenseClass(
    companyId: string,
    expenseClass: CtExpenseClassification
  ): Promise<Array<{ id: string; accountCode: string; accountName: string }>> {
    return this.prisma.chart_of_accounts.findMany({
      where: {
        companyId,
        ctExpenseClass: expenseClass
      },
      select: {
        id: true,
        accountCode: true,
        accountName: true
      }
    });
  }

  /**
   * Gets accounts by CT income classification
   */
  async getAccountsByIncomeClass(
    companyId: string,
    incomeClass: CtIncomeClassification
  ): Promise<Array<{ id: string; accountCode: string; accountName: string }>> {
    return this.prisma.chart_of_accounts.findMany({
      where: {
        companyId,
        ctIncomeClass: incomeClass
      },
      select: {
        id: true,
        accountCode: true,
        accountName: true
      }
    });
  }

  /**
   * Gets all non-deductible expense accounts
   */
  async getNonDeductibleAccounts(
    companyId: string
  ): Promise<Array<{
    id: string;
    accountCode: string;
    accountName: string;
    ctExpenseClass: CtExpenseClassification;
    deductiblePercent: number;
  }>> {
    const accounts = await this.prisma.chart_of_accounts.findMany({
      where: {
        companyId,
        ctExpenseClass: {
          in: ['NON_DEDUCTIBLE', 'ENTERTAINMENT_50_PCT', 'OWNER_WITHDRAWAL', 'PERSONAL_EXPENSE']
        }
      },
      select: {
        id: true,
        accountCode: true,
        accountName: true,
        ctExpenseClass: true
      }
    });

    return accounts.map(account => ({
      ...account,
      ctExpenseClass: account.ctExpenseClass!,
      deductiblePercent: this.getDeductiblePercent(account.ctExpenseClass!)
    }));
  }

  /**
   * Gets deductible percentage for expense classification
   */
  private getDeductiblePercent(classification: CtExpenseClassification): number {
    switch (classification) {
      case 'FULLY_DEDUCTIBLE':
        return 100;
      case 'ENTERTAINMENT_50_PCT':
        return 50;
      case 'NON_DEDUCTIBLE':
      case 'OWNER_WITHDRAWAL':
      case 'PERSONAL_EXPENSE':
        return 0;
      case 'RELATED_PARTY':
        return 100; // Subject to arm's length test
      default:
        return 100;
    }
  }

  /**
   * Gets all exempt income accounts
   */
  async getExemptIncomeAccounts(
    companyId: string
  ): Promise<Array<{
    id: string;
    accountCode: string;
    accountName: string;
    ctIncomeClass: CtIncomeClassification;
    exemptionType: string;
  }>> {
    const accounts = await this.prisma.chart_of_accounts.findMany({
      where: {
        companyId,
        ctIncomeClass: {
          in: ['EXEMPT_DIVIDEND', 'EXEMPT_CAPITAL_GAIN', 'EXEMPT_FOREIGN_PE', 'QUALIFYING_INCOME']
        }
      },
      select: {
        id: true,
        accountCode: true,
        accountName: true,
        ctIncomeClass: true
      }
    });

    return accounts.map(account => ({
      ...account,
      ctIncomeClass: account.ctIncomeClass!,
      exemptionType: this.getExemptionType(account.ctIncomeClass!)
    }));
  }

  /**
   * Gets exemption type description
   */
  private getExemptionType(classification: CtIncomeClassification): string {
    switch (classification) {
      case 'EXEMPT_DIVIDEND':
        return 'Participation exemption - dividends';
      case 'EXEMPT_CAPITAL_GAIN':
        return 'Participation exemption - capital gains';
      case 'EXEMPT_FOREIGN_PE':
        return 'Foreign PE income election';
      case 'QUALIFYING_INCOME':
        return 'QFZP qualifying income';
      default:
        return 'Taxable';
    }
  }

  /**
   * Validates CT mappings for completeness
   */
  async validateMappings(companyId: string): Promise<{
    valid: boolean;
    issues: string[];
    warnings: string[];
  }> {
    const issues: string[] = [];
    const warnings: string[] = [];

    // Check for unmapped expense accounts
    const unmappedExpenses = await this.prisma.chart_of_accounts.count({
      where: {
        companyId,
        accountType: 'EXPENSE',
        ctExpenseClass: null
      }
    });

    if (unmappedExpenses > 0) {
      warnings.push(`${unmappedExpenses} expense account(s) have no CT classification`);
    }

    // Check for unmapped income accounts
    const unmappedIncome = await this.prisma.chart_of_accounts.count({
      where: {
        companyId,
        accountType: 'INCOME',
        ctIncomeClass: null
      }
    });

    if (unmappedIncome > 0) {
      warnings.push(`${unmappedIncome} income account(s) have no CT classification`);
    }

    // Check for dividend accounts without exemption check
    const dividendAccounts = await this.prisma.chart_of_accounts.count({
      where: {
        companyId,
        ctCategory: 'DIVIDEND_INCOME',
        ctIncomeClass: null
      }
    });

    if (dividendAccounts > 0) {
      issues.push(`${dividendAccounts} dividend account(s) need participation exemption classification`);
    }

    return {
      valid: issues.length === 0,
      issues,
      warnings
    };
  }
}
```

Create the directory if needed:
```bash
mkdir -p backend/src/services/corporate-tax
```
  </action>
  <verify>
Run `npx tsc --noEmit` to verify TypeScript compiles.
Verify the file exists and has correct exports.
  </verify>
  <done>
CtChartMappingService:
- updateAccountMapping() for single account CT classification
- applyDefaultMappings() with DEFAULT_CT_MAPPING_RULES
- getMappingSummary() for coverage reporting
- getNonDeductibleAccounts() for CT-02 expense aggregation
- getExemptIncomeAccounts() for CT-03 income aggregation
- validateMappings() for completeness check
- 15+ default mapping rules for common UAE account patterns
  </done>
</task>

<task type="auto">
  <name>Task 2: Create CT Chart Mapping Seed Script</name>
  <files>backend/prisma/seed/ct-chart-mappings.ts</files>
  <action>
Create a seed script for default CT chart mappings:

```typescript
import { PrismaClient, CtAccountCategory, CtExpenseClassification, CtIncomeClassification } from '@prisma/client';

/**
 * CT Chart Mappings Seed Script
 *
 * Seeds default CT classifications for common chart of accounts patterns.
 * Run after company setup to pre-populate CT mappings.
 *
 * Usage: npx ts-node prisma/seed/ct-chart-mappings.ts --companyId=<uuid>
 */

interface CtAccountTemplate {
  accountCodePattern: RegExp;
  accountNameKeywords: string[];
  ctCategory: CtAccountCategory;
  ctExpenseClass?: CtExpenseClassification;
  ctIncomeClass?: CtIncomeClassification;
  isQualifyingPBE?: boolean;
  description: string;
}

const CT_ACCOUNT_TEMPLATES: CtAccountTemplate[] = [
  // ==========================================================================
  // INCOME ACCOUNTS
  // ==========================================================================

  // Trading income - taxable
  {
    accountCodePattern: /^4[0-3]/,
    accountNameKeywords: ['sales', 'revenue', 'service income', 'trading income'],
    ctCategory: 'TRADING_INCOME',
    ctIncomeClass: 'TAXABLE',
    description: 'Main trading revenue - fully taxable'
  },

  // Interest income - taxable
  {
    accountCodePattern: /^4[4-5]/,
    accountNameKeywords: ['interest', 'finance income'],
    ctCategory: 'INVESTMENT_INCOME',
    ctIncomeClass: 'TAXABLE',
    description: 'Interest and finance income - taxable'
  },

  // Dividend income - potentially exempt
  {
    accountCodePattern: /^46/,
    accountNameKeywords: ['dividend'],
    ctCategory: 'DIVIDEND_INCOME',
    ctIncomeClass: 'EXEMPT_DIVIDEND',
    description: 'Dividend income - check participation exemption conditions'
  },

  // Capital gains - potentially exempt
  {
    accountCodePattern: /^47/,
    accountNameKeywords: ['gain', 'disposal', 'profit on sale'],
    ctCategory: 'CAPITAL_GAINS',
    ctIncomeClass: 'TAXABLE',
    description: 'Capital gains - check participation exemption for qualifying shares'
  },

  // Other income
  {
    accountCodePattern: /^4[8-9]/,
    accountNameKeywords: ['other income', 'miscellaneous'],
    ctCategory: 'OTHER_INCOME',
    ctIncomeClass: 'TAXABLE',
    description: 'Other income - taxable'
  },

  // ==========================================================================
  // EXPENSE ACCOUNTS - FULLY DEDUCTIBLE
  // ==========================================================================

  // Cost of sales
  {
    accountCodePattern: /^5/,
    accountNameKeywords: ['cost of sales', 'cost of goods', 'direct cost', 'purchases'],
    ctCategory: 'COST_OF_SALES',
    ctExpenseClass: 'FULLY_DEDUCTIBLE',
    description: 'Cost of goods sold - fully deductible'
  },

  // Staff costs
  {
    accountCodePattern: /^6[0-1]/,
    accountNameKeywords: ['salary', 'wages', 'employee', 'payroll', 'gratuity', 'bonus', 'staff'],
    ctCategory: 'STAFF_COSTS',
    ctExpenseClass: 'FULLY_DEDUCTIBLE',
    description: 'Staff costs - fully deductible'
  },

  // Administrative expenses
  {
    accountCodePattern: /^6[2-4]/,
    accountNameKeywords: ['rent', 'utilities', 'office', 'admin', 'telephone', 'insurance', 'professional fees'],
    ctCategory: 'ADMIN_EXPENSES',
    ctExpenseClass: 'FULLY_DEDUCTIBLE',
    description: 'Administrative expenses - fully deductible'
  },

  // Depreciation
  {
    accountCodePattern: /^66/,
    accountNameKeywords: ['depreciation', 'amortization'],
    ctCategory: 'DEPRECIATION',
    ctExpenseClass: 'FULLY_DEDUCTIBLE',
    description: 'Depreciation - follows accounting treatment'
  },

  // Finance costs
  {
    accountCodePattern: /^67/,
    accountNameKeywords: ['interest', 'finance cost', 'bank charge', 'loan fee'],
    ctCategory: 'FINANCE_COSTS',
    ctExpenseClass: 'FULLY_DEDUCTIBLE',
    description: 'Finance costs - deductible (subject to related party limitations)'
  },

  // ==========================================================================
  // EXPENSE ACCOUNTS - PARTIALLY DEDUCTIBLE (50%)
  // ==========================================================================

  // Entertainment - 50% deductible per FTA Article 33(2)
  {
    accountCodePattern: /^65[0-5]/,
    accountNameKeywords: ['entertainment', 'hospitality', 'client meal', 'business meal', 'business lunch', 'business dinner'],
    ctCategory: 'ENTERTAINMENT',
    ctExpenseClass: 'ENTERTAINMENT_50_PCT',
    description: 'Entertainment - 50% deductible per FTA Article 33(2)'
  },

  // ==========================================================================
  // EXPENSE ACCOUNTS - NON-DEDUCTIBLE (0%)
  // ==========================================================================

  // Fines and penalties - 0% deductible
  {
    accountCodePattern: /^68[0-2]/,
    accountNameKeywords: ['fine', 'penalty', 'violation', 'late fee', 'government fee'],
    ctCategory: 'FINES_PENALTIES',
    ctExpenseClass: 'NON_DEDUCTIBLE',
    description: 'Fines and penalties - 0% deductible per FTA Article 33'
  },

  // Donations - depends on QPBE status
  {
    accountCodePattern: /^68[3-5]/,
    accountNameKeywords: ['donation', 'charity', 'charitable', 'contribution'],
    ctCategory: 'DONATIONS',
    ctExpenseClass: 'NON_DEDUCTIBLE',
    isQualifyingPBE: false,
    description: 'Donations to non-QPBE - 0% deductible'
  },

  // Owner withdrawals
  {
    accountCodePattern: /^88/,
    accountNameKeywords: ['drawing', 'withdrawal', 'owner'],
    ctCategory: 'NOT_APPLICABLE',
    ctExpenseClass: 'OWNER_WITHDRAWAL',
    description: 'Owner withdrawals - not deductible'
  },

  // ==========================================================================
  // RELATED PARTY ACCOUNTS
  // ==========================================================================

  // Related party expenses
  {
    accountCodePattern: /^69/,
    accountNameKeywords: ['intercompany', 'related party', 'management fee', 'group charge', 'affiliate'],
    ctCategory: 'RELATED_PARTY_EXPENSE',
    ctExpenseClass: 'RELATED_PARTY',
    description: 'Related party expenses - subject to arm\'s length test'
  },

  // ==========================================================================
  // BALANCE SHEET ACCOUNTS (for CT reporting)
  // ==========================================================================

  // Fixed assets
  {
    accountCodePattern: /^1[0-4]/,
    accountNameKeywords: ['property', 'plant', 'equipment', 'vehicle', 'furniture', 'building'],
    ctCategory: 'FIXED_ASSETS',
    description: 'Property, plant and equipment'
  },

  // Investments
  {
    accountCodePattern: /^1[5-7]/,
    accountNameKeywords: ['investment', 'subsidiary', 'associate', 'shares'],
    ctCategory: 'INVESTMENTS',
    description: 'Investment holdings - track for participation exemption'
  },

  // Related party receivables
  {
    accountCodePattern: /^18/,
    accountNameKeywords: ['due from', 'intercompany receivable', 'related party receivable', 'loan to'],
    ctCategory: 'RELATED_PARTY_RECEIVABLES',
    description: 'Amounts due from related parties'
  },

  // Related party payables
  {
    accountCodePattern: /^28/,
    accountNameKeywords: ['due to', 'intercompany payable', 'related party payable', 'loan from'],
    ctCategory: 'RELATED_PARTY_PAYABLES',
    description: 'Amounts due to related parties'
  }
];

/**
 * Seeds CT mappings for a company's chart of accounts
 */
export async function seedCtChartMappings(
  prisma: PrismaClient,
  companyId: string
): Promise<{ updated: number; skipped: number }> {
  const accounts = await prisma.chart_of_accounts.findMany({
    where: {
      companyId,
      ctCategory: null // Only update unmapped accounts
    },
    select: {
      id: true,
      accountCode: true,
      accountName: true
    }
  });

  let updated = 0;
  let skipped = 0;

  for (const account of accounts) {
    const template = findMatchingTemplate(account.accountCode, account.accountName);

    if (template) {
      await prisma.chart_of_accounts.update({
        where: { id: account.id },
        data: {
          ctCategory: template.ctCategory,
          ctExpenseClass: template.ctExpenseClass,
          ctIncomeClass: template.ctIncomeClass,
          isQualifyingPBE: template.isQualifyingPBE ?? false
        }
      });
      updated++;
    } else {
      skipped++;
    }
  }

  console.log(`CT Chart Mappings: Updated ${updated}, Skipped ${skipped}`);
  return { updated, skipped };
}

/**
 * Finds matching CT template for an account
 */
function findMatchingTemplate(
  accountCode: string,
  accountName: string
): CtAccountTemplate | null {
  const normalizedName = accountName.toLowerCase();

  // Sort templates by specificity (name match is more specific than code-only match)
  for (const template of CT_ACCOUNT_TEMPLATES) {
    const codeMatches = template.accountCodePattern.test(accountCode);
    const nameMatches = template.accountNameKeywords.some(keyword =>
      normalizedName.includes(keyword.toLowerCase())
    );

    if (codeMatches && nameMatches) {
      return template;
    }
  }

  // Second pass: code-only matches
  for (const template of CT_ACCOUNT_TEMPLATES) {
    if (template.accountCodePattern.test(accountCode)) {
      return template;
    }
  }

  return null;
}

// CLI runner
if (require.main === module) {
  const companyId = process.argv.find(arg => arg.startsWith('--companyId='))?.split('=')[1];

  if (!companyId) {
    console.error('Usage: npx ts-node prisma/seed/ct-chart-mappings.ts --companyId=<uuid>');
    process.exit(1);
  }

  const prisma = new PrismaClient();

  seedCtChartMappings(prisma, companyId)
    .then(result => {
      console.log('CT Chart Mappings seeded successfully:', result);
      process.exit(0);
    })
    .catch(error => {
      console.error('Error seeding CT mappings:', error);
      process.exit(1);
    })
    .finally(() => {
      prisma.$disconnect();
    });
}
```

Create the directory if needed:
```bash
mkdir -p backend/prisma/seed
```
  </action>
  <verify>
Run `npx tsc --noEmit backend/prisma/seed/ct-chart-mappings.ts` to verify TypeScript compiles.
  </verify>
  <done>
CT chart mapping seed script:
- CT_ACCOUNT_TEMPLATES with 20+ templates
- seedCtChartMappings() function for bulk seeding
- Covers income, expense, and balance sheet accounts
- Entertainment flagged as ENTERTAINMENT_50_PCT
- Fines/Penalties flagged as NON_DEDUCTIBLE
- Related party accounts flagged for arm's length test
- CLI runner for direct execution
  </done>
</task>

<task type="auto">
  <name>Task 3: Register CtChartMappingService in DI Container</name>
  <files>backend/src/di/container.ts, backend/src/di/types.ts, backend/src/services/corporate-tax/index.ts</files>
  <action>
Add CtChartMappingService to the dependency injection container.

In `backend/src/di/types.ts`, add:
```typescript
// Corporate Tax Services
CtChartMappingService: Symbol.for('CtChartMappingService'),
```

In `backend/src/di/container.ts`, add import and binding:
```typescript
import { CtChartMappingService } from '../services/corporate-tax/ct-chart-mapping.service';

// In the container bindings section:
container.bind<CtChartMappingService>(TYPES.CtChartMappingService)
  .to(CtChartMappingService)
  .inSingletonScope();
```

Create an index file for corporate-tax services:
```typescript
// backend/src/services/corporate-tax/index.ts
export {
  CtChartMappingService,
  CtMappingInput,
  CtMappingRule,
  BulkMappingResult,
  CtMappingSummary,
  DEFAULT_CT_MAPPING_RULES
} from './ct-chart-mapping.service';
```
  </action>
  <verify>
Run `npx tsc --noEmit` to verify container compiles.
  </verify>
  <done>
DI container updated with:
- TYPES.CtChartMappingService symbol
- CtChartMappingService bound as singleton
- Index file exports all CT chart mapping types
  </done>
</task>

</tasks>

<verification>
1. Run `npx tsc --noEmit` - all files should compile
2. Verify CtChartMappingService has updateAccountMapping and applyDefaultMappings methods
3. Verify DEFAULT_CT_MAPPING_RULES includes ENTERTAINMENT_50_PCT rule
4. Verify DEFAULT_CT_MAPPING_RULES includes NON_DEDUCTIBLE rule for fines
5. Check DI container bindings resolve without error
</verification>

<success_criteria>
- CtChartMappingService can map accounts to CT categories
- Default rules auto-classify entertainment as 50% deductible
- Default rules auto-classify fines/penalties as 0% deductible
- Dividend accounts flagged for participation exemption check
- Related party accounts flagged for arm's length test
- Seed script can bulk-apply mappings to company chart of accounts
- Service registered in DI container
</success_criteria>

<output>
After completion, create `.planning/phases/04-corporate-tax-compliance/04-02-SUMMARY.md`
</output>
