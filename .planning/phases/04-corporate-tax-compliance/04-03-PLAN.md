---
phase: 04-corporate-tax-compliance
plan: 03
type: execute
wave: 2
depends_on: ["04-01", "04-02"]
files_modified:
  - backend/src/services/corporate-tax/ct-adjustment.service.ts
  - backend/src/di/container.ts
autonomous: true

must_haves:
  truths:
    - "Non-deductible expenses are aggregated from journal entries by CT classification"
    - "Entertainment expenses show full amount and 50% disallowed portion"
    - "Exempt income is aggregated with participation exemption verification"
    - "Dividends qualify for exemption based on 5%/12-month/9% rules"
    - "Related party adjustments identified for arm's length failures"
  artifacts:
    - path: "backend/src/services/corporate-tax/ct-adjustment.service.ts"
      provides: "Service for aggregating CT adjustments (non-deductible, exempt income)"
      exports: ["CtAdjustmentService"]
      min_lines: 350
  key_links:
    - from: "ct-adjustment.service.ts"
      to: "ct-chart-mapping.service.ts"
      via: "Get accounts by expense/income classification"
      pattern: "CtChartMappingService"
    - from: "ct-adjustment.service.ts"
      to: "accounting_journal_lines"
      via: "Aggregate transactions by classified accounts"
      pattern: "prisma.accountingJournalLine"
---

<objective>
Create the CT Adjustment Service that aggregates non-deductible expenses (CT-02) and exempt income (CT-03) from accounting data.

Purpose: UAE CT requires adjusting accounting income by adding back non-deductible expenses (fines, 50% of entertainment) and subtracting exempt income (qualifying dividends, capital gains). This service aggregates these adjustments from journal entries using the CT chart mappings from 04-02.

Output:
- CtAdjustmentService for aggregating CT adjustments
- Non-deductible expense calculation with breakdowns
- Exempt income aggregation with participation exemption checks
- Related party adjustment identification
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-corporate-tax-compliance/04-RESEARCH.md
@.planning/phases/04-corporate-tax-compliance/04-01-SUMMARY.md
@.planning/phases/04-corporate-tax-compliance/04-02-SUMMARY.md

# Dependencies
@backend/src/types/corporate-tax.types.ts
@backend/src/services/corporate-tax/ct-chart-mapping.service.ts
@backend/src/utils/decimal-math.util.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CT Adjustment Service</name>
  <files>backend/src/services/corporate-tax/ct-adjustment.service.ts</files>
  <action>
Create the CT adjustment aggregation service:

```typescript
import { PrismaClient, CtExpenseClassification, CtIncomeClassification } from '@prisma/client';
import { Decimal } from '@prisma/client/runtime/library';
import { injectable, inject } from 'inversify';
import { TYPES } from '../../di/types';
import { roundCurrency, toDecimal, ZERO } from '../../utils/decimal-math.util';
import {
  NonDeductibleSummary,
  NonDeductibleDetail,
  ExemptIncomeSummary,
  DividendExemptionDetail,
  CapitalGainExemptionDetail,
  ParticipationDetail,
  OtherAdjustmentsSummary,
  CT_CONSTANTS
} from '../../types/corporate-tax.types';
import { CtChartMappingService } from './ct-chart-mapping.service';
import logger from '../logger.service';

/**
 * CT Adjustment Service
 *
 * Aggregates Corporate Tax adjustments from accounting data:
 * - Non-deductible expenses (add back to accounting income)
 * - Exempt income (subtract from accounting income)
 * - Other adjustments (related party, transitional)
 *
 * Requirements: CT-02 (non-deductible), CT-03 (exempt income)
 *
 * Formula: Taxable Income = Accounting Income - Exempt Income + Non-Deductible + Other
 */

// ============================================================================
// Input/Output Types
// ============================================================================

export interface AdjustmentPeriodInput {
  companyId: string;
  startDate: Date;
  endDate: Date;
}

export interface CtAdjustmentResult {
  nonDeductible: NonDeductibleSummary;
  exemptIncome: ExemptIncomeSummary;
  otherAdjustments: OtherAdjustmentsSummary;

  // Net adjustment to accounting income
  netAdjustment: Decimal;

  // Breakdown details for audit
  nonDeductibleDetails: NonDeductibleDetail[];
  exemptIncomeDetails: ParticipationDetail[];
}

// ============================================================================
// Service
// ============================================================================

@injectable()
export class CtAdjustmentService {
  constructor(
    @inject(TYPES.PrismaClient)
    private readonly prisma: PrismaClient,
    @inject(TYPES.CtChartMappingService)
    private readonly chartMappingService: CtChartMappingService
  ) {}

  /**
   * Aggregates all CT adjustments for a period
   */
  async aggregateAdjustments(input: AdjustmentPeriodInput): Promise<CtAdjustmentResult> {
    // Aggregate non-deductible expenses (CT-02)
    const nonDeductible = await this.aggregateNonDeductibleExpenses(input);

    // Aggregate exempt income (CT-03)
    const exemptIncome = await this.aggregateExemptIncome(input);

    // Aggregate other adjustments
    const otherAdjustments = await this.aggregateOtherAdjustments(input);

    // Calculate net adjustment
    // + Non-deductible (add back)
    // - Exempt income (subtract)
    // +/- Other adjustments
    const netAdjustment = roundCurrency(
      nonDeductible.summary.total
        .minus(exemptIncome.summary.total)
        .plus(otherAdjustments.total)
    );

    return {
      nonDeductible: nonDeductible.summary,
      exemptIncome: exemptIncome.summary,
      otherAdjustments,
      netAdjustment,
      nonDeductibleDetails: nonDeductible.details,
      exemptIncomeDetails: exemptIncome.details
    };
  }

  // ==========================================================================
  // NON-DEDUCTIBLE EXPENSES (CT-02)
  // ==========================================================================

  /**
   * Aggregates non-deductible expenses by classification
   */
  async aggregateNonDeductibleExpenses(
    input: AdjustmentPeriodInput
  ): Promise<{
    summary: NonDeductibleSummary;
    details: NonDeductibleDetail[];
  }> {
    // Get accounts classified as non-deductible
    const nonDeductibleAccounts = await this.chartMappingService.getNonDeductibleAccounts(
      input.companyId
    );

    const accountIds = nonDeductibleAccounts.map(a => a.id);

    // Get journal entries for these accounts
    const journalLines = await this.prisma.accountingJournalLine.findMany({
      where: {
        journalEntry: {
          companyId: input.companyId,
          entryDate: { gte: input.startDate, lte: input.endDate },
          status: 'POSTED'
        },
        accountId: { in: accountIds },
        debitAmount: { gt: 0 } // Expenses are debits
      },
      include: {
        account: {
          select: {
            id: true,
            accountCode: true,
            accountName: true,
            ctExpenseClass: true,
            ctCategory: true
          }
        }
      }
    });

    // Aggregate by account
    const accountTotals = new Map<string, {
      account: typeof journalLines[0]['account'];
      totalExpense: Decimal;
    }>();

    for (const line of journalLines) {
      const existing = accountTotals.get(line.accountId);
      const amount = toDecimal(line.debitAmount);

      if (existing) {
        existing.totalExpense = existing.totalExpense.plus(amount);
      } else {
        accountTotals.set(line.accountId, {
          account: line.account,
          totalExpense: amount
        });
      }
    }

    // Calculate non-deductible portions
    let finesAndPenalties = ZERO;
    let entertainmentDisallowed = ZERO;
    let donationsDisallowed = ZERO;
    let ownerWithdrawals = ZERO;
    let personalExpenses = ZERO;
    let relatedPartyExcess = ZERO;
    let recoverableInputVat = ZERO;
    let illicitPayments = ZERO;

    const details: NonDeductibleDetail[] = [];

    for (const [accountId, data] of accountTotals) {
      const classification = data.account.ctExpenseClass as CtExpenseClassification;
      const totalExpense = data.totalExpense;
      let deductiblePortion = totalExpense;
      let nonDeductiblePortion = ZERO;
      let reason = '';

      switch (classification) {
        case 'NON_DEDUCTIBLE':
          // 0% deductible
          nonDeductiblePortion = totalExpense;
          deductiblePortion = ZERO;

          if (data.account.ctCategory === 'FINES_PENALTIES') {
            finesAndPenalties = finesAndPenalties.plus(nonDeductiblePortion);
            reason = 'Fines and penalties - 0% deductible per FTA Article 33';
          } else {
            illicitPayments = illicitPayments.plus(nonDeductiblePortion);
            reason = 'Non-deductible expense per FTA Article 33';
          }
          break;

        case 'ENTERTAINMENT_50_PCT':
          // 50% deductible - add back the disallowed 50%
          nonDeductiblePortion = roundCurrency(totalExpense.times(new Decimal('0.5')));
          deductiblePortion = totalExpense.minus(nonDeductiblePortion);
          entertainmentDisallowed = entertainmentDisallowed.plus(nonDeductiblePortion);
          reason = 'Entertainment - 50% deductible per FTA Article 33(2)';
          break;

        case 'OWNER_WITHDRAWAL':
          // 0% deductible
          nonDeductiblePortion = totalExpense;
          deductiblePortion = ZERO;
          ownerWithdrawals = ownerWithdrawals.plus(nonDeductiblePortion);
          reason = 'Owner withdrawal - not deductible';
          break;

        case 'PERSONAL_EXPENSE':
          // 0% deductible
          nonDeductiblePortion = totalExpense;
          deductiblePortion = ZERO;
          personalExpenses = personalExpenses.plus(nonDeductiblePortion);
          reason = 'Personal expense - not deductible';
          break;

        case 'RELATED_PARTY':
          // Deductible subject to arm's length test
          // Related party excess is calculated separately via transfer pricing service
          // For now, assume fully deductible; adjustments come from TP service
          deductiblePortion = totalExpense;
          nonDeductiblePortion = ZERO;
          reason = 'Related party expense - subject to arm\'s length test';
          break;

        default:
          // Fully deductible (should not be in this list but handle gracefully)
          deductiblePortion = totalExpense;
          nonDeductiblePortion = ZERO;
          reason = 'Fully deductible';
      }

      if (nonDeductiblePortion.greaterThan(ZERO)) {
        details.push({
          accountId,
          accountName: data.account.accountName,
          totalExpense: roundCurrency(totalExpense),
          deductiblePortion: roundCurrency(deductiblePortion),
          nonDeductiblePortion: roundCurrency(nonDeductiblePortion),
          classification,
          reason
        });
      }
    }

    // Calculate related party excess from transfer pricing
    relatedPartyExcess = await this.calculateRelatedPartyExcess(input);

    const total = roundCurrency(
      finesAndPenalties
        .plus(entertainmentDisallowed)
        .plus(donationsDisallowed)
        .plus(ownerWithdrawals)
        .plus(personalExpenses)
        .plus(relatedPartyExcess)
        .plus(recoverableInputVat)
        .plus(illicitPayments)
    );

    return {
      summary: {
        finesAndPenalties: roundCurrency(finesAndPenalties),
        entertainmentDisallowed: roundCurrency(entertainmentDisallowed),
        donationsDisallowed: roundCurrency(donationsDisallowed),
        ownerWithdrawals: roundCurrency(ownerWithdrawals),
        personalExpenses: roundCurrency(personalExpenses),
        relatedPartyExcess: roundCurrency(relatedPartyExcess),
        recoverableInputVat: roundCurrency(recoverableInputVat),
        illicitPayments: roundCurrency(illicitPayments),
        total
      },
      details
    };
  }

  /**
   * Calculates related party excess from arm's length adjustments
   */
  private async calculateRelatedPartyExcess(
    input: AdjustmentPeriodInput
  ): Promise<Decimal> {
    // Sum adjustments from related party transactions where adjustment was required
    const adjustments = await this.prisma.relatedPartyTransaction.aggregate({
      where: {
        companyId: input.companyId,
        transactionDate: { gte: input.startDate, lte: input.endDate },
        adjustmentRequired: true
      },
      _sum: { adjustmentAmount: true }
    });

    return toDecimal(adjustments._sum.adjustmentAmount);
  }

  // ==========================================================================
  // EXEMPT INCOME (CT-03)
  // ==========================================================================

  /**
   * Aggregates exempt income with participation exemption checks
   */
  async aggregateExemptIncome(
    input: AdjustmentPeriodInput
  ): Promise<{
    summary: ExemptIncomeSummary;
    details: ParticipationDetail[];
  }> {
    // Get accounts classified as exempt income
    const exemptAccounts = await this.chartMappingService.getExemptIncomeAccounts(
      input.companyId
    );

    const accountIds = exemptAccounts.map(a => a.id);

    // Get journal entries for these accounts
    const journalLines = await this.prisma.accountingJournalLine.findMany({
      where: {
        journalEntry: {
          companyId: input.companyId,
          entryDate: { gte: input.startDate, lte: input.endDate },
          status: 'POSTED'
        },
        accountId: { in: accountIds },
        creditAmount: { gt: 0 } // Income is credits
      },
      include: {
        account: {
          select: {
            id: true,
            accountCode: true,
            accountName: true,
            ctIncomeClass: true,
            ctCategory: true
          }
        }
      }
    });

    // Aggregate by account and classification
    let domesticDividends = ZERO;
    let foreignDividends = ZERO;
    let qualifyingGains = ZERO;
    let nonQualifyingGains = ZERO;
    let foreignPeIncome = ZERO;
    let intraGroupReorganization = ZERO;

    const details: ParticipationDetail[] = [];

    for (const line of journalLines) {
      const amount = toDecimal(line.creditAmount);
      const classification = line.account.ctIncomeClass as CtIncomeClassification;

      switch (classification) {
        case 'EXEMPT_DIVIDEND':
          // Check participation exemption conditions
          const dividendDetail = await this.checkDividendExemption(
            input.companyId,
            line.accountId,
            amount,
            input.endDate
          );

          if (dividendDetail.qualifiesForExemption) {
            if (dividendDetail.entityName?.includes('UAE') || !dividendDetail.foreignTaxRate) {
              domesticDividends = domesticDividends.plus(amount);
            } else {
              foreignDividends = foreignDividends.plus(amount);
            }
          }
          details.push(dividendDetail);
          break;

        case 'EXEMPT_CAPITAL_GAIN':
          // Check participation exemption for capital gains
          const gainDetail = await this.checkCapitalGainExemption(
            input.companyId,
            line.accountId,
            amount,
            input.endDate
          );

          if (gainDetail.qualifiesForExemption) {
            qualifyingGains = qualifyingGains.plus(amount);
          } else {
            nonQualifyingGains = nonQualifyingGains.plus(amount);
          }
          details.push(gainDetail);
          break;

        case 'EXEMPT_FOREIGN_PE':
          foreignPeIncome = foreignPeIncome.plus(amount);
          details.push({
            investmentId: line.accountId,
            entityName: line.account.accountName,
            ownershipPercent: new Decimal('100'),
            acquisitionDate: new Date(),
            acquisitionCost: ZERO,
            qualifiesForExemption: true,
            exemptionReason: 'Foreign PE income election',
            amount
          });
          break;

        case 'QUALIFYING_INCOME':
          // QFZP qualifying income - exempt at 0%
          details.push({
            investmentId: line.accountId,
            entityName: line.account.accountName,
            ownershipPercent: new Decimal('100'),
            acquisitionDate: new Date(),
            acquisitionCost: ZERO,
            qualifiesForExemption: true,
            exemptionReason: 'QFZP qualifying income',
            amount
          });
          break;

        default:
          // Non-qualifying income - taxable
          break;
      }
    }

    const dividendTotal = roundCurrency(domesticDividends.plus(foreignDividends));
    const capitalGainTotal = roundCurrency(qualifyingGains);
    const total = roundCurrency(
      dividendTotal
        .plus(capitalGainTotal)
        .plus(foreignPeIncome)
        .plus(intraGroupReorganization)
    );

    return {
      summary: {
        dividends: {
          domesticDividends: roundCurrency(domesticDividends),
          foreignDividends: roundCurrency(foreignDividends),
          total: dividendTotal,
          details: details.filter(d => d.exemptionReason?.includes('dividend'))
        },
        capitalGains: {
          qualifyingGains: roundCurrency(qualifyingGains),
          nonQualifyingGains: roundCurrency(nonQualifyingGains),
          total: capitalGainTotal,
          details: details.filter(d => d.exemptionReason?.includes('capital gain'))
        },
        foreignPeIncome: roundCurrency(foreignPeIncome),
        intraGroupReorganization: roundCurrency(intraGroupReorganization),
        total
      },
      details
    };
  }

  /**
   * Checks if dividend qualifies for participation exemption
   *
   * Conditions (FTA Article 23):
   * 1. Ownership >= 5% (or acquisition cost > AED 4M)
   * 2. Holding period >= 12 months (or intention to hold)
   * 3. For foreign dividends: Subject to >= 9% tax rate
   * 4. Not more than 50% of participation's assets are non-qualifying
   */
  private async checkDividendExemption(
    companyId: string,
    accountId: string,
    amount: Decimal,
    asOfDate: Date
  ): Promise<ParticipationDetail> {
    // Look for investment record linked to this account
    // In a real implementation, this would query an investments table
    // For now, return a basic structure that can be enhanced

    const investment = await this.prisma.investment?.findFirst?.({
      where: {
        companyId,
        accountId
      }
    }).catch(() => null);

    if (!investment) {
      // No investment record found - assume domestic dividend exempt
      return {
        investmentId: accountId,
        entityName: 'Unknown entity',
        ownershipPercent: new Decimal('100'),
        acquisitionDate: new Date(),
        acquisitionCost: ZERO,
        qualifiesForExemption: true,
        exemptionReason: 'Domestic dividend - assumed qualifying',
        amount
      };
    }

    // Check ownership condition
    const ownershipPercent = toDecimal(investment.ownershipPercent);
    const acquisitionCost = toDecimal(investment.acquisitionCost);
    const meetsOwnershipTest = ownershipPercent.greaterThanOrEqualTo(CT_CONSTANTS.PARTICIPATION_OWNERSHIP_MIN)
      || acquisitionCost.greaterThan(CT_CONSTANTS.PARTICIPATION_COST_THRESHOLD);

    // Check holding period
    const acquisitionDate = investment.acquisitionDate;
    const holdingMonths = this.calculateHoldingMonths(acquisitionDate, asOfDate);
    const meetsHoldingTest = holdingMonths >= CT_CONSTANTS.PARTICIPATION_HOLDING_MONTHS;

    // Check foreign tax rate (for foreign dividends)
    const foreignTaxRate = investment.foreignTaxRate ? toDecimal(investment.foreignTaxRate) : null;
    const meetsTaxRateTest = !foreignTaxRate
      || foreignTaxRate.greaterThanOrEqualTo(CT_CONSTANTS.PARTICIPATION_TAX_RATE_MIN);

    const qualifies = meetsOwnershipTest && meetsHoldingTest && meetsTaxRateTest;

    let exemptionReason: string | undefined;
    if (!qualifies) {
      if (!meetsOwnershipTest) {
        exemptionReason = 'Ownership below 5% and cost below AED 4M';
      } else if (!meetsHoldingTest) {
        exemptionReason = `Holding period ${holdingMonths} months (needs 12)`;
      } else if (!meetsTaxRateTest) {
        exemptionReason = `Foreign tax rate ${foreignTaxRate}% (needs 9%)`;
      }
    } else {
      exemptionReason = 'Participation exemption - qualifying dividend';
    }

    return {
      investmentId: investment.id,
      entityName: investment.entityName || 'Unknown',
      ownershipPercent,
      acquisitionDate,
      acquisitionCost,
      foreignTaxRate: foreignTaxRate || undefined,
      qualifiesForExemption: qualifies,
      exemptionReason,
      amount
    };
  }

  /**
   * Checks if capital gain qualifies for participation exemption
   */
  private async checkCapitalGainExemption(
    companyId: string,
    accountId: string,
    amount: Decimal,
    asOfDate: Date
  ): Promise<ParticipationDetail> {
    // Similar to dividend exemption check
    // Capital gains on qualifying participations are exempt
    return {
      investmentId: accountId,
      entityName: 'Unknown entity',
      ownershipPercent: new Decimal('100'),
      acquisitionDate: new Date(),
      acquisitionCost: ZERO,
      qualifiesForExemption: false,
      exemptionReason: 'Capital gain - requires participation verification',
      amount
    };
  }

  /**
   * Calculates holding period in months
   */
  private calculateHoldingMonths(acquisitionDate: Date, asOfDate: Date): number {
    const years = asOfDate.getFullYear() - acquisitionDate.getFullYear();
    const months = asOfDate.getMonth() - acquisitionDate.getMonth();
    return years * 12 + months;
  }

  // ==========================================================================
  // OTHER ADJUSTMENTS
  // ==========================================================================

  /**
   * Aggregates other CT adjustments
   */
  async aggregateOtherAdjustments(
    input: AdjustmentPeriodInput
  ): Promise<OtherAdjustmentsSummary> {
    // Unrealized gains/losses adjustment (if realisation basis elected)
    const unrealizedGainsLosses = ZERO; // Requires election tracking

    // Transitional adjustments (for pre-CT assets)
    const transitionalAdjustments = ZERO; // Requires opening balance tracking

    // Interest limitation (not currently implemented in UAE CT)
    const interestLimitation = ZERO;

    return {
      unrealizedGainsLosses,
      transitionalAdjustments,
      interestLimitation,
      total: roundCurrency(
        unrealizedGainsLosses
          .plus(transitionalAdjustments)
          .plus(interestLimitation)
      )
    };
  }

  // ==========================================================================
  // DONATION DEDUCTIBILITY CHECK
  // ==========================================================================

  /**
   * Checks if donation is to a Qualifying Public Benefit Entity
   */
  async checkDonationDeductibility(
    companyId: string,
    accountId: string,
    amount: Decimal
  ): Promise<{
    deductible: boolean;
    isQpbe: boolean;
    reason: string;
  }> {
    const account = await this.prisma.chart_of_accounts.findUnique({
      where: { id: accountId },
      select: { isQualifyingPBE: true, accountName: true }
    });

    if (!account) {
      return {
        deductible: false,
        isQpbe: false,
        reason: 'Account not found'
      };
    }

    if (account.isQualifyingPBE) {
      return {
        deductible: true,
        isQpbe: true,
        reason: 'Donation to Qualifying Public Benefit Entity'
      };
    }

    return {
      deductible: false,
      isQpbe: false,
      reason: 'Donation to non-QPBE - not deductible'
    };
  }
}
```
  </action>
  <verify>
Run `npx tsc --noEmit` to verify TypeScript compiles.
Verify the service has aggregateAdjustments, aggregateNonDeductibleExpenses, and aggregateExemptIncome methods.
  </verify>
  <done>
CtAdjustmentService:
- aggregateAdjustments() for full CT adjustment calculation
- aggregateNonDeductibleExpenses() with breakdown by type
- Entertainment 50% disallowed calculation
- Fines/penalties 100% non-deductible
- aggregateExemptIncome() with participation exemption checks
- checkDividendExemption() verifying 5%/12-month/9% rules
- calculateRelatedPartyExcess() from TP adjustments
- checkDonationDeductibility() for QPBE status
  </done>
</task>

<task type="auto">
  <name>Task 2: Register CtAdjustmentService in DI Container</name>
  <files>backend/src/di/container.ts, backend/src/di/types.ts, backend/src/services/corporate-tax/index.ts</files>
  <action>
Add CtAdjustmentService to the dependency injection container.

In `backend/src/di/types.ts`, add:
```typescript
CtAdjustmentService: Symbol.for('CtAdjustmentService'),
```

In `backend/src/di/container.ts`, add import and binding:
```typescript
import { CtAdjustmentService } from '../services/corporate-tax/ct-adjustment.service';

container.bind<CtAdjustmentService>(TYPES.CtAdjustmentService)
  .to(CtAdjustmentService)
  .inSingletonScope();
```

Update `backend/src/services/corporate-tax/index.ts`:
```typescript
export {
  CtChartMappingService,
  CtMappingInput,
  CtMappingRule,
  BulkMappingResult,
  CtMappingSummary,
  DEFAULT_CT_MAPPING_RULES
} from './ct-chart-mapping.service';

export {
  CtAdjustmentService,
  AdjustmentPeriodInput,
  CtAdjustmentResult
} from './ct-adjustment.service';
```
  </action>
  <verify>
Run `npx tsc --noEmit` to verify container compiles.
  </verify>
  <done>
DI container updated with:
- TYPES.CtAdjustmentService symbol
- CtAdjustmentService bound as singleton
- Index file exports CtAdjustmentService and related types
  </done>
</task>

</tasks>

<verification>
1. Run `npx tsc --noEmit` - all files should compile
2. Verify CtAdjustmentService aggregates entertainment as 50% non-deductible
3. Verify CtAdjustmentService aggregates fines as 100% non-deductible
4. Verify participation exemption checks ownership, holding period, and tax rate
5. Verify service queries journal lines by CT-classified accounts
</verification>

<success_criteria>
- Non-deductible expenses aggregated from journal entries
- Entertainment shows full amount and 50% disallowed portion (CT-02)
- Fines/penalties show 100% non-deductible (CT-02)
- Exempt income aggregated with participation exemption verification (CT-03)
- Dividends check 5%/12-month/9% rules for exemption
- Related party excess calculated from TP adjustments
- Service registered in DI container
</success_criteria>

<output>
After completion, create `.planning/phases/04-corporate-tax-compliance/04-03-SUMMARY.md`
</output>
