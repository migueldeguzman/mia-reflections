---
phase: 04-corporate-tax-compliance
plan: 05
type: execute
wave: 3
depends_on: ["04-03", "04-04"]
files_modified:
  - backend/src/services/corporate-tax/ct-report.service.ts
  - backend/src/di/container.ts
autonomous: true

must_haves:
  truths:
    - "CT-adjusted P&L shows accounting amounts and CT adjustment columns"
    - "Non-deductible expenses shown as additions to accounting income"
    - "Exempt income shown as deductions from accounting income"
    - "CT-adjusted Balance Sheet shows deferred tax and CT payable"
    - "Reports can be generated for any fiscal period"
  artifacts:
    - path: "backend/src/services/corporate-tax/ct-report.service.ts"
      provides: "CT-adjusted P&L and Balance Sheet generation (CT-05, CT-06)"
      exports: ["CtReportService"]
      min_lines: 300
  key_links:
    - from: "ct-report.service.ts"
      to: "financial-reports.service.ts"
      via: "Get standard P&L and Balance Sheet"
      pattern: "FinancialReportsService"
    - from: "ct-report.service.ts"
      to: "ct-adjustment.service.ts"
      via: "Get CT adjustment details"
      pattern: "CtAdjustmentService"
    - from: "ct-report.service.ts"
      to: "ct-calculation.service.ts"
      via: "Get CT calculation result"
      pattern: "CtCalculationService"
---

<objective>
Create the CT Report Service that generates CT-adjusted Profit & Loss and Balance Sheet statements.

Purpose: CT-05 and CT-06 require generating financial statements that show the CT adjustments applied to accounting figures. This enables users to see exactly how accounting income transforms into taxable income, with clear columns for non-deductible additions and exempt income deductions.

Output:
- CtReportService for CT-adjusted financial statements
- CT-adjusted P&L with adjustment columns
- CT-adjusted Balance Sheet with deferred tax
- Report data for PDF/Excel generation
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-corporate-tax-compliance/04-RESEARCH.md
@.planning/phases/04-corporate-tax-compliance/04-03-SUMMARY.md
@.planning/phases/04-corporate-tax-compliance/04-04-SUMMARY.md

# Dependencies
@backend/src/types/corporate-tax.types.ts
@backend/src/services/corporate-tax/ct-adjustment.service.ts
@backend/src/services/corporate-tax/ct-calculation.service.ts
@backend/src/services/finance/financial-reports.service.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CT Report Service</name>
  <files>backend/src/services/corporate-tax/ct-report.service.ts</files>
  <action>
Create the CT-adjusted financial statements service:

```typescript
import { PrismaClient, CtAccountCategory, CtExpenseClassification, CtIncomeClassification } from '@prisma/client';
import { Decimal } from '@prisma/client/runtime/library';
import { injectable, inject } from 'inversify';
import { TYPES } from '../../di/types';
import { roundCurrency, toDecimal, ZERO } from '../../utils/decimal-math.util';
import {
  CtAdjustedProfitAndLoss,
  CtAdjustedBalanceSheet,
  CtAdjustedSection,
  CtAdjustedAccountLine,
  CtAdjustedLine,
  CtCalculationResult,
  NonDeductibleDetail
} from '../../types/corporate-tax.types';
import { CtAdjustmentService } from './ct-adjustment.service';
import { CtCalculationService } from './ct-calculation.service';
import logger from '../logger.service';

/**
 * CT Report Service
 *
 * Generates CT-adjusted financial statements showing:
 * - Standard accounting amounts
 * - CT adjustments (additions for non-deductible, deductions for exempt)
 * - Taxable amounts
 *
 * Requirements: CT-05 (CT-adjusted P&L), CT-06 (CT-adjusted Balance Sheet)
 */

// ============================================================================
// Input Types
// ============================================================================

export interface CtReportInput {
  companyId: string;
  fiscalYearId: string;
  startDate: Date;
  endDate: Date;
}

export interface CtReportSummary {
  accountingIncome: Decimal;
  exemptIncomeDeductions: Decimal;
  nonDeductibleAdditions: Decimal;
  otherAdjustments: Decimal;
  taxableIncome: Decimal;
  ctPayable: Decimal;
}

// ============================================================================
// Service
// ============================================================================

@injectable()
export class CtReportService {
  constructor(
    @inject(TYPES.PrismaClient)
    private readonly prisma: PrismaClient,
    @inject(TYPES.CtAdjustmentService)
    private readonly adjustmentService: CtAdjustmentService,
    @inject(TYPES.CtCalculationService)
    private readonly calculationService: CtCalculationService,
    @inject(TYPES.FinancialReportsService)
    private readonly financialReportsService: any
  ) {}

  /**
   * Generates CT-adjusted Profit & Loss statement
   *
   * Columns:
   * 1. Account Name
   * 2. Accounting Amount (per IFRS)
   * 3. CT Adjustment (+/-)
   * 4. Taxable Amount
   */
  async generateCtAdjustedPnL(input: CtReportInput): Promise<CtAdjustedProfitAndLoss> {
    logger.info('Generating CT-adjusted P&L', { companyId: input.companyId });

    // Get CT calculation result
    const ctResult = await this.calculationService.calculateCorporateTax({
      companyId: input.companyId,
      fiscalYearId: input.fiscalYearId,
      startDate: input.startDate,
      endDate: input.endDate
    });

    // Get adjustment details for line-item breakdown
    const adjustments = await this.adjustmentService.aggregateAdjustments({
      companyId: input.companyId,
      startDate: input.startDate,
      endDate: input.endDate
    });

    // Get account balances with CT classifications
    const accounts = await this.getAccountBalancesWithCtClassification(
      input.companyId,
      input.startDate,
      input.endDate
    );

    // Build P&L sections
    const revenue = this.buildSection(
      accounts.filter(a => a.ctCategory?.startsWith('TRADING') || a.ctCategory?.includes('INCOME')),
      adjustments.nonDeductibleDetails,
      'INCOME'
    );

    const costOfSales = this.buildSection(
      accounts.filter(a => a.ctCategory === 'COST_OF_SALES'),
      adjustments.nonDeductibleDetails,
      'EXPENSE'
    );

    const operatingExpenses = this.buildSection(
      accounts.filter(a =>
        a.accountType === 'EXPENSE' &&
        a.ctCategory !== 'COST_OF_SALES' &&
        a.ctCategory !== 'FINANCE_COSTS'
      ),
      adjustments.nonDeductibleDetails,
      'EXPENSE'
    );

    const otherIncome = this.buildSection(
      accounts.filter(a =>
        a.ctCategory === 'DIVIDEND_INCOME' ||
        a.ctCategory === 'CAPITAL_GAINS' ||
        a.ctCategory === 'OTHER_INCOME'
      ),
      adjustments.nonDeductibleDetails,
      'INCOME'
    );

    const otherExpenses = this.buildSection(
      accounts.filter(a =>
        a.ctCategory === 'FINES_PENALTIES' ||
        a.ctCategory === 'FINANCE_COSTS'
      ),
      adjustments.nonDeductibleDetails,
      'EXPENSE'
    );

    // Calculate line totals
    const grossProfit = this.calculateLine(
      revenue.total.accountingAmount.minus(costOfSales.total.accountingAmount),
      revenue.total.adjustment.minus(costOfSales.total.adjustment)
    );

    const operatingProfit = this.calculateLine(
      grossProfit.accountingAmount.minus(operatingExpenses.total.accountingAmount),
      grossProfit.adjustment.minus(operatingExpenses.total.adjustment)
    );

    const netAccountingIncome = this.calculateLine(
      operatingProfit.accountingAmount
        .plus(otherIncome.total.accountingAmount)
        .minus(otherExpenses.total.accountingAmount),
      operatingProfit.adjustment
        .plus(otherIncome.total.adjustment)
        .minus(otherExpenses.total.adjustment)
    );

    return {
      companyId: input.companyId,
      periodStart: input.startDate,
      periodEnd: input.endDate,

      revenue,
      costOfSales,
      grossProfit,
      operatingExpenses,
      operatingProfit,
      otherIncome,
      otherExpenses,
      netAccountingIncome,

      ctAdjustments: {
        exemptIncomeDeductions: ctResult.exemptIncome.total,
        nonDeductibleAdditions: ctResult.nonDeductibleExpenses.total,
        otherAdjustments: ctResult.otherAdjustments.total,
        netAdjustment: ctResult.nonDeductibleExpenses.total
          .minus(ctResult.exemptIncome.total)
          .plus(ctResult.otherAdjustments.total)
      },

      taxableIncome: ctResult.taxableIncome,
      ctPayable: ctResult.ctPayable
    };
  }

  /**
   * Generates CT-adjusted Balance Sheet
   */
  async generateCtAdjustedBalanceSheet(input: CtReportInput): Promise<CtAdjustedBalanceSheet> {
    logger.info('Generating CT-adjusted Balance Sheet', { companyId: input.companyId });

    // Get CT calculation for deferred tax
    const ctResult = await this.calculationService.calculateCorporateTax({
      companyId: input.companyId,
      fiscalYearId: input.fiscalYearId,
      startDate: input.startDate,
      endDate: input.endDate
    });

    // Get account balances with CT classifications
    const accounts = await this.getAccountBalancesWithCtClassification(
      input.companyId,
      input.startDate,
      input.endDate
    );

    // Build Balance Sheet sections
    const assets = this.buildSection(
      accounts.filter(a => a.accountType === 'ASSET'),
      [],
      'ASSET'
    );

    const liabilities = this.buildSection(
      accounts.filter(a => a.accountType === 'LIABILITY'),
      [],
      'LIABILITY'
    );

    const equity = this.buildSection(
      accounts.filter(a => a.accountType === 'EQUITY'),
      [],
      'EQUITY'
    );

    // Calculate deferred tax (simplified - full implementation would track timing differences)
    const deferredTaxAsset = ZERO; // From tax losses
    const deferredTaxLiability = ZERO; // From accelerated depreciation

    // Current tax payable
    const currentTaxPayable = ctResult.ctPayable;

    return {
      companyId: input.companyId,
      asOfDate: input.endDate,

      assets,
      liabilities,
      equity,

      deferredTaxAsset,
      deferredTaxLiability,
      currentTaxPayable
    };
  }

  /**
   * Gets a summary of CT adjustments
   */
  async getCtReportSummary(input: CtReportInput): Promise<CtReportSummary> {
    const ctResult = await this.calculationService.calculateCorporateTax({
      companyId: input.companyId,
      fiscalYearId: input.fiscalYearId,
      startDate: input.startDate,
      endDate: input.endDate
    });

    return {
      accountingIncome: ctResult.accountingIncome,
      exemptIncomeDeductions: ctResult.exemptIncome.total,
      nonDeductibleAdditions: ctResult.nonDeductibleExpenses.total,
      otherAdjustments: ctResult.otherAdjustments.total,
      taxableIncome: ctResult.taxableIncome,
      ctPayable: ctResult.ctPayable
    };
  }

  /**
   * Gets account balances with CT classification
   */
  private async getAccountBalancesWithCtClassification(
    companyId: string,
    startDate: Date,
    endDate: Date
  ): Promise<Array<{
    accountId: string;
    accountCode: string;
    accountName: string;
    accountType: string;
    ctCategory: CtAccountCategory | null;
    ctExpenseClass: CtExpenseClassification | null;
    ctIncomeClass: CtIncomeClassification | null;
    debitBalance: Decimal;
    creditBalance: Decimal;
    netBalance: Decimal;
  }>> {
    // Get all accounts with their CT classifications
    const accounts = await this.prisma.chart_of_accounts.findMany({
      where: { companyId },
      select: {
        id: true,
        accountCode: true,
        accountName: true,
        accountType: true,
        ctCategory: true,
        ctExpenseClass: true,
        ctIncomeClass: true
      }
    });

    // Get balances for each account
    const balances = await Promise.all(
      accounts.map(async (account) => {
        const result = await this.prisma.accountingJournalLine.aggregate({
          where: {
            accountId: account.id,
            journalEntry: {
              companyId,
              entryDate: { gte: startDate, lte: endDate },
              status: 'POSTED'
            }
          },
          _sum: {
            debitAmount: true,
            creditAmount: true
          }
        });

        const debitBalance = toDecimal(result._sum.debitAmount);
        const creditBalance = toDecimal(result._sum.creditAmount);
        const netBalance = debitBalance.minus(creditBalance);

        return {
          accountId: account.id,
          accountCode: account.accountCode,
          accountName: account.accountName,
          accountType: account.accountType,
          ctCategory: account.ctCategory,
          ctExpenseClass: account.ctExpenseClass,
          ctIncomeClass: account.ctIncomeClass,
          debitBalance,
          creditBalance,
          netBalance
        };
      })
    );

    // Filter out zero balances and sort by account code
    return balances
      .filter(b => !b.netBalance.equals(ZERO))
      .sort((a, b) => a.accountCode.localeCompare(b.accountCode));
  }

  /**
   * Builds a section of the P&L or Balance Sheet
   */
  private buildSection(
    accounts: Array<{
      accountId: string;
      accountCode: string;
      accountName: string;
      ctCategory: CtAccountCategory | null;
      ctExpenseClass?: CtExpenseClassification | null;
      ctIncomeClass?: CtIncomeClassification | null;
      netBalance: Decimal;
    }>,
    nonDeductibleDetails: NonDeductibleDetail[],
    type: 'INCOME' | 'EXPENSE' | 'ASSET' | 'LIABILITY' | 'EQUITY'
  ): CtAdjustedSection {
    const lines: CtAdjustedAccountLine[] = accounts.map(account => {
      // Get accounting amount (absolute value for display)
      const accountingAmount = account.netBalance.abs();

      // Calculate CT adjustment based on classification
      let exemptAmount = ZERO;
      let nonDeductibleAmount = ZERO;

      if (type === 'EXPENSE' && account.ctExpenseClass) {
        const detail = nonDeductibleDetails.find(d => d.accountId === account.accountId);
        if (detail) {
          nonDeductibleAmount = detail.nonDeductiblePortion;
        } else {
          // Calculate based on classification
          switch (account.ctExpenseClass) {
            case 'NON_DEDUCTIBLE':
            case 'OWNER_WITHDRAWAL':
            case 'PERSONAL_EXPENSE':
              nonDeductibleAmount = accountingAmount;
              break;
            case 'ENTERTAINMENT_50_PCT':
              nonDeductibleAmount = roundCurrency(accountingAmount.times(new Decimal('0.5')));
              break;
            default:
              nonDeductibleAmount = ZERO;
          }
        }
      } else if (type === 'INCOME' && account.ctIncomeClass) {
        switch (account.ctIncomeClass) {
          case 'EXEMPT_DIVIDEND':
          case 'EXEMPT_CAPITAL_GAIN':
          case 'EXEMPT_FOREIGN_PE':
          case 'QUALIFYING_INCOME':
            exemptAmount = accountingAmount;
            break;
          default:
            exemptAmount = ZERO;
        }
      }

      // Taxable amount = Accounting - Exempt (for income) or Accounting - Deductible (for expense)
      const taxableAmount = type === 'INCOME'
        ? accountingAmount.minus(exemptAmount)
        : accountingAmount.minus(nonDeductibleAmount); // For expenses, this is the deductible portion

      return {
        accountId: account.accountId,
        accountCode: account.accountCode,
        accountName: account.accountName,
        ctCategory: account.ctCategory || 'NOT_APPLICABLE',
        accountingAmount: roundCurrency(accountingAmount),
        exemptAmount: roundCurrency(exemptAmount),
        nonDeductibleAmount: roundCurrency(nonDeductibleAmount),
        taxableAmount: roundCurrency(taxableAmount)
      };
    });

    // Calculate totals
    const totalAccounting = lines.reduce((sum, l) => sum.plus(l.accountingAmount), ZERO);
    const totalExempt = lines.reduce((sum, l) => sum.plus(l.exemptAmount), ZERO);
    const totalNonDeductible = lines.reduce((sum, l) => sum.plus(l.nonDeductibleAmount), ZERO);
    const totalTaxable = lines.reduce((sum, l) => sum.plus(l.taxableAmount), ZERO);

    const adjustment = type === 'INCOME'
      ? totalExempt.negated() // Exempt income is subtracted
      : totalNonDeductible;  // Non-deductible is added back

    return {
      accounts: lines,
      total: {
        accountingAmount: roundCurrency(totalAccounting),
        adjustment: roundCurrency(adjustment),
        taxableAmount: roundCurrency(totalTaxable)
      }
    };
  }

  /**
   * Calculates a line with adjustment
   */
  private calculateLine(accountingAmount: Decimal, adjustment: Decimal): CtAdjustedLine {
    return {
      accountingAmount: roundCurrency(accountingAmount),
      adjustment: roundCurrency(adjustment),
      taxableAmount: roundCurrency(accountingAmount.plus(adjustment))
    };
  }

  /**
   * Exports CT-adjusted P&L to JSON for report generation
   */
  async exportCtAdjustedPnL(input: CtReportInput): Promise<object> {
    const report = await this.generateCtAdjustedPnL(input);

    // Get company info
    const company = await this.prisma.company.findUnique({
      where: { id: input.companyId }
    });

    return {
      reportTitle: 'CT-Adjusted Profit & Loss Statement',
      company: {
        name: company?.name,
        trn: await this.getCompanyTrn(input.companyId)
      },
      period: {
        start: input.startDate.toISOString().split('T')[0],
        end: input.endDate.toISOString().split('T')[0]
      },
      sections: {
        revenue: this.sectionToJson(report.revenue, 'Revenue'),
        costOfSales: this.sectionToJson(report.costOfSales, 'Cost of Sales'),
        grossProfit: this.lineToJson(report.grossProfit, 'Gross Profit'),
        operatingExpenses: this.sectionToJson(report.operatingExpenses, 'Operating Expenses'),
        operatingProfit: this.lineToJson(report.operatingProfit, 'Operating Profit'),
        otherIncome: this.sectionToJson(report.otherIncome, 'Other Income'),
        otherExpenses: this.sectionToJson(report.otherExpenses, 'Other Expenses'),
        netAccountingIncome: this.lineToJson(report.netAccountingIncome, 'Net Accounting Income')
      },
      ctAdjustments: {
        exemptIncomeDeductions: Number(report.ctAdjustments.exemptIncomeDeductions),
        nonDeductibleAdditions: Number(report.ctAdjustments.nonDeductibleAdditions),
        otherAdjustments: Number(report.ctAdjustments.otherAdjustments),
        netAdjustment: Number(report.ctAdjustments.netAdjustment)
      },
      taxableIncome: Number(report.taxableIncome),
      ctPayable: Number(report.ctPayable),
      generatedAt: new Date().toISOString()
    };
  }

  private sectionToJson(section: CtAdjustedSection, name: string): object {
    return {
      name,
      accounts: section.accounts.map(a => ({
        code: a.accountCode,
        name: a.accountName,
        accounting: Number(a.accountingAmount),
        exempt: Number(a.exemptAmount),
        nonDeductible: Number(a.nonDeductibleAmount),
        taxable: Number(a.taxableAmount)
      })),
      total: {
        accounting: Number(section.total.accountingAmount),
        adjustment: Number(section.total.adjustment),
        taxable: Number(section.total.taxableAmount)
      }
    };
  }

  private lineToJson(line: CtAdjustedLine, name: string): object {
    return {
      name,
      accounting: Number(line.accountingAmount),
      adjustment: Number(line.adjustment),
      taxable: Number(line.taxableAmount)
    };
  }

  private async getCompanyTrn(companyId: string): Promise<string | null> {
    const config = await this.prisma.tenant_compliance_config.findFirst({
      where: { companyId },
      select: { trn: true }
    });
    return config?.trn || null;
  }
}
```
  </action>
  <verify>
Run `npx tsc --noEmit` to verify TypeScript compiles.
Verify the service has generateCtAdjustedPnL and generateCtAdjustedBalanceSheet methods.
  </verify>
  <done>
CtReportService:
- generateCtAdjustedPnL() with accounting + adjustment + taxable columns (CT-05)
- generateCtAdjustedBalanceSheet() with deferred tax items (CT-06)
- getCtReportSummary() for quick overview
- getAccountBalancesWithCtClassification() joins GL with CT mappings
- buildSection() calculates exempt and non-deductible amounts per account
- exportCtAdjustedPnL() JSON export for report generation
- Sections: Revenue, Cost of Sales, Operating Expenses, Other Income/Expenses
  </done>
</task>

<task type="auto">
  <name>Task 2: Register CtReportService in DI Container</name>
  <files>backend/src/di/container.ts, backend/src/di/types.ts, backend/src/services/corporate-tax/index.ts</files>
  <action>
Add CtReportService to the dependency injection container.

In `backend/src/di/types.ts`, add:
```typescript
CtReportService: Symbol.for('CtReportService'),
```

In `backend/src/di/container.ts`, add import and binding:
```typescript
import { CtReportService } from '../services/corporate-tax/ct-report.service';

container.bind<CtReportService>(TYPES.CtReportService)
  .to(CtReportService)
  .inSingletonScope();
```

Update `backend/src/services/corporate-tax/index.ts`:
```typescript
export {
  CtChartMappingService,
  // ... existing exports
} from './ct-chart-mapping.service';

export {
  CtAdjustmentService,
  // ... existing exports
} from './ct-adjustment.service';

export {
  CtCalculationService
} from './ct-calculation.service';

export {
  CtReportService,
  CtReportInput,
  CtReportSummary
} from './ct-report.service';
```
  </action>
  <verify>
Run `npx tsc --noEmit` to verify container compiles.
  </verify>
  <done>
DI container updated with:
- TYPES.CtReportService symbol
- CtReportService bound as singleton
- Depends on CtAdjustmentService, CtCalculationService, FinancialReportsService
- Index file exports CtReportService and related types
  </done>
</task>

</tasks>

<verification>
1. Run `npx tsc --noEmit` - all files should compile
2. Verify CT-adjusted P&L shows accounting, adjustment, and taxable columns
3. Verify non-deductible expenses shown as additions
4. Verify exempt income shown as deductions
5. Verify CT-adjusted Balance Sheet includes CT payable
</verification>

<success_criteria>
- CT-adjusted P&L shows accounting amounts and CT adjustment columns (CT-05)
- Non-deductible expenses (entertainment 50%, fines 100%) shown as additions
- Exempt income (dividends, gains) shown as deductions
- CT-adjusted Balance Sheet shows deferred tax and CT payable (CT-06)
- Reports can be generated for any fiscal period
- JSON export available for report generation
- Service registered in DI container
</success_criteria>

<output>
After completion, create `.planning/phases/04-corporate-tax-compliance/04-05-SUMMARY.md`
</output>
