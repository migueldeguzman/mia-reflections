---
phase: 04-corporate-tax-compliance
plan: 04
type: execute
wave: 2
depends_on: ["04-01", "04-02"]
files_modified:
  - backend/src/services/corporate-tax/ct-calculation.service.ts
  - backend/src/di/container.ts
autonomous: true

must_haves:
  truths:
    - "CT calculates 9% on taxable income exceeding AED 375,000 threshold"
    - "Tax losses offset maximum 75% of taxable income"
    - "Accounting income comes from FinancialReportsService P&L"
    - "CT adjustments (non-deductible, exempt) applied correctly"
    - "Small Business Relief check for revenue under AED 3M"
  artifacts:
    - path: "backend/src/services/corporate-tax/ct-calculation.service.ts"
      provides: "Core CT calculation engine (CT-01)"
      exports: ["CtCalculationService"]
      min_lines: 300
  key_links:
    - from: "ct-calculation.service.ts"
      to: "ct-adjustment.service.ts"
      via: "Get non-deductible and exempt income totals"
      pattern: "CtAdjustmentService"
    - from: "ct-calculation.service.ts"
      to: "financial-reports.service.ts"
      via: "Get accounting income from P&L"
      pattern: "FinancialReportsService"
    - from: "ct-calculation.service.ts"
      to: "taxLoss"
      via: "Query and apply available losses"
      pattern: "prisma.taxLoss"
---

<objective>
Create the core CT Calculation Service that computes taxable income and CT payable per UAE FTA regulations.

Purpose: CT-01 requires calculating 9% CT on profits exceeding AED 375,000. This service takes accounting income from FinancialReportsService, applies adjustments from CtAdjustmentService, handles loss carry-forward (75% cap), and computes final CT payable.

Output:
- CtCalculationService for full CT computation
- Taxable income calculation with adjustment schedule
- Loss carry-forward with 75% utilization cap
- Small Business Relief eligibility check
- QFZP qualifying/non-qualifying income split
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-corporate-tax-compliance/04-RESEARCH.md
@.planning/phases/04-corporate-tax-compliance/04-01-SUMMARY.md
@.planning/phases/04-corporate-tax-compliance/04-03-SUMMARY.md

# Dependencies
@backend/src/types/corporate-tax.types.ts
@backend/src/services/corporate-tax/ct-adjustment.service.ts
@backend/src/services/finance/financial-reports.service.ts
@backend/src/utils/decimal-math.util.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CT Calculation Service</name>
  <files>backend/src/services/corporate-tax/ct-calculation.service.ts</files>
  <action>
Create the core CT calculation service:

```typescript
import { PrismaClient } from '@prisma/client';
import { Decimal } from '@prisma/client/runtime/library';
import { injectable, inject } from 'inversify';
import { TYPES } from '../../di/types';
import { roundCurrency, toDecimal, ZERO, max, min } from '../../utils/decimal-math.util';
import {
  CtCalculationInput,
  CtCalculationResult,
  TaxableIncomeSchedule,
  CT_CONSTANTS,
  SmallBusinessReliefCheck,
  TaxLossRecord,
  LossOffsetCalculation
} from '../../types/corporate-tax.types';
import { CtAdjustmentService } from './ct-adjustment.service';
import logger from '../logger.service';

/**
 * CT Calculation Service
 *
 * Core Corporate Tax calculation engine implementing UAE FTA regulations.
 *
 * Key formulas:
 * - Taxable Income = Accounting Income - Exempt Income + Non-Deductible
 * - Loss Offset = min(Available Losses, Taxable Income x 75%)
 * - CT Payable = max(0, Taxable Income - 375,000) x 9%
 *
 * Requirement: CT-01
 */

// ============================================================================
// Service
// ============================================================================

@injectable()
export class CtCalculationService {
  constructor(
    @inject(TYPES.PrismaClient)
    private readonly prisma: PrismaClient,
    @inject(TYPES.CtAdjustmentService)
    private readonly adjustmentService: CtAdjustmentService,
    @inject(TYPES.FinancialReportsService)
    private readonly financialReportsService: any // Type from finance module
  ) {}

  /**
   * Calculates Corporate Tax for a period
   *
   * Steps:
   * 1. Get accounting income from P&L
   * 2. Apply CT adjustments (non-deductible, exempt)
   * 3. Calculate taxable income before losses
   * 4. Apply loss carry-forward (max 75%)
   * 5. Calculate CT at 9% on amount exceeding threshold
   */
  async calculateCorporateTax(input: CtCalculationInput): Promise<CtCalculationResult> {
    logger.info('Starting CT calculation', {
      companyId: input.companyId,
      startDate: input.startDate,
      endDate: input.endDate
    });

    // 1. Get accounting income from P&L
    const accountingIncome = await this.getAccountingIncome(input);

    // 2. Check if company is QFZP
    const isQfzp = input.isQfzp ?? await this.checkQfzpStatus(input.companyId);

    // 3. Get CT adjustments
    const adjustments = await this.adjustmentService.aggregateAdjustments({
      companyId: input.companyId,
      startDate: input.startDate,
      endDate: input.endDate
    });

    // 4. Calculate taxable income before losses
    const taxableIncomeBeforeLosses = roundCurrency(
      accountingIncome
        .minus(adjustments.exemptIncome.total)
        .plus(adjustments.nonDeductible.total)
        .plus(adjustments.otherAdjustments.total)
    );

    // 5. Get available losses and calculate offset
    const lossCalculation = await this.calculateLossOffset(
      input.companyId,
      taxableIncomeBeforeLosses
    );

    // 6. Calculate taxable income after losses
    const taxableIncome = max(
      taxableIncomeBeforeLosses.minus(lossCalculation.amountToOffset),
      ZERO
    );

    // 7. Check Small Business Relief eligibility
    const sbrCheck = await this.checkSmallBusinessRelief(input.companyId, input.endDate);
    const sbrApplied = sbrCheck.eligible && taxableIncome.greaterThan(ZERO);

    // 8. Calculate CT payable
    let ctPayable: Decimal;
    let taxFreeAmount: Decimal;
    let taxableAmount: Decimal;

    if (sbrApplied) {
      // Small Business Relief - 0% CT
      ctPayable = ZERO;
      taxFreeAmount = taxableIncome;
      taxableAmount = ZERO;
    } else if (isQfzp) {
      // QFZP - calculate qualifying vs non-qualifying
      // For now, assume all income is qualifying (0% rate)
      // Non-qualifying would be taxed at 9%
      ctPayable = ZERO;
      taxFreeAmount = taxableIncome;
      taxableAmount = ZERO;
    } else {
      // Standard calculation
      taxFreeAmount = min(taxableIncome, CT_CONSTANTS.THRESHOLD);
      taxableAmount = max(taxableIncome.minus(CT_CONSTANTS.THRESHOLD), ZERO);
      ctPayable = roundCurrency(taxableAmount.times(CT_CONSTANTS.RATE));
    }

    // 9. Record loss usage if applicable
    if (lossCalculation.amountToOffset.greaterThan(ZERO)) {
      await this.recordLossUsage(
        input.companyId,
        input.fiscalYearId,
        lossCalculation
      );
    }

    const result: CtCalculationResult = {
      companyId: input.companyId,
      periodStart: input.startDate,
      periodEnd: input.endDate,

      accountingIncome,

      exemptIncome: adjustments.exemptIncome,
      nonDeductibleExpenses: adjustments.nonDeductible,
      otherAdjustments: adjustments.otherAdjustments,

      taxableIncomeBeforeLosses,
      availableLosses: lossCalculation.totalAvailable,
      lossesApplied: lossCalculation.amountToOffset,
      taxableIncome,

      taxFreeAmount,
      taxableAmount,
      ctRate: CT_CONSTANTS.RATE,
      ctPayable,

      isQfzp,
      eligibleForSbr: sbrCheck.eligible,
      sbrApplied
    };

    logger.info('CT calculation complete', {
      companyId: input.companyId,
      accountingIncome: accountingIncome.toString(),
      taxableIncome: taxableIncome.toString(),
      ctPayable: ctPayable.toString()
    });

    return result;
  }

  /**
   * Gets accounting income from P&L (net profit before tax)
   */
  private async getAccountingIncome(input: CtCalculationInput): Promise<Decimal> {
    try {
      const pnl = await this.financialReportsService.getProfitAndLoss(
        input.companyId,
        {
          startDate: input.startDate,
          endDate: input.endDate
        }
      );

      return toDecimal(pnl.netIncome || pnl.netProfit || 0);
    } catch (error) {
      logger.warn('Failed to get P&L from FinancialReportsService, falling back to GL query', { error });

      // Fallback: Calculate from GL directly
      return this.calculateAccountingIncomeFromGl(input);
    }
  }

  /**
   * Fallback: Calculate accounting income from General Ledger
   */
  private async calculateAccountingIncomeFromGl(input: CtCalculationInput): Promise<Decimal> {
    // Get revenue (credit balances on income accounts)
    const revenueResult = await this.prisma.accountingJournalLine.aggregate({
      where: {
        journalEntry: {
          companyId: input.companyId,
          entryDate: { gte: input.startDate, lte: input.endDate },
          status: 'POSTED'
        },
        account: {
          accountType: 'INCOME'
        }
      },
      _sum: {
        creditAmount: true,
        debitAmount: true
      }
    });

    // Get expenses (debit balances on expense accounts)
    const expenseResult = await this.prisma.accountingJournalLine.aggregate({
      where: {
        journalEntry: {
          companyId: input.companyId,
          entryDate: { gte: input.startDate, lte: input.endDate },
          status: 'POSTED'
        },
        account: {
          accountType: 'EXPENSE'
        }
      },
      _sum: {
        debitAmount: true,
        creditAmount: true
      }
    });

    const revenue = toDecimal(revenueResult._sum.creditAmount)
      .minus(toDecimal(revenueResult._sum.debitAmount));

    const expenses = toDecimal(expenseResult._sum.debitAmount)
      .minus(toDecimal(expenseResult._sum.creditAmount));

    return roundCurrency(revenue.minus(expenses));
  }

  /**
   * Calculates loss offset with 75% cap
   */
  async calculateLossOffset(
    companyId: string,
    taxableIncomeBeforeLosses: Decimal
  ): Promise<LossOffsetCalculation> {
    // Get available losses (ordered by oldest first - FIFO)
    const losses = await this.prisma.taxLoss.findMany({
      where: {
        companyId,
        remainingAmount: { gt: 0 }
      },
      orderBy: { periodStart: 'asc' }
    });

    const availableLosses: TaxLossRecord[] = losses.map(l => ({
      id: l.id,
      companyId: l.companyId,
      fiscalYearId: l.fiscalYearId,
      lossType: l.lossType as 'TRADING' | 'CAPITAL',
      lossAmount: toDecimal(l.lossAmount),
      usedAmount: toDecimal(l.usedAmount),
      remainingAmount: toDecimal(l.remainingAmount),
      periodStart: l.periodStart,
      periodEnd: l.periodEnd
    }));

    const totalAvailable = availableLosses.reduce(
      (sum, l) => sum.plus(l.remainingAmount),
      ZERO
    );

    // Maximum offset is 75% of taxable income
    const maxOffsetAmount = roundCurrency(
      taxableIncomeBeforeLosses.times(CT_CONSTANTS.MAX_LOSS_OFFSET)
    );

    // Amount to offset is minimum of available and max allowed
    const amountToOffset = min(totalAvailable, maxOffsetAmount);

    const taxableIncomeAfterLosses = max(
      taxableIncomeBeforeLosses.minus(amountToOffset),
      ZERO
    );

    const lossesRemaining = totalAvailable.minus(amountToOffset);

    return {
      taxableIncomeBeforeLosses,
      maxOffsetAmount,
      availableLosses,
      totalAvailable,
      amountToOffset,
      taxableIncomeAfterLosses,
      lossesRemaining
    };
  }

  /**
   * Records loss usage for audit trail
   */
  private async recordLossUsage(
    companyId: string,
    appliedInPeriod: string,
    calculation: LossOffsetCalculation
  ): Promise<void> {
    let remainingToOffset = calculation.amountToOffset;

    // Apply to losses in FIFO order
    for (const loss of calculation.availableLosses) {
      if (remainingToOffset.lessThanOrEqualTo(ZERO)) break;

      const useFromThisLoss = min(loss.remainingAmount, remainingToOffset);

      if (useFromThisLoss.greaterThan(ZERO)) {
        // Update the loss record
        await this.prisma.taxLoss.update({
          where: { id: loss.id },
          data: {
            usedAmount: { increment: useFromThisLoss.toNumber() },
            remainingAmount: { decrement: useFromThisLoss.toNumber() }
          }
        });

        // Create usage record
        await this.prisma.taxLossUsage.create({
          data: {
            taxLossId: loss.id,
            appliedInPeriod,
            amountUsed: useFromThisLoss.toNumber(),
            balanceBefore: loss.remainingAmount.toNumber(),
            balanceAfter: loss.remainingAmount.minus(useFromThisLoss).toNumber(),
            createdById: 'SYSTEM'
          }
        });

        remainingToOffset = remainingToOffset.minus(useFromThisLoss);
      }
    }
  }

  /**
   * Checks if company qualifies for Small Business Relief
   *
   * Conditions:
   * - Revenue <= AED 3M in current period
   * - Revenue <= AED 3M in previous period
   * - Not a QFZP
   * - Tax period ends on or before Dec 31, 2026
   */
  async checkSmallBusinessRelief(
    companyId: string,
    taxPeriodEndDate: Date
  ): Promise<SmallBusinessReliefCheck> {
    const reliefEndDate = new Date('2026-12-31');

    // Check if relief still available
    if (taxPeriodEndDate.getTime() > reliefEndDate.getTime()) {
      return {
        eligible: false,
        reason: 'Small Business Relief ended December 2026',
        currentPeriodRevenue: ZERO,
        previousPeriodRevenue: ZERO,
        thresholdAmount: CT_CONSTANTS.SBR_THRESHOLD,
        reliefEndDate,
        isQfzp: false
      };
    }

    // Check if QFZP (not eligible)
    const isQfzp = await this.checkQfzpStatus(companyId);
    if (isQfzp) {
      return {
        eligible: false,
        reason: 'QFZPs not eligible for Small Business Relief',
        currentPeriodRevenue: ZERO,
        previousPeriodRevenue: ZERO,
        thresholdAmount: CT_CONSTANTS.SBR_THRESHOLD,
        reliefEndDate,
        isQfzp: true
      };
    }

    // Calculate current period revenue
    const currentRevenue = await this.calculatePeriodRevenue(companyId, taxPeriodEndDate);

    // Calculate previous period revenue
    const previousPeriodEnd = new Date(taxPeriodEndDate);
    previousPeriodEnd.setFullYear(previousPeriodEnd.getFullYear() - 1);
    const previousRevenue = await this.calculatePeriodRevenue(companyId, previousPeriodEnd);

    const eligible = currentRevenue.lessThanOrEqualTo(CT_CONSTANTS.SBR_THRESHOLD)
      && previousRevenue.lessThanOrEqualTo(CT_CONSTANTS.SBR_THRESHOLD);

    return {
      eligible,
      reason: eligible ? undefined : `Revenue exceeds AED ${CT_CONSTANTS.SBR_THRESHOLD} threshold`,
      currentPeriodRevenue: currentRevenue,
      previousPeriodRevenue: previousRevenue,
      thresholdAmount: CT_CONSTANTS.SBR_THRESHOLD,
      reliefEndDate,
      isQfzp: false
    };
  }

  /**
   * Calculates revenue for a period (12 months ending on date)
   */
  private async calculatePeriodRevenue(
    companyId: string,
    periodEndDate: Date
  ): Promise<Decimal> {
    const periodStartDate = new Date(periodEndDate);
    periodStartDate.setFullYear(periodStartDate.getFullYear() - 1);
    periodStartDate.setDate(periodStartDate.getDate() + 1);

    const result = await this.prisma.accountingJournalLine.aggregate({
      where: {
        journalEntry: {
          companyId,
          entryDate: { gte: periodStartDate, lte: periodEndDate },
          status: 'POSTED'
        },
        account: {
          accountType: 'INCOME'
        }
      },
      _sum: { creditAmount: true }
    });

    return toDecimal(result._sum.creditAmount);
  }

  /**
   * Checks if company is a Qualifying Free Zone Person
   */
  private async checkQfzpStatus(companyId: string): Promise<boolean> {
    const config = await this.prisma.tenant_compliance_config.findFirst({
      where: { companyId },
      select: {
        freeZoneStatus: true,
        isDesignatedZone: true
      }
    });

    // QFZP requires specific registration and conditions
    // For now, check if company is in a designated free zone
    return config?.freeZoneStatus === 'QFZP' || false;
  }

  /**
   * Creates a taxable income schedule for CT return
   */
  generateTaxableIncomeSchedule(result: CtCalculationResult): TaxableIncomeSchedule {
    return {
      line1_accountingIncome: result.accountingIncome,
      line2_exemptIncome: result.exemptIncome.total,
      line3_nonDeductibleExpenses: result.nonDeductibleExpenses.total,
      line4_otherAdditions: result.otherAdjustments.total.greaterThan(ZERO)
        ? result.otherAdjustments.total
        : ZERO,
      line5_otherDeductions: result.otherAdjustments.total.lessThan(ZERO)
        ? result.otherAdjustments.total.abs()
        : ZERO,
      line6_taxableIncomeBeforeLosses: result.taxableIncomeBeforeLosses,
      line7_lossRelief: result.lossesApplied,
      line8_taxableIncome: result.taxableIncome
    };
  }

  /**
   * Records a tax loss for carry-forward
   */
  async recordTaxLoss(
    companyId: string,
    fiscalYearId: string,
    lossAmount: Decimal,
    periodStart: Date,
    periodEnd: Date,
    lossType: 'TRADING' | 'CAPITAL',
    createdById: string
  ): Promise<TaxLossRecord> {
    const loss = await this.prisma.taxLoss.create({
      data: {
        companyId,
        fiscalYearId,
        lossType,
        lossAmount: lossAmount.toNumber(),
        usedAmount: 0,
        remainingAmount: lossAmount.toNumber(),
        periodStart,
        periodEnd,
        createdById
      }
    });

    logger.info('Tax loss recorded', {
      companyId,
      fiscalYearId,
      lossAmount: lossAmount.toString(),
      lossType
    });

    return {
      id: loss.id,
      companyId: loss.companyId,
      fiscalYearId: loss.fiscalYearId,
      lossType: loss.lossType as 'TRADING' | 'CAPITAL',
      lossAmount: toDecimal(loss.lossAmount),
      usedAmount: toDecimal(loss.usedAmount),
      remainingAmount: toDecimal(loss.remainingAmount),
      periodStart: loss.periodStart,
      periodEnd: loss.periodEnd
    };
  }

  /**
   * Gets available losses for a company
   */
  async getAvailableLosses(companyId: string): Promise<TaxLossRecord[]> {
    const losses = await this.prisma.taxLoss.findMany({
      where: {
        companyId,
        remainingAmount: { gt: 0 }
      },
      orderBy: { periodStart: 'asc' }
    });

    return losses.map(l => ({
      id: l.id,
      companyId: l.companyId,
      fiscalYearId: l.fiscalYearId,
      lossType: l.lossType as 'TRADING' | 'CAPITAL',
      lossAmount: toDecimal(l.lossAmount),
      usedAmount: toDecimal(l.usedAmount),
      remainingAmount: toDecimal(l.remainingAmount),
      periodStart: l.periodStart,
      periodEnd: l.periodEnd
    }));
  }
}
```
  </action>
  <verify>
Run `npx tsc --noEmit` to verify TypeScript compiles.
Verify the service has calculateCorporateTax, calculateLossOffset, and checkSmallBusinessRelief methods.
  </verify>
  <done>
CtCalculationService:
- calculateCorporateTax() with full CT-01 implementation
- Gets accounting income from FinancialReportsService.getProfitAndLoss()
- Applies non-deductible and exempt income adjustments
- calculateLossOffset() with 75% cap (CT-01)
- Records loss usage in taxLossUsage table
- checkSmallBusinessRelief() for AED 3M threshold
- checkQfzpStatus() for free zone persons
- generateTaxableIncomeSchedule() for CT return
- recordTaxLoss() for loss carry-forward tracking
  </done>
</task>

<task type="auto">
  <name>Task 2: Register CtCalculationService in DI Container</name>
  <files>backend/src/di/container.ts, backend/src/di/types.ts, backend/src/services/corporate-tax/index.ts</files>
  <action>
Add CtCalculationService to the dependency injection container.

In `backend/src/di/types.ts`, add:
```typescript
CtCalculationService: Symbol.for('CtCalculationService'),
```

In `backend/src/di/container.ts`, add import and binding:
```typescript
import { CtCalculationService } from '../services/corporate-tax/ct-calculation.service';

container.bind<CtCalculationService>(TYPES.CtCalculationService)
  .to(CtCalculationService)
  .inSingletonScope();
```

Update `backend/src/services/corporate-tax/index.ts`:
```typescript
export {
  CtChartMappingService,
  CtMappingInput,
  CtMappingRule,
  BulkMappingResult,
  CtMappingSummary,
  DEFAULT_CT_MAPPING_RULES
} from './ct-chart-mapping.service';

export {
  CtAdjustmentService,
  AdjustmentPeriodInput,
  CtAdjustmentResult
} from './ct-adjustment.service';

export {
  CtCalculationService
} from './ct-calculation.service';
```
  </action>
  <verify>
Run `npx tsc --noEmit` to verify container compiles.
  </verify>
  <done>
DI container updated with:
- TYPES.CtCalculationService symbol
- CtCalculationService bound as singleton
- Depends on CtAdjustmentService and FinancialReportsService
- Index file exports CtCalculationService
  </done>
</task>

</tasks>

<verification>
1. Run `npx tsc --noEmit` - all files should compile
2. Verify CT uses 9% rate on amount exceeding AED 375,000
3. Verify loss offset caps at 75% of taxable income
4. Verify Small Business Relief checks AED 3M threshold
5. Verify accounting income comes from P&L service
</verification>

<success_criteria>
- CT calculates 9% on taxable income exceeding AED 375,000 (CT-01)
- Tax losses offset maximum 75% of taxable income
- Accounting income sourced from FinancialReportsService.getProfitAndLoss()
- CT adjustments (non-deductible, exempt) applied from CtAdjustmentService
- Small Business Relief checked for revenue under AED 3M
- Loss usage recorded in taxLossUsage table for audit trail
- Service registered in DI container
</success_criteria>

<output>
After completion, create `.planning/phases/04-corporate-tax-compliance/04-04-SUMMARY.md`
</output>
