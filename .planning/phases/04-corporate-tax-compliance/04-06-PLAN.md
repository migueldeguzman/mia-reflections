---
phase: 04-corporate-tax-compliance
plan: 06
type: execute
wave: 3
depends_on: ["04-01"]
files_modified:
  - backend/src/services/corporate-tax/transfer-pricing.service.ts
  - backend/src/di/container.ts
autonomous: true

must_haves:
  truths:
    - "Related party transactions can be recorded with transfer pricing details"
    - "Arm's length price comparison identifies adjustments needed"
    - "TP disclosure thresholds calculated (AED 40M total, AED 4M per category)"
    - "Documentation requirements determined based on group revenue"
    - "TP adjustments flow into CT non-deductible calculation"
  artifacts:
    - path: "backend/src/services/corporate-tax/transfer-pricing.service.ts"
      provides: "Transfer pricing documentation and threshold service (CT-07)"
      exports: ["TransferPricingService"]
      min_lines: 300
  key_links:
    - from: "transfer-pricing.service.ts"
      to: "relatedPartyTransaction"
      via: "Record and query RP transactions"
      pattern: "prisma.relatedPartyTransaction"
    - from: "transfer-pricing.service.ts"
      to: "ct-adjustment.service.ts"
      via: "TP adjustments feed into non-deductible"
      pattern: "calculateRelatedPartyExcess"
---

<objective>
Create the Transfer Pricing Service for related party transaction tracking and arm's length compliance.

Purpose: CT-07 requires maintaining transfer pricing documentation for intercompany transactions. This service records related party transactions, compares against arm's length prices, calculates disclosure thresholds, and identifies when Master File/Local File documentation is required.

Output:
- TransferPricingService for TP compliance
- Related party transaction recording
- Arm's length price comparison and adjustment calculation
- TP disclosure threshold analysis
- Documentation requirement determination
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-corporate-tax-compliance/04-RESEARCH.md
@.planning/phases/04-corporate-tax-compliance/04-01-SUMMARY.md

# Dependencies
@backend/src/types/corporate-tax.types.ts
@backend/src/utils/decimal-math.util.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Transfer Pricing Service</name>
  <files>backend/src/services/corporate-tax/transfer-pricing.service.ts</files>
  <action>
Create the transfer pricing service:

```typescript
import { PrismaClient, TransferPricingMethod, RelationshipType } from '@prisma/client';
import { Decimal } from '@prisma/client/runtime/library';
import { injectable, inject } from 'inversify';
import { TYPES } from '../../di/types';
import { roundCurrency, toDecimal, ZERO } from '../../utils/decimal-math.util';
import {
  RelatedPartyTransactionInput,
  ArmLengthTestResult,
  TransferPricingThresholds,
  TransferPricingCategoryBreakdown
} from '../../types/corporate-tax.types';
import logger from '../logger.service';

/**
 * Transfer Pricing Service
 *
 * Manages transfer pricing compliance for related party transactions.
 *
 * Key thresholds (FTA Ministerial Decision):
 * - AED 40M+ total or AED 4M+ per category: TP Disclosure Form required
 * - AED 500K+ connected person payments: Noted in CT return
 * - AED 200M+ group revenue: Master File + Local File required
 * - AED 3.15B+ global MNE revenue: Country-by-Country Report
 *
 * Requirement: CT-07
 */

// ============================================================================
// Constants
// ============================================================================

const TP_THRESHOLDS = {
  /** Total RP value requiring TP Disclosure Form */
  DISCLOSURE_TOTAL: new Decimal('40000000'), // AED 40M

  /** Per-category value requiring TP Disclosure Form */
  DISCLOSURE_PER_CATEGORY: new Decimal('4000000'), // AED 4M

  /** Connected person payments noted in CT return */
  CONNECTED_PERSON_NOTED: new Decimal('500000'), // AED 500K

  /** Group revenue requiring Master/Local File */
  MASTER_LOCAL_FILE: new Decimal('200000000'), // AED 200M

  /** Global MNE revenue requiring CbCR */
  CBCR_THRESHOLD: new Decimal('3150000000'), // AED 3.15B

  /** Arm's length tolerance percentage */
  ARM_LENGTH_TOLERANCE: new Decimal('0.05') // 5% tolerance
};

// ============================================================================
// Types
// ============================================================================

export interface RelatedPartyTransactionRecord {
  id: string;
  companyId: string;
  relatedPartyId: string;
  relatedPartyName: string;
  relationshipType: RelationshipType;
  transactionDate: Date;
  transactionType: string;
  description: string;
  transactionAmount: Decimal;
  armLengthPrice: Decimal | null;
  pricingMethod: TransferPricingMethod | null;
  adjustmentRequired: boolean;
  adjustmentAmount: Decimal | null;
  hasDocumentation: boolean;
}

export interface TpComplianceStatus {
  companyId: string;
  fiscalYear: string;
  thresholds: TransferPricingThresholds;
  requiredActions: string[];
  documentationStatus: {
    disclosureFormRequired: boolean;
    disclosureFormComplete: boolean;
    masterFileRequired: boolean;
    masterFileComplete: boolean;
    localFileRequired: boolean;
    localFileComplete: boolean;
  };
  adjustmentsSummary: {
    totalAdjustments: Decimal;
    transactionsAdjusted: number;
  };
}

// ============================================================================
// Service
// ============================================================================

@injectable()
export class TransferPricingService {
  constructor(
    @inject(TYPES.PrismaClient)
    private readonly prisma: PrismaClient
  ) {}

  /**
   * Records a related party transaction
   */
  async recordTransaction(
    input: RelatedPartyTransactionInput
  ): Promise<RelatedPartyTransactionRecord> {
    // Perform arm's length test if arm's length price provided
    let adjustmentRequired = false;
    let adjustmentAmount: Decimal | null = null;

    if (input.armLengthPrice) {
      const testResult = this.performArmLengthTest(
        toDecimal(input.transactionAmount),
        toDecimal(input.armLengthPrice)
      );
      adjustmentRequired = testResult.adjustmentRequired;
      adjustmentAmount = testResult.adjustmentAmount;
    }

    const transaction = await this.prisma.relatedPartyTransaction.create({
      data: {
        companyId: input.companyId,
        relatedPartyId: input.relatedPartyId,
        relatedPartyName: input.relatedPartyName,
        relatedPartyTrn: input.relatedPartyTrn,
        relationshipType: input.relationshipType,
        transactionDate: input.transactionDate,
        transactionType: input.transactionType,
        description: input.description,
        transactionAmount: input.transactionAmount.toNumber(),
        currency: input.currency || 'AED',
        armLengthPrice: input.armLengthPrice?.toNumber(),
        pricingMethod: input.pricingMethod,
        adjustmentRequired,
        adjustmentAmount: adjustmentAmount?.toNumber(),
        createdById: input.createdById
      }
    });

    logger.info('Related party transaction recorded', {
      id: transaction.id,
      companyId: input.companyId,
      relatedPartyName: input.relatedPartyName,
      transactionType: input.transactionType,
      amount: input.transactionAmount.toString(),
      adjustmentRequired
    });

    return this.mapToRecord(transaction);
  }

  /**
   * Performs arm's length price comparison
   */
  performArmLengthTest(
    transactionAmount: Decimal,
    armLengthPrice: Decimal
  ): ArmLengthTestResult {
    const difference = transactionAmount.minus(armLengthPrice).abs();
    const differencePercent = armLengthPrice.equals(ZERO)
      ? new Decimal('100')
      : difference.dividedBy(armLengthPrice).times(new Decimal('100'));

    const withinRange = differencePercent.lessThanOrEqualTo(
      TP_THRESHOLDS.ARM_LENGTH_TOLERANCE.times(new Decimal('100'))
    );

    const adjustmentRequired = !withinRange;

    // Adjustment is the non-arm's length excess
    // If transaction > arm's length, excess is not deductible
    const adjustmentAmount = transactionAmount.greaterThan(armLengthPrice)
      ? transactionAmount.minus(armLengthPrice)
      : ZERO;

    return {
      transactionId: '',
      transactionAmount,
      armLengthPrice,
      difference: roundCurrency(difference),
      differencePercent: roundCurrency(differencePercent),
      withinRange,
      adjustmentRequired,
      adjustmentAmount: roundCurrency(adjustmentAmount),
      pricingMethod: 'CUP' // Default, should be specified
    };
  }

  /**
   * Updates arm's length price and recalculates adjustment
   */
  async updateArmLengthPrice(
    transactionId: string,
    armLengthPrice: Decimal,
    pricingMethod: TransferPricingMethod,
    userId: string
  ): Promise<RelatedPartyTransactionRecord> {
    const existing = await this.prisma.relatedPartyTransaction.findUnique({
      where: { id: transactionId }
    });

    if (!existing) {
      throw new Error('Related party transaction not found');
    }

    const transactionAmount = toDecimal(existing.transactionAmount);
    const testResult = this.performArmLengthTest(transactionAmount, armLengthPrice);

    const updated = await this.prisma.relatedPartyTransaction.update({
      where: { id: transactionId },
      data: {
        armLengthPrice: armLengthPrice.toNumber(),
        pricingMethod,
        adjustmentRequired: testResult.adjustmentRequired,
        adjustmentAmount: testResult.adjustmentAmount.toNumber(),
        updatedAt: new Date()
      }
    });

    // Audit log
    await this.prisma.auditLogs.create({
      data: {
        userId,
        action: 'TP_ARM_LENGTH_UPDATE',
        entity: 'RelatedPartyTransaction',
        entityId: transactionId,
        previousValue: {
          armLengthPrice: existing.armLengthPrice,
          adjustmentRequired: existing.adjustmentRequired
        },
        newValue: {
          armLengthPrice: armLengthPrice.toNumber(),
          pricingMethod,
          adjustmentRequired: testResult.adjustmentRequired,
          adjustmentAmount: testResult.adjustmentAmount.toNumber()
        }
      }
    });

    return this.mapToRecord(updated);
  }

  /**
   * Calculates transfer pricing thresholds for a period
   */
  async calculateThresholds(
    companyId: string,
    startDate: Date,
    endDate: Date
  ): Promise<TransferPricingThresholds> {
    // Get all RP transactions for the period
    const transactions = await this.prisma.relatedPartyTransaction.findMany({
      where: {
        companyId,
        transactionDate: { gte: startDate, lte: endDate }
      }
    });

    // Calculate total value
    const totalRelatedPartyValue = transactions.reduce(
      (sum, t) => sum.plus(toDecimal(t.transactionAmount).abs()),
      ZERO
    );

    // Calculate by category (transaction type)
    const categoryMap = new Map<string, { total: Decimal; count: number }>();
    for (const t of transactions) {
      const existing = categoryMap.get(t.transactionType) || { total: ZERO, count: 0 };
      categoryMap.set(t.transactionType, {
        total: existing.total.plus(toDecimal(t.transactionAmount).abs()),
        count: existing.count + 1
      });
    }

    const byCategory: TransferPricingCategoryBreakdown[] = Array.from(categoryMap.entries()).map(
      ([transactionType, data]) => ({
        transactionType,
        totalAmount: roundCurrency(data.total),
        transactionCount: data.count,
        exceedsAed4M: data.total.greaterThanOrEqualTo(TP_THRESHOLDS.DISCLOSURE_PER_CATEGORY)
      })
    );

    // Calculate connected person payments
    // Connected persons include directors, key management
    const connectedTransactions = transactions.filter(
      t => t.relationshipType === 'KEY_MANAGEMENT' || t.relationshipType === 'COMMON_OWNER'
    );
    const connectedPersonPayments = connectedTransactions.reduce(
      (sum, t) => sum.plus(toDecimal(t.transactionAmount).abs()),
      ZERO
    );

    // Get group revenue for Master/Local File determination
    const groupRevenue = await this.getGroupRevenue(companyId, startDate, endDate);

    const exceedsAed40M = totalRelatedPartyValue.greaterThanOrEqualTo(TP_THRESHOLDS.DISCLOSURE_TOTAL);
    const anyCategoryExceeds4M = byCategory.some(c => c.exceedsAed4M);
    const requiresDisclosureForm = exceedsAed40M || anyCategoryExceeds4M;

    return {
      totalRelatedPartyValue: roundCurrency(totalRelatedPartyValue),
      exceedsAed40M,
      requiresDisclosureForm,

      byCategory,

      connectedPersonPayments: roundCurrency(connectedPersonPayments),
      exceedsAed500K: connectedPersonPayments.greaterThanOrEqualTo(TP_THRESHOLDS.CONNECTED_PERSON_NOTED),

      groupRevenue: roundCurrency(groupRevenue),
      requiresMasterLocalFile: groupRevenue.greaterThanOrEqualTo(TP_THRESHOLDS.MASTER_LOCAL_FILE),
      requiresCbcr: groupRevenue.greaterThanOrEqualTo(TP_THRESHOLDS.CBCR_THRESHOLD)
    };
  }

  /**
   * Gets group revenue for documentation threshold
   */
  private async getGroupRevenue(
    companyId: string,
    startDate: Date,
    endDate: Date
  ): Promise<Decimal> {
    // Check if company is part of a tax group
    const groupMembership = await this.prisma.taxGroupMember.findFirst({
      where: {
        companyId,
        joinDate: { lte: endDate },
        OR: [
          { leaveDate: null },
          { leaveDate: { gte: startDate } }
        ]
      },
      include: {
        taxGroup: {
          include: { members: true }
        }
      }
    });

    if (groupMembership) {
      // Sum revenue across all group members
      const memberIds = groupMembership.taxGroup.members.map(m => m.companyId);

      const result = await this.prisma.accountingJournalLine.aggregate({
        where: {
          journalEntry: {
            companyId: { in: memberIds },
            entryDate: { gte: startDate, lte: endDate },
            status: 'POSTED'
          },
          account: {
            accountType: 'INCOME'
          }
        },
        _sum: { creditAmount: true }
      });

      return toDecimal(result._sum.creditAmount);
    }

    // Single company revenue
    const result = await this.prisma.accountingJournalLine.aggregate({
      where: {
        journalEntry: {
          companyId,
          entryDate: { gte: startDate, lte: endDate },
          status: 'POSTED'
        },
        account: {
          accountType: 'INCOME'
        }
      },
      _sum: { creditAmount: true }
    });

    return toDecimal(result._sum.creditAmount);
  }

  /**
   * Gets TP compliance status for a fiscal year
   */
  async getComplianceStatus(
    companyId: string,
    fiscalYear: string,
    startDate: Date,
    endDate: Date
  ): Promise<TpComplianceStatus> {
    const thresholds = await this.calculateThresholds(companyId, startDate, endDate);

    // Get adjustment totals
    const adjustments = await this.prisma.relatedPartyTransaction.aggregate({
      where: {
        companyId,
        transactionDate: { gte: startDate, lte: endDate },
        adjustmentRequired: true
      },
      _sum: { adjustmentAmount: true },
      _count: { id: true }
    });

    // Check documentation status
    const transactions = await this.prisma.relatedPartyTransaction.findMany({
      where: {
        companyId,
        transactionDate: { gte: startDate, lte: endDate }
      },
      select: {
        hasLocalFile: true,
        hasMasterFile: true
      }
    });

    const hasLocalFile = transactions.some(t => t.hasLocalFile);
    const hasMasterFile = transactions.some(t => t.hasMasterFile);

    // Determine required actions
    const requiredActions: string[] = [];

    if (thresholds.requiresDisclosureForm) {
      requiredActions.push('Complete TP Disclosure Form in CT Return');
    }

    if (thresholds.requiresMasterLocalFile && !hasMasterFile) {
      requiredActions.push('Prepare Master File within 30 days of FTA request');
    }

    if (thresholds.requiresMasterLocalFile && !hasLocalFile) {
      requiredActions.push('Prepare Local File within 30 days of FTA request');
    }

    if (thresholds.exceedsAed500K) {
      requiredActions.push('Disclose connected person payments in CT Return');
    }

    if (thresholds.requiresCbcr) {
      requiredActions.push('File Country-by-Country Report');
    }

    const totalAdjustments = toDecimal(adjustments._sum.adjustmentAmount);

    if (totalAdjustments.greaterThan(ZERO)) {
      requiredActions.push(`Review ${adjustments._count.id} transactions with arm\'s length adjustments`);
    }

    return {
      companyId,
      fiscalYear,
      thresholds,
      requiredActions,
      documentationStatus: {
        disclosureFormRequired: thresholds.requiresDisclosureForm,
        disclosureFormComplete: false, // Would need to track this separately
        masterFileRequired: thresholds.requiresMasterLocalFile,
        masterFileComplete: hasMasterFile,
        localFileRequired: thresholds.requiresMasterLocalFile,
        localFileComplete: hasLocalFile
      },
      adjustmentsSummary: {
        totalAdjustments: roundCurrency(totalAdjustments),
        transactionsAdjusted: adjustments._count.id
      }
    };
  }

  /**
   * Updates documentation status for a transaction
   */
  async updateDocumentationStatus(
    transactionId: string,
    hasLocalFile: boolean,
    hasMasterFile: boolean,
    benchmarkingDone: boolean,
    documentationPath: string | null,
    notes: string | null,
    userId: string
  ): Promise<void> {
    await this.prisma.relatedPartyTransaction.update({
      where: { id: transactionId },
      data: {
        hasLocalFile,
        hasMasterFile,
        benchmarkingDone,
        documentationPath,
        notes,
        updatedAt: new Date()
      }
    });

    await this.prisma.auditLogs.create({
      data: {
        userId,
        action: 'TP_DOCUMENTATION_UPDATE',
        entity: 'RelatedPartyTransaction',
        entityId: transactionId,
        newValue: {
          hasLocalFile,
          hasMasterFile,
          benchmarkingDone,
          documentationPath
        }
      }
    });
  }

  /**
   * Gets all transactions for a period
   */
  async getTransactionsForPeriod(
    companyId: string,
    startDate: Date,
    endDate: Date
  ): Promise<RelatedPartyTransactionRecord[]> {
    const transactions = await this.prisma.relatedPartyTransaction.findMany({
      where: {
        companyId,
        transactionDate: { gte: startDate, lte: endDate }
      },
      orderBy: { transactionDate: 'desc' }
    });

    return transactions.map(t => this.mapToRecord(t));
  }

  /**
   * Maps Prisma record to typed record
   */
  private mapToRecord(t: any): RelatedPartyTransactionRecord {
    return {
      id: t.id,
      companyId: t.companyId,
      relatedPartyId: t.relatedPartyId,
      relatedPartyName: t.relatedPartyName,
      relationshipType: t.relationshipType,
      transactionDate: t.transactionDate,
      transactionType: t.transactionType,
      description: t.description,
      transactionAmount: toDecimal(t.transactionAmount),
      armLengthPrice: t.armLengthPrice ? toDecimal(t.armLengthPrice) : null,
      pricingMethod: t.pricingMethod,
      adjustmentRequired: t.adjustmentRequired,
      adjustmentAmount: t.adjustmentAmount ? toDecimal(t.adjustmentAmount) : null,
      hasDocumentation: t.hasLocalFile || t.hasMasterFile
    };
  }
}
```
  </action>
  <verify>
Run `npx tsc --noEmit` to verify TypeScript compiles.
Verify the service has recordTransaction, calculateThresholds, and getComplianceStatus methods.
  </verify>
  <done>
TransferPricingService:
- recordTransaction() with automatic arm's length test
- performArmLengthTest() comparing against arm's length price
- updateArmLengthPrice() with audit trail
- calculateThresholds() for AED 40M/4M/500K checks
- getComplianceStatus() with required actions list
- updateDocumentationStatus() for Master File/Local File tracking
- getTransactionsForPeriod() for period queries
- TP_THRESHOLDS constants for all FTA thresholds
  </done>
</task>

<task type="auto">
  <name>Task 2: Register TransferPricingService in DI Container</name>
  <files>backend/src/di/container.ts, backend/src/di/types.ts, backend/src/services/corporate-tax/index.ts</files>
  <action>
Add TransferPricingService to the dependency injection container.

In `backend/src/di/types.ts`, add:
```typescript
TransferPricingService: Symbol.for('TransferPricingService'),
```

In `backend/src/di/container.ts`, add import and binding:
```typescript
import { TransferPricingService } from '../services/corporate-tax/transfer-pricing.service';

container.bind<TransferPricingService>(TYPES.TransferPricingService)
  .to(TransferPricingService)
  .inSingletonScope();
```

Update `backend/src/services/corporate-tax/index.ts`:
```typescript
// ... existing exports

export {
  TransferPricingService,
  RelatedPartyTransactionRecord,
  TpComplianceStatus
} from './transfer-pricing.service';
```
  </action>
  <verify>
Run `npx tsc --noEmit` to verify container compiles.
  </verify>
  <done>
DI container updated with:
- TYPES.TransferPricingService symbol
- TransferPricingService bound as singleton
- Index file exports TransferPricingService and related types
  </done>
</task>

</tasks>

<verification>
1. Run `npx tsc --noEmit` - all files should compile
2. Verify TP thresholds: AED 40M total, AED 4M per category
3. Verify arm's length test calculates adjustment amount
4. Verify documentation requirements based on group revenue
5. Verify compliance status includes required actions
</verification>

<success_criteria>
- Related party transactions recorded with pricing details (CT-07)
- Arm's length comparison identifies adjustments needed
- TP disclosure thresholds calculated (AED 40M total, AED 4M per category)
- Master File/Local File requirements determined based on AED 200M revenue
- Connected person payments tracked for AED 500K disclosure
- Adjustments from TP flow into CT non-deductible calculation
- Service registered in DI container
</success_criteria>

<output>
After completion, create `.planning/phases/04-corporate-tax-compliance/04-06-SUMMARY.md`
</output>
