---
phase: 04-corporate-tax-compliance
plan: 08
type: execute
wave: 4
depends_on: ["04-01"]
files_modified:
  - backend/src/services/corporate-tax/ct-retention.service.ts
  - backend/src/di/container.ts
autonomous: true

must_haves:
  truths:
    - "CT records retention period enforced at 7 years from period end"
    - "Compliance check reports which periods have complete records"
    - "Warning generated when records approach retention limit"
    - "Audit queries span full 7-year history"
    - "Records cannot be deleted within retention period"
  artifacts:
    - path: "backend/src/services/corporate-tax/ct-retention.service.ts"
      provides: "7-year record retention enforcement (CT-08)"
      exports: ["CtRetentionService"]
      min_lines: 200
  key_links:
    - from: "ct-retention.service.ts"
      to: "ctTaxPeriod"
      via: "Query tax periods for retention compliance"
      pattern: "prisma.ctTaxPeriod"
    - from: "ct-retention.service.ts"
      to: "auditLogs"
      via: "Verify audit trail completeness"
      pattern: "prisma.auditLogs"
---

<objective>
Create the CT Retention Service that enforces 7-year record retention per UAE FTA requirements.

Purpose: CT-08 requires retaining all financial records for 7 years from the end of each tax period. This service checks retention compliance, prevents deletion of records within the retention period, generates warnings when approaching limits, and supports FTA audit queries spanning the full 7-year history.

Output:
- CtRetentionService for retention compliance
- 7-year retention period enforcement
- Compliance status reporting by period
- Retention warning notifications
- Deletion prevention during retention period
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-corporate-tax-compliance/04-RESEARCH.md
@.planning/phases/04-corporate-tax-compliance/04-01-SUMMARY.md

# Dependencies
@backend/src/utils/decimal-math.util.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CT Retention Service</name>
  <files>backend/src/services/corporate-tax/ct-retention.service.ts</files>
  <action>
Create the record retention enforcement service:

```typescript
import { PrismaClient } from '@prisma/client';
import { injectable, inject } from 'inversify';
import { TYPES } from '../../di/types';
import logger from '../logger.service';

/**
 * CT Retention Service
 *
 * Enforces FTA 7-year record retention requirement for Corporate Tax.
 *
 * Key requirements:
 * - All financial records must be retained for 7 years from tax period end
 * - Records include invoices, journals, CT calculations, returns, supporting docs
 * - Records must be available within 30 days of FTA request
 * - Penalties apply for non-compliance
 *
 * Requirement: CT-08
 */

// ============================================================================
// Constants
// ============================================================================

/** FTA-mandated retention period in years */
const RETENTION_YEARS = 7;

/** Warning threshold in months before retention expires */
const WARNING_MONTHS = 6;

// ============================================================================
// Types
// ============================================================================

export interface RetentionStatus {
  companyId: string;
  periodNumber: string;
  periodEnd: Date;
  retentionExpiry: Date;
  daysUntilExpiry: number;
  status: 'ACTIVE' | 'WARNING' | 'EXPIRED';
  recordCounts: RecordCounts;
  missingRecords: string[];
}

export interface RecordCounts {
  invoices: number;
  creditNotes: number;
  journalEntries: number;
  ctCalculations: number;
  relatedPartyTransactions: number;
  auditLogs: number;
}

export interface RetentionComplianceReport {
  companyId: string;
  generatedAt: Date;
  retentionYears: number;
  periods: RetentionStatus[];
  overallStatus: 'COMPLIANT' | 'WARNING' | 'NON_COMPLIANT';
  warnings: string[];
  requiredActions: string[];
}

export interface DeletionCheckResult {
  allowed: boolean;
  reason?: string;
  retentionExpiry?: Date;
}

// ============================================================================
// Service
// ============================================================================

@injectable()
export class CtRetentionService {
  constructor(
    @inject(TYPES.PrismaClient)
    private readonly prisma: PrismaClient
  ) {}

  /**
   * Checks retention compliance for a company
   */
  async checkRetentionCompliance(companyId: string): Promise<RetentionComplianceReport> {
    const now = new Date();
    const warnings: string[] = [];
    const requiredActions: string[] = [];

    // Get all CT periods for the company
    const periods = await this.prisma.ctTaxPeriod.findMany({
      where: { companyId },
      orderBy: { endDate: 'desc' }
    });

    // Get fiscal periods that should have been filed
    const oldestRequiredDate = new Date(now);
    oldestRequiredDate.setFullYear(oldestRequiredDate.getFullYear() - RETENTION_YEARS);

    const periodStatuses: RetentionStatus[] = [];

    for (const period of periods) {
      const status = await this.getPeriodRetentionStatus(companyId, period.id);
      periodStatuses.push(status);

      if (status.status === 'WARNING') {
        warnings.push(
          `Period ${status.periodNumber} retention expires in ${status.daysUntilExpiry} days`
        );
      }

      if (status.missingRecords.length > 0) {
        requiredActions.push(
          `Period ${status.periodNumber}: Missing ${status.missingRecords.join(', ')}`
        );
      }
    }

    // Check for missing periods (gaps in filing history)
    const expectedPeriods = this.getExpectedPeriods(companyId, oldestRequiredDate, now);
    const filedPeriodNumbers = new Set(periods.map(p => p.periodNumber));

    for (const expected of expectedPeriods) {
      if (!filedPeriodNumbers.has(expected)) {
        requiredActions.push(`Missing CT period: ${expected}`);
      }
    }

    // Determine overall status
    let overallStatus: 'COMPLIANT' | 'WARNING' | 'NON_COMPLIANT';
    if (requiredActions.length > 0) {
      overallStatus = 'NON_COMPLIANT';
    } else if (warnings.length > 0) {
      overallStatus = 'WARNING';
    } else {
      overallStatus = 'COMPLIANT';
    }

    logger.info('Retention compliance checked', {
      companyId,
      overallStatus,
      periodsChecked: periodStatuses.length,
      warnings: warnings.length,
      requiredActions: requiredActions.length
    });

    return {
      companyId,
      generatedAt: now,
      retentionYears: RETENTION_YEARS,
      periods: periodStatuses,
      overallStatus,
      warnings,
      requiredActions
    };
  }

  /**
   * Gets retention status for a specific period
   */
  async getPeriodRetentionStatus(
    companyId: string,
    periodId: string
  ): Promise<RetentionStatus> {
    const period = await this.prisma.ctTaxPeriod.findUnique({
      where: { id: periodId }
    });

    if (!period || period.companyId !== companyId) {
      throw new Error('CT period not found');
    }

    const now = new Date();
    const retentionExpiry = this.calculateRetentionExpiry(period.endDate);
    const daysUntilExpiry = Math.floor(
      (retentionExpiry.getTime() - now.getTime()) / (1000 * 60 * 60 * 24)
    );

    // Get record counts for the period
    const recordCounts = await this.getRecordCounts(
      companyId,
      period.startDate,
      period.endDate
    );

    // Check for missing records
    const missingRecords = this.identifyMissingRecords(recordCounts, period);

    // Determine status
    let status: 'ACTIVE' | 'WARNING' | 'EXPIRED';
    if (daysUntilExpiry < 0) {
      status = 'EXPIRED';
    } else if (daysUntilExpiry < WARNING_MONTHS * 30) {
      status = 'WARNING';
    } else {
      status = 'ACTIVE';
    }

    return {
      companyId,
      periodNumber: period.periodNumber,
      periodEnd: period.endDate,
      retentionExpiry,
      daysUntilExpiry,
      status,
      recordCounts,
      missingRecords
    };
  }

  /**
   * Gets record counts for a period
   */
  private async getRecordCounts(
    companyId: string,
    startDate: Date,
    endDate: Date
  ): Promise<RecordCounts> {
    const [invoices, creditNotes, journalEntries, ctCalculations, rpTransactions, auditLogs] =
      await Promise.all([
        this.prisma.invoice.count({
          where: {
            companyId,
            invoiceDate: { gte: startDate, lte: endDate }
          }
        }),
        this.prisma.credit_notes.count({
          where: {
            companyId,
            creditNoteDate: { gte: startDate, lte: endDate }
          }
        }),
        this.prisma.accountingJournalEntry.count({
          where: {
            companyId,
            entryDate: { gte: startDate, lte: endDate }
          }
        }),
        this.prisma.ctTaxPeriod.count({
          where: {
            companyId,
            endDate: { gte: startDate, lte: endDate },
            ctPayable: { not: null } // Has calculation
          }
        }),
        this.prisma.relatedPartyTransaction.count({
          where: {
            companyId,
            transactionDate: { gte: startDate, lte: endDate }
          }
        }),
        this.prisma.auditLogs.count({
          where: {
            createdAt: { gte: startDate, lte: endDate },
            entity: {
              in: ['TaxInvoice', 'CreditNote', 'JournalEntry', 'CtTaxPeriod', 'RelatedPartyTransaction']
            }
          }
        })
      ]);

    return {
      invoices,
      creditNotes,
      journalEntries,
      ctCalculations,
      relatedPartyTransactions: rpTransactions,
      auditLogs
    };
  }

  /**
   * Identifies missing records for a period
   */
  private identifyMissingRecords(counts: RecordCounts, period: any): string[] {
    const missing: string[] = [];

    // Check for minimum expected records
    if (counts.journalEntries === 0) {
      missing.push('journal entries');
    }

    if (period.ctPayable !== null && counts.ctCalculations === 0) {
      missing.push('CT calculation records');
    }

    if (counts.auditLogs < 10) { // Minimum expected audit entries
      missing.push('audit logs (insufficient)');
    }

    return missing;
  }

  /**
   * Checks if a record can be deleted
   */
  async checkDeletionAllowed(
    entityType: string,
    entityId: string,
    recordDate: Date
  ): Promise<DeletionCheckResult> {
    const retentionExpiry = this.calculateRetentionExpiry(recordDate);
    const now = new Date();

    if (now < retentionExpiry) {
      const daysRemaining = Math.floor(
        (retentionExpiry.getTime() - now.getTime()) / (1000 * 60 * 60 * 24)
      );

      return {
        allowed: false,
        reason: `Record is within ${RETENTION_YEARS}-year retention period. ${daysRemaining} days remaining.`,
        retentionExpiry
      };
    }

    return {
      allowed: true,
      retentionExpiry
    };
  }

  /**
   * Prevents deletion of records within retention period (middleware hook)
   */
  async enforceRetention(
    entityType: string,
    entityId: string,
    recordDate: Date
  ): Promise<void> {
    const check = await this.checkDeletionAllowed(entityType, entityId, recordDate);

    if (!check.allowed) {
      logger.warn('Deletion blocked by retention policy', {
        entityType,
        entityId,
        recordDate,
        retentionExpiry: check.retentionExpiry
      });

      throw new Error(
        `Cannot delete ${entityType}: FTA ${RETENTION_YEARS}-year retention requirement. ` +
        `Retention expires on ${check.retentionExpiry?.toISOString().split('T')[0]}`
      );
    }
  }

  /**
   * Gets records approaching retention expiry
   */
  async getExpiringRecords(
    companyId: string,
    withinDays: number = WARNING_MONTHS * 30
  ): Promise<RetentionStatus[]> {
    const now = new Date();
    const warningDate = new Date(now);
    warningDate.setDate(warningDate.getDate() + withinDays);

    // Calculate which period end dates would have retention expiring within warning period
    const expiryStart = new Date(warningDate);
    expiryStart.setFullYear(expiryStart.getFullYear() - RETENTION_YEARS);

    const periods = await this.prisma.ctTaxPeriod.findMany({
      where: {
        companyId,
        endDate: { lte: expiryStart }
      }
    });

    const expiringStatuses: RetentionStatus[] = [];

    for (const period of periods) {
      const status = await this.getPeriodRetentionStatus(companyId, period.id);
      if (status.daysUntilExpiry <= withinDays && status.daysUntilExpiry > 0) {
        expiringStatuses.push(status);
      }
    }

    return expiringStatuses;
  }

  /**
   * Generates retention report for FTA audit
   */
  async generateAuditReport(
    companyId: string,
    fromDate: Date,
    toDate: Date
  ): Promise<{
    companyId: string;
    period: { from: Date; to: Date };
    retentionCompliance: boolean;
    recordSummary: RecordCounts;
    auditTrailComplete: boolean;
    generatedAt: Date;
  }> {
    const recordCounts = await this.getRecordCounts(companyId, fromDate, toDate);

    // Check audit trail completeness
    const auditLogCount = await this.prisma.auditLogs.count({
      where: {
        createdAt: { gte: fromDate, lte: toDate }
      }
    });

    // Estimate expected audit logs (rough heuristic)
    const expectedLogs =
      (recordCounts.invoices * 2) + // Create + potentially update
      (recordCounts.creditNotes * 2) +
      (recordCounts.journalEntries * 2);

    const auditTrailComplete = auditLogCount >= expectedLogs * 0.8; // 80% threshold

    // Check overall retention compliance
    const compliance = await this.checkRetentionCompliance(companyId);
    const retentionCompliance = compliance.overallStatus !== 'NON_COMPLIANT';

    logger.info('FTA audit report generated', {
      companyId,
      fromDate,
      toDate,
      retentionCompliance,
      recordsFound: Object.values(recordCounts).reduce((a, b) => a + b, 0)
    });

    return {
      companyId,
      period: { from: fromDate, to: toDate },
      retentionCompliance,
      recordSummary: recordCounts,
      auditTrailComplete,
      generatedAt: new Date()
    };
  }

  /**
   * Calculates retention expiry date (7 years from period end)
   */
  private calculateRetentionExpiry(periodEnd: Date): Date {
    const expiry = new Date(periodEnd);
    expiry.setFullYear(expiry.getFullYear() + RETENTION_YEARS);
    return expiry;
  }

  /**
   * Gets expected period numbers for a date range
   */
  private getExpectedPeriods(
    companyId: string,
    fromDate: Date,
    toDate: Date
  ): string[] {
    const periods: string[] = [];
    const startYear = fromDate.getFullYear();
    const endYear = toDate.getFullYear();

    for (let year = startYear; year <= endYear; year++) {
      periods.push(`FY${year}`);
    }

    return periods;
  }
}
```
  </action>
  <verify>
Run `npx tsc --noEmit` to verify TypeScript compiles.
Verify the service has checkRetentionCompliance, checkDeletionAllowed, and generateAuditReport methods.
  </verify>
  <done>
CtRetentionService:
- checkRetentionCompliance() with 7-year period check
- getPeriodRetentionStatus() for individual periods
- getRecordCounts() for invoices, journals, RP transactions
- checkDeletionAllowed() preventing deletion within retention
- enforceRetention() middleware hook for blocking deletions
- getExpiringRecords() with 6-month warning threshold
- generateAuditReport() for FTA audit requests
- RETENTION_YEARS constant set to 7
- WARNING_MONTHS constant set to 6
  </done>
</task>

<task type="auto">
  <name>Task 2: Register CtRetentionService in DI Container</name>
  <files>backend/src/di/container.ts, backend/src/di/types.ts, backend/src/services/corporate-tax/index.ts</files>
  <action>
Add CtRetentionService to the dependency injection container.

In `backend/src/di/types.ts`, add:
```typescript
CtRetentionService: Symbol.for('CtRetentionService'),
```

In `backend/src/di/container.ts`, add import and binding:
```typescript
import { CtRetentionService } from '../services/corporate-tax/ct-retention.service';

container.bind<CtRetentionService>(TYPES.CtRetentionService)
  .to(CtRetentionService)
  .inSingletonScope();
```

Update `backend/src/services/corporate-tax/index.ts`:
```typescript
// ... existing exports

export {
  CtRetentionService,
  RetentionStatus,
  RetentionComplianceReport,
  DeletionCheckResult,
  RecordCounts
} from './ct-retention.service';
```
  </action>
  <verify>
Run `npx tsc --noEmit` to verify container compiles.
  </verify>
  <done>
DI container updated with:
- TYPES.CtRetentionService symbol
- CtRetentionService bound as singleton
- Index file exports CtRetentionService and related types
  </done>
</task>

</tasks>

<verification>
1. Run `npx tsc --noEmit` - all files should compile
2. Verify 7-year retention period enforced
3. Verify checkDeletionAllowed blocks deletion within retention
4. Verify warning generated 6 months before expiry
5. Verify audit report includes all record types
</verification>

<success_criteria>
- CT records retention enforced at 7 years from period end (CT-08)
- Compliance report shows which periods have complete records
- Warning generated when records within 6 months of retention limit
- Deletion blocked for records within retention period
- Audit report generated for FTA requests
- Service registered in DI container
</success_criteria>

<output>
After completion, create `.planning/phases/04-corporate-tax-compliance/04-08-SUMMARY.md`
</output>
