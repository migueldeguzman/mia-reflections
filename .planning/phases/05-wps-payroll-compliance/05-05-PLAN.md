---
phase: 05-wps-payroll-compliance
plan: 05
type: execute
wave: 3
depends_on: ["05-01", "05-03", "05-04"]
files_modified:
  - web-erp-app/backend/src/services/payroll/payroll-cycle.service.ts
  - web-erp-app/backend/src/controllers/payroll/payroll-cycle.controller.ts
  - web-erp-app/backend/src/routes/payroll/payroll.routes.ts
autonomous: true

must_haves:
  truths:
    - "Payroll cycles follow state machine (DRAFT -> PROCESSING -> READY -> SUBMITTED -> ACCEPTED/REJECTED -> COMPLETED)"
    - "Only valid state transitions allowed"
    - "Employee salary records can be added/edited in DRAFT status only"
    - "SIF generation moves cycle to READY status"
    - "WPS submission recorded with timestamp and status"
  artifacts:
    - path: "web-erp-app/backend/src/services/payroll/payroll-cycle.service.ts"
      provides: "Payroll cycle state management service"
      exports: ["PayrollCycleService", "createPayrollCycle", "transitionCycleStatus"]
    - path: "web-erp-app/backend/src/controllers/payroll/payroll-cycle.controller.ts"
      provides: "Payroll cycle API controller"
      exports: ["PayrollCycleController"]
    - path: "web-erp-app/backend/src/routes/payroll/payroll.routes.ts"
      provides: "Payroll API routes"
      exports: ["payrollRoutes"]
  key_links:
    - from: "payroll-cycle.service.ts"
      to: "PayrollCycle model"
      via: "Prisma operations"
      pattern: "prisma\\.payrollCycle\\."
    - from: "payroll-cycle.service.ts"
      to: "WpsSifService"
      via: "DI injection for SIF generation"
      pattern: "TYPES\\.WpsSifService"
---

<objective>
Create payroll cycle management service with state machine for tracking salary processing from draft through WPS submission to completion.

Purpose: WPS-04 (Salary cycle management) - Enable tracking and management of payroll cycles with proper status transitions.

Output: PayrollCycleService with full CRUD and state management, controller, and API routes.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-wps-payroll-compliance/05-RESEARCH.md
@.planning/phases/05-wps-payroll-compliance/05-01-SUMMARY.md
@.planning/phases/05-wps-payroll-compliance/05-04-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PayrollCycleService</name>
  <files>web-erp-app/backend/src/services/payroll/payroll-cycle.service.ts</files>
  <action>
Create PayrollCycleService for payroll cycle management:

```typescript
/**
 * Payroll Cycle Service
 *
 * Manages salary payment cycles with state machine for WPS processing.
 *
 * State Machine:
 * DRAFT -> PROCESSING -> READY -> SUBMITTED -> ACCEPTED/REJECTED -> COMPLETED
 *
 * WPS-04: Salary cycle management
 *
 * @module PayrollCycleService
 */

import { PrismaClient } from '@prisma/client';
import { Decimal } from '@prisma/client/runtime/library';
import { injectable, inject } from 'inversify';
import { TYPES } from '../../config/types';
import logger from '../logger.service';
import { WpsSifService } from './wps-sif.service';
import { BankRoutingService } from './bank-routing.service';
import { validateUaeIban } from '../../utils/iban-validation.util';
import {
  PayrollCycleStatus,
  CYCLE_TRANSITIONS,
} from '../../types/payroll/wps.types';

// ============================================
// TYPES
// ============================================

export interface PayrollCycleContext {
  companyId: string;
  userId: string;
}

export interface CreatePayrollCycleInput {
  salaryMonth: string;        // MMYYYY format
  payPeriodStart: Date;
  payPeriodEnd: Date;
  notes?: string;
}

export interface AddEmployeeToPayrollInput {
  employeeId: string;
  personCode: string;
  employeeName: string;
  iban: string;
  basicSalary: Decimal;
  housingAllowance?: Decimal;
  transportAllowance?: Decimal;
  otherAllowances?: Decimal;
  overtime?: Decimal;
  deductions?: Decimal;
  totalDays?: number;
  leaveDays?: number;
  unpaidLeaveDays?: number;
}

export interface PayrollCycleSummary {
  id: string;
  cycleNumber: string;
  salaryMonth: string;
  status: PayrollCycleStatus;
  employeeCount: number;
  totalAmount: Decimal;
  payPeriodStart: Date;
  payPeriodEnd: Date;
  sifFileName: string | null;
  sifGeneratedAt: Date | null;
  submittedAt: Date | null;
  acceptedAt: Date | null;
  completedAt: Date | null;
}

// ============================================
// SERVICE
// ============================================

@injectable()
export class PayrollCycleService {
  constructor(
    @inject(TYPES.PrismaClient) private prisma: PrismaClient,
    @inject(TYPES.WpsSifService) private wpsSifService: WpsSifService,
    @inject(TYPES.BankRoutingService) private bankRoutingService: BankRoutingService
  ) {}

  /**
   * Create a new payroll cycle
   *
   * @param context - User context
   * @param input - Cycle creation input
   * @returns Created payroll cycle
   */
  async createPayrollCycle(
    context: PayrollCycleContext,
    input: CreatePayrollCycleInput
  ): Promise<PayrollCycleSummary> {
    // Generate cycle number (YYYY-MM format)
    const year = input.salaryMonth.substring(2);
    const month = input.salaryMonth.substring(0, 2);
    const cycleNumber = `${year}-${month}`;

    // Check for duplicate cycle
    const existing = await this.prisma.payrollCycle.findFirst({
      where: {
        companyId: context.companyId,
        cycleNumber,
      },
    });

    if (existing) {
      throw new Error(`Payroll cycle ${cycleNumber} already exists`);
    }

    const cycle = await this.prisma.payrollCycle.create({
      data: {
        companyId: context.companyId,
        cycleNumber,
        salaryMonth: input.salaryMonth,
        payPeriodStart: input.payPeriodStart,
        payPeriodEnd: input.payPeriodEnd,
        status: PayrollCycleStatus.DRAFT,
        notes: input.notes,
        createdById: context.userId,
      },
    });

    logger.audit('[PayrollCycle] Cycle created', {
      userId: context.userId,
      companyId: context.companyId,
      cycleNumber,
    });

    return this.mapToSummary(cycle);
  }

  /**
   * Get payroll cycle by ID
   *
   * @param context - User context
   * @param cycleId - Cycle ID
   * @returns Payroll cycle summary
   */
  async getPayrollCycle(
    context: PayrollCycleContext,
    cycleId: string
  ): Promise<PayrollCycleSummary> {
    const cycle = await this.prisma.payrollCycle.findUnique({
      where: { id: cycleId },
    });

    if (!cycle) {
      throw new Error('Payroll cycle not found');
    }

    if (cycle.companyId !== context.companyId) {
      throw new Error('Access denied: Cannot access payroll from other companies');
    }

    return this.mapToSummary(cycle);
  }

  /**
   * List payroll cycles for company
   *
   * @param context - User context
   * @param options - List options
   * @returns Array of payroll cycle summaries
   */
  async listPayrollCycles(
    context: PayrollCycleContext,
    options: { status?: PayrollCycleStatus; limit?: number; offset?: number } = {}
  ): Promise<{ cycles: PayrollCycleSummary[]; total: number }> {
    const where: any = { companyId: context.companyId };
    if (options.status) {
      where.status = options.status;
    }

    const [cycles, total] = await Promise.all([
      this.prisma.payrollCycle.findMany({
        where,
        orderBy: { createdAt: 'desc' },
        take: options.limit || 20,
        skip: options.offset || 0,
      }),
      this.prisma.payrollCycle.count({ where }),
    ]);

    return {
      cycles: cycles.map(c => this.mapToSummary(c)),
      total,
    };
  }

  /**
   * Add employee to payroll cycle
   *
   * Can only add employees when cycle is in DRAFT status.
   *
   * @param context - User context
   * @param cycleId - Cycle ID
   * @param input - Employee salary data
   * @returns Created salary record
   */
  async addEmployeeToPayroll(
    context: PayrollCycleContext,
    cycleId: string,
    input: AddEmployeeToPayrollInput
  ) {
    const cycle = await this.prisma.payrollCycle.findUnique({
      where: { id: cycleId },
    });

    if (!cycle) {
      throw new Error('Payroll cycle not found');
    }

    if (cycle.companyId !== context.companyId) {
      throw new Error('Access denied');
    }

    if (cycle.status !== PayrollCycleStatus.DRAFT) {
      throw new Error(`Cannot add employees when cycle is in ${cycle.status} status`);
    }

    // Validate IBAN
    const ibanValidation = validateUaeIban(input.iban);
    if (!ibanValidation.isValid) {
      throw new Error(`Invalid IBAN: ${ibanValidation.errors[0]?.message}`);
    }

    // Get routing code for IBAN
    const routingResult = await this.bankRoutingService.getRoutingCodeForIban(input.iban);
    if (!routingResult.found) {
      throw new Error(`Cannot find WPS routing code: ${routingResult.error}`);
    }

    // Calculate net salary
    const basicSalary = new Decimal(input.basicSalary);
    const housingAllowance = new Decimal(input.housingAllowance || 0);
    const transportAllowance = new Decimal(input.transportAllowance || 0);
    const otherAllowances = new Decimal(input.otherAllowances || 0);
    const overtime = new Decimal(input.overtime || 0);
    const deductions = new Decimal(input.deductions || 0);

    const netSalary = basicSalary
      .add(housingAllowance)
      .add(transportAllowance)
      .add(otherAllowances)
      .add(overtime)
      .sub(deductions);

    const record = await this.prisma.employeeSalaryRecord.create({
      data: {
        payrollCycleId: cycleId,
        employeeId: input.employeeId,
        personCode: input.personCode,
        employeeName: input.employeeName,
        iban: ibanValidation.iban,
        bankRoutingCode: routingResult.routingCode!,
        basicSalary,
        housingAllowance,
        transportAllowance,
        otherAllowances,
        overtime,
        deductions,
        netSalary,
        totalDays: input.totalDays || 30,
        leaveDays: input.leaveDays || 0,
        unpaidLeaveDays: input.unpaidLeaveDays || 0,
      },
    });

    // Update cycle totals
    await this.updateCycleTotals(cycleId);

    logger.audit('[PayrollCycle] Employee added to payroll', {
      userId: context.userId,
      companyId: context.companyId,
      cycleId,
      employeeId: input.employeeId,
    });

    return record;
  }

  /**
   * Transition payroll cycle status
   *
   * Validates transition is allowed per state machine.
   *
   * @param context - User context
   * @param cycleId - Cycle ID
   * @param newStatus - Target status
   * @returns Updated cycle
   */
  async transitionCycleStatus(
    context: PayrollCycleContext,
    cycleId: string,
    newStatus: PayrollCycleStatus
  ): Promise<PayrollCycleSummary> {
    const cycle = await this.prisma.payrollCycle.findUnique({
      where: { id: cycleId },
    });

    if (!cycle) {
      throw new Error('Payroll cycle not found');
    }

    if (cycle.companyId !== context.companyId) {
      throw new Error('Access denied');
    }

    // Validate transition
    const currentStatus = cycle.status as PayrollCycleStatus;
    const allowedTransitions = CYCLE_TRANSITIONS[currentStatus] || [];

    if (!allowedTransitions.includes(newStatus)) {
      throw new Error(
        `Invalid transition: Cannot move from ${currentStatus} to ${newStatus}. ` +
        `Allowed: ${allowedTransitions.join(', ')}`
      );
    }

    // Build update data with timestamp fields
    const updateData: any = {
      status: newStatus,
      updatedAt: new Date(),
    };

    switch (newStatus) {
      case PayrollCycleStatus.SUBMITTED:
        updateData.submittedAt = new Date();
        break;
      case PayrollCycleStatus.ACCEPTED:
        updateData.acceptedAt = new Date();
        break;
      case PayrollCycleStatus.REJECTED:
        updateData.rejectedAt = new Date();
        break;
      case PayrollCycleStatus.COMPLETED:
        updateData.completedAt = new Date();
        break;
    }

    const updated = await this.prisma.payrollCycle.update({
      where: { id: cycleId },
      data: updateData,
    });

    logger.audit('[PayrollCycle] Status transitioned', {
      userId: context.userId,
      companyId: context.companyId,
      cycleId,
      from: currentStatus,
      to: newStatus,
    });

    return this.mapToSummary(updated);
  }

  /**
   * Generate SIF file for payroll cycle
   *
   * Transitions cycle from DRAFT/PROCESSING to READY.
   *
   * @param context - User context
   * @param cycleId - Cycle ID
   * @returns SIF generation result
   */
  async generateSif(context: PayrollCycleContext, cycleId: string) {
    const cycle = await this.prisma.payrollCycle.findUnique({
      where: { id: cycleId },
    });

    if (!cycle) {
      throw new Error('Payroll cycle not found');
    }

    if (cycle.companyId !== context.companyId) {
      throw new Error('Access denied');
    }

    // Can only generate SIF from DRAFT or PROCESSING
    if (![PayrollCycleStatus.DRAFT, PayrollCycleStatus.PROCESSING].includes(
      cycle.status as PayrollCycleStatus
    )) {
      throw new Error(`Cannot generate SIF when cycle is in ${cycle.status} status`);
    }

    // Transition to PROCESSING if in DRAFT
    if (cycle.status === PayrollCycleStatus.DRAFT) {
      await this.transitionCycleStatus(context, cycleId, PayrollCycleStatus.PROCESSING);
    }

    // Generate SIF (this also transitions to READY)
    const result = await this.wpsSifService.generateSifFile(context, cycleId);

    return result;
  }

  /**
   * Record WPS submission
   *
   * @param context - User context
   * @param cycleId - Cycle ID
   * @param submissionData - Submission details
   * @returns Created submission record
   */
  async recordWpsSubmission(
    context: PayrollCycleContext,
    cycleId: string,
    submissionData: { sifFileName: string; sifContent?: string }
  ) {
    const cycle = await this.prisma.payrollCycle.findUnique({
      where: { id: cycleId },
    });

    if (!cycle) {
      throw new Error('Payroll cycle not found');
    }

    if (cycle.status !== PayrollCycleStatus.READY) {
      throw new Error('Cycle must be in READY status to submit');
    }

    // Create submission record
    const submission = await this.prisma.wpsSubmission.create({
      data: {
        payrollCycleId: cycleId,
        companyId: context.companyId,
        sifFileName: submissionData.sifFileName,
        sifContent: submissionData.sifContent,
        employeeCount: cycle.employeeCount,
        totalAmount: cycle.totalAmount,
        submittedAt: new Date(),
        submittedById: context.userId,
        status: 'PENDING',
      },
    });

    // Transition cycle to SUBMITTED
    await this.transitionCycleStatus(context, cycleId, PayrollCycleStatus.SUBMITTED);

    logger.audit('[PayrollCycle] WPS submission recorded', {
      userId: context.userId,
      companyId: context.companyId,
      cycleId,
      submissionId: submission.id,
    });

    return submission;
  }

  /**
   * Record WPS acceptance/rejection
   *
   * @param context - User context
   * @param submissionId - Submission ID
   * @param accepted - Whether submission was accepted
   * @param rejectionReason - Reason if rejected
   */
  async recordWpsResponse(
    context: PayrollCycleContext,
    submissionId: string,
    accepted: boolean,
    rejectionReason?: string
  ) {
    const submission = await this.prisma.wpsSubmission.findUnique({
      where: { id: submissionId },
      include: { payrollCycle: true },
    });

    if (!submission) {
      throw new Error('WPS submission not found');
    }

    if (submission.companyId !== context.companyId) {
      throw new Error('Access denied');
    }

    // Update submission
    await this.prisma.wpsSubmission.update({
      where: { id: submissionId },
      data: {
        status: accepted ? 'ACCEPTED' : 'REJECTED',
        acceptedAt: accepted ? new Date() : null,
        rejectedAt: !accepted ? new Date() : null,
        rejectionReason: rejectionReason || null,
      },
    });

    // Transition cycle status
    const newStatus = accepted
      ? PayrollCycleStatus.ACCEPTED
      : PayrollCycleStatus.REJECTED;

    await this.transitionCycleStatus(
      context,
      submission.payrollCycleId,
      newStatus
    );

    logger.audit('[PayrollCycle] WPS response recorded', {
      userId: context.userId,
      companyId: context.companyId,
      submissionId,
      accepted,
      rejectionReason,
    });
  }

  /**
   * Get salary records for a payroll cycle
   */
  async getSalaryRecords(context: PayrollCycleContext, cycleId: string) {
    const cycle = await this.prisma.payrollCycle.findUnique({
      where: { id: cycleId },
    });

    if (!cycle || cycle.companyId !== context.companyId) {
      throw new Error('Payroll cycle not found or access denied');
    }

    return this.prisma.employeeSalaryRecord.findMany({
      where: { payrollCycleId: cycleId },
      orderBy: { employeeName: 'asc' },
    });
  }

  /**
   * Update cycle totals after adding/removing employees
   */
  private async updateCycleTotals(cycleId: string): Promise<void> {
    const aggregates = await this.prisma.employeeSalaryRecord.aggregate({
      where: { payrollCycleId: cycleId, isActive: true },
      _count: true,
      _sum: { netSalary: true },
    });

    await this.prisma.payrollCycle.update({
      where: { id: cycleId },
      data: {
        employeeCount: aggregates._count,
        totalAmount: aggregates._sum.netSalary || new Decimal(0),
        updatedAt: new Date(),
      },
    });
  }

  /**
   * Map Prisma model to summary DTO
   */
  private mapToSummary(cycle: any): PayrollCycleSummary {
    return {
      id: cycle.id,
      cycleNumber: cycle.cycleNumber,
      salaryMonth: cycle.salaryMonth,
      status: cycle.status as PayrollCycleStatus,
      employeeCount: cycle.employeeCount,
      totalAmount: cycle.totalAmount,
      payPeriodStart: cycle.payPeriodStart,
      payPeriodEnd: cycle.payPeriodEnd,
      sifFileName: cycle.sifFileName,
      sifGeneratedAt: cycle.sifGeneratedAt,
      submittedAt: cycle.submittedAt,
      acceptedAt: cycle.acceptedAt,
      completedAt: cycle.completedAt,
    };
  }
}
```
  </action>
  <verify>
    - `npx tsc --noEmit` compiles successfully
    - State transitions follow CYCLE_TRANSITIONS rules
    - Employee addition validates IBAN and looks up routing code
  </verify>
  <done>PayrollCycleService with state machine and CRUD operations</done>
</task>

<task type="auto">
  <name>Task 2: Create PayrollCycleController</name>
  <files>web-erp-app/backend/src/controllers/payroll/payroll-cycle.controller.ts</files>
  <action>
Create controller for payroll cycle API endpoints:

```typescript
/**
 * Payroll Cycle Controller
 *
 * Handles HTTP requests for payroll cycle management.
 *
 * @module PayrollCycleController
 */

import { Request, Response } from 'express';
import { injectable, inject } from 'inversify';
import { TYPES } from '../../config/types';
import { PayrollCycleService } from '../../services/payroll/payroll-cycle.service';
import { AuthRequest } from '../../types/express';
import logger from '../../services/logger.service';

@injectable()
export class PayrollCycleController {
  constructor(
    @inject(TYPES.PayrollCycleService) private payrollCycleService: PayrollCycleService
  ) {}

  /**
   * POST /payroll/cycles
   * Create a new payroll cycle
   */
  createCycle = async (req: Request, res: Response) => {
    try {
      const authReq = req as AuthRequest;
      const { companyId } = authReq.query;
      const userId = authReq.user?.id;

      if (!companyId || !userId) {
        return res.status(400).json({ success: false, message: 'Missing company or user' });
      }

      const { salaryMonth, payPeriodStart, payPeriodEnd, notes } = req.body;

      const cycle = await this.payrollCycleService.createPayrollCycle(
        { companyId: companyId as string, userId },
        {
          salaryMonth,
          payPeriodStart: new Date(payPeriodStart),
          payPeriodEnd: new Date(payPeriodEnd),
          notes,
        }
      );

      res.status(201).json({ success: true, data: cycle });
    } catch (error: any) {
      logger.error('[PayrollController] Error creating cycle:', error);
      res.status(500).json({ success: false, message: error.message || 'Failed to create payroll cycle' });
    }
  };

  /**
   * GET /payroll/cycles/:id
   * Get payroll cycle by ID
   */
  getCycle = async (req: Request, res: Response) => {
    try {
      const authReq = req as AuthRequest;
      const { companyId } = authReq.query;
      const userId = authReq.user?.id;
      const { id } = req.params;

      const cycle = await this.payrollCycleService.getPayrollCycle(
        { companyId: companyId as string, userId: userId! },
        id
      );

      res.json({ success: true, data: cycle });
    } catch (error: any) {
      logger.error('[PayrollController] Error getting cycle:', error);
      res.status(500).json({ success: false, message: error.message || 'Failed to get payroll cycle' });
    }
  };

  /**
   * GET /payroll/cycles
   * List payroll cycles
   */
  listCycles = async (req: Request, res: Response) => {
    try {
      const authReq = req as AuthRequest;
      const { companyId, status, limit, offset } = authReq.query;
      const userId = authReq.user?.id;

      const result = await this.payrollCycleService.listPayrollCycles(
        { companyId: companyId as string, userId: userId! },
        {
          status: status as any,
          limit: limit ? parseInt(limit as string, 10) : undefined,
          offset: offset ? parseInt(offset as string, 10) : undefined,
        }
      );

      res.json({ success: true, data: result.cycles, total: result.total });
    } catch (error: any) {
      logger.error('[PayrollController] Error listing cycles:', error);
      res.status(500).json({ success: false, message: 'Failed to list payroll cycles' });
    }
  };

  /**
   * POST /payroll/cycles/:id/employees
   * Add employee to payroll cycle
   */
  addEmployee = async (req: Request, res: Response) => {
    try {
      const authReq = req as AuthRequest;
      const { companyId } = authReq.query;
      const userId = authReq.user?.id;
      const { id } = req.params;

      const record = await this.payrollCycleService.addEmployeeToPayroll(
        { companyId: companyId as string, userId: userId! },
        id,
        req.body
      );

      res.status(201).json({ success: true, data: record });
    } catch (error: any) {
      logger.error('[PayrollController] Error adding employee:', error);
      res.status(500).json({ success: false, message: error.message || 'Failed to add employee' });
    }
  };

  /**
   * GET /payroll/cycles/:id/employees
   * Get salary records for a cycle
   */
  getSalaryRecords = async (req: Request, res: Response) => {
    try {
      const authReq = req as AuthRequest;
      const { companyId } = authReq.query;
      const userId = authReq.user?.id;
      const { id } = req.params;

      const records = await this.payrollCycleService.getSalaryRecords(
        { companyId: companyId as string, userId: userId! },
        id
      );

      res.json({ success: true, data: records });
    } catch (error: any) {
      logger.error('[PayrollController] Error getting salary records:', error);
      res.status(500).json({ success: false, message: 'Failed to get salary records' });
    }
  };

  /**
   * POST /payroll/cycles/:id/transition
   * Transition cycle status
   */
  transitionStatus = async (req: Request, res: Response) => {
    try {
      const authReq = req as AuthRequest;
      const { companyId } = authReq.query;
      const userId = authReq.user?.id;
      const { id } = req.params;
      const { status } = req.body;

      const cycle = await this.payrollCycleService.transitionCycleStatus(
        { companyId: companyId as string, userId: userId! },
        id,
        status
      );

      res.json({ success: true, data: cycle });
    } catch (error: any) {
      logger.error('[PayrollController] Error transitioning status:', error);
      res.status(500).json({ success: false, message: error.message || 'Failed to transition status' });
    }
  };

  /**
   * POST /payroll/cycles/:id/generate-sif
   * Generate SIF file for cycle
   */
  generateSif = async (req: Request, res: Response) => {
    try {
      const authReq = req as AuthRequest;
      const { companyId } = authReq.query;
      const userId = authReq.user?.id;
      const { id } = req.params;

      const result = await this.payrollCycleService.generateSif(
        { companyId: companyId as string, userId: userId! },
        id
      );

      res.json({ success: true, data: result });
    } catch (error: any) {
      logger.error('[PayrollController] Error generating SIF:', error);
      res.status(500).json({ success: false, message: error.message || 'Failed to generate SIF' });
    }
  };

  /**
   * POST /payroll/cycles/:id/submit
   * Record WPS submission
   */
  recordSubmission = async (req: Request, res: Response) => {
    try {
      const authReq = req as AuthRequest;
      const { companyId } = authReq.query;
      const userId = authReq.user?.id;
      const { id } = req.params;
      const { sifFileName, sifContent } = req.body;

      const submission = await this.payrollCycleService.recordWpsSubmission(
        { companyId: companyId as string, userId: userId! },
        id,
        { sifFileName, sifContent }
      );

      res.status(201).json({ success: true, data: submission });
    } catch (error: any) {
      logger.error('[PayrollController] Error recording submission:', error);
      res.status(500).json({ success: false, message: error.message || 'Failed to record submission' });
    }
  };
}
```
  </action>
  <verify>
    - Controller compiles without errors
    - All endpoints extract context from request
    - Error handling returns appropriate HTTP status codes
  </verify>
  <done>PayrollCycleController with all CRUD and action endpoints</done>
</task>

<task type="auto">
  <name>Task 3: Create payroll routes and register DI</name>
  <files>
    web-erp-app/backend/src/routes/payroll/payroll.routes.ts
    web-erp-app/backend/src/config/types.ts
    web-erp-app/backend/src/config/container.ts
    web-erp-app/backend/src/index.ts
  </files>
  <action>
1. Create payroll routes:
   ```typescript
   /**
    * Payroll Routes
    *
    * API endpoints for payroll and WPS management.
    */

   import { Router } from 'express';
   import { container } from '../../config/container';
   import { TYPES } from '../../config/types';
   import { PayrollCycleController } from '../../controllers/payroll/payroll-cycle.controller';
   import { authenticateJWT } from '../../middleware/auth.middleware';
   import { requirePermission } from '../../middleware/permission.middleware';

   const router = Router();
   const controller = container.get<PayrollCycleController>(TYPES.PayrollCycleController);

   // Payroll cycles
   router.post('/cycles',
     authenticateJWT,
     requirePermission('payroll.create'),
     controller.createCycle
   );

   router.get('/cycles',
     authenticateJWT,
     requirePermission('payroll.view'),
     controller.listCycles
   );

   router.get('/cycles/:id',
     authenticateJWT,
     requirePermission('payroll.view'),
     controller.getCycle
   );

   router.post('/cycles/:id/employees',
     authenticateJWT,
     requirePermission('payroll.edit'),
     controller.addEmployee
   );

   router.get('/cycles/:id/employees',
     authenticateJWT,
     requirePermission('payroll.view'),
     controller.getSalaryRecords
   );

   router.post('/cycles/:id/transition',
     authenticateJWT,
     requirePermission('payroll.edit'),
     controller.transitionStatus
   );

   router.post('/cycles/:id/generate-sif',
     authenticateJWT,
     requirePermission('payroll.process'),
     controller.generateSif
   );

   router.post('/cycles/:id/submit',
     authenticateJWT,
     requirePermission('payroll.submit'),
     controller.recordSubmission
   );

   export default router;
   ```

2. Add to types.ts:
   ```typescript
   PayrollCycleService: Symbol.for('PayrollCycleService'),
   PayrollCycleController: Symbol.for('PayrollCycleController'),
   ```

3. Register in container.ts:
   ```typescript
   import { PayrollCycleService } from '../services/payroll/payroll-cycle.service';
   import { PayrollCycleController } from '../controllers/payroll/payroll-cycle.controller';

   container.bind<PayrollCycleService>(TYPES.PayrollCycleService)
     .to(PayrollCycleService)
     .inSingletonScope();

   container.bind<PayrollCycleController>(TYPES.PayrollCycleController)
     .to(PayrollCycleController)
     .inSingletonScope();
   ```

4. Register routes in index.ts:
   ```typescript
   import payrollRoutes from './routes/payroll/payroll.routes';

   app.use('/api/payroll', payrollRoutes);
   ```
  </action>
  <verify>
    - Routes register without errors
    - `npm run dev` starts successfully
    - `curl http://localhost:3000/api/payroll/cycles` returns 401 (auth required)
  </verify>
  <done>Payroll routes registered with authentication and permissions</done>
</task>

</tasks>

<verification>
1. Service compiles: `npx tsc --noEmit`
2. State machine enforced: DRAFT can only transition to PROCESSING or CANCELLED
3. Employee addition validates IBAN and gets routing code
4. SIF generation transitions cycle to READY
5. API endpoints respond correctly (with authentication)
</verification>

<success_criteria>
1. PayrollCycleService implements full state machine with valid transitions
2. Employee addition in DRAFT status only
3. IBAN validated before adding employee
4. Routing code looked up from BankRoutingService
5. SIF generation moves cycle from DRAFT/PROCESSING to READY
6. WPS submission moves cycle to SUBMITTED
7. All endpoints secured with authentication and permissions
8. Audit logging for all state changes
</success_criteria>

<output>
After completion, create `.planning/phases/05-wps-payroll-compliance/05-05-SUMMARY.md`
</output>
