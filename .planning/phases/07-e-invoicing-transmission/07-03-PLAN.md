---
phase: 07-e-invoicing-transmission
plan: 03
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - web-erp-app/backend/src/services/einvoice/transmission/credential-store.service.ts
  - web-erp-app/backend/src/services/einvoice/transmission/oauth-token.service.ts
autonomous: true

must_haves:
  truths:
    - "Credentials encrypted with AES-256-GCM before storage"
    - "Credential values never exposed in logs or responses"
    - "OAuth tokens auto-refresh before expiry"
    - "MFA required for credential modifications"
  artifacts:
    - path: "web-erp-app/backend/src/services/einvoice/transmission/credential-store.service.ts"
      provides: "Encrypted credential storage"
      exports: ["CredentialStoreService"]
      min_lines: 200
    - path: "web-erp-app/backend/src/services/einvoice/transmission/oauth-token.service.ts"
      provides: "OAuth token management"
      exports: ["OAuthTokenService"]
  key_links:
    - from: "credential-store.service.ts"
      to: "einvoice_credentials"
      via: "prisma operations"
      pattern: "prisma\\.einvoice_credentials"
    - from: "oauth-token.service.ts"
      to: "credential-store.service.ts"
      via: "service injection"
      pattern: "CredentialStoreService"
---

<objective>
Create secure credential storage service with AES-256-GCM encryption for ASP/DCTCE credentials, and OAuth token management with automatic refresh.

Purpose: Superuser access framework compliance - credentials must be encrypted at rest, never logged, and require MFA for modifications.

Output: CredentialStoreService and OAuthTokenService for secure credential management.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-e-invoicing-transmission/07-CONTEXT.md
@.planning/phases/07-e-invoicing-transmission/07-RESEARCH.md
@.planning/phases/07-e-invoicing-transmission/07-01-SUMMARY.md
@web-erp-app/backend/src/types/einvoice-transmission.types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create credential store service with AES-256-GCM encryption</name>
  <files>web-erp-app/backend/src/services/einvoice/transmission/credential-store.service.ts</files>
  <action>
Create the directory and credential store service:

```bash
mkdir -p web-erp-app/backend/src/services/einvoice/transmission
```

```typescript
/**
 * Credential Store Service
 * Phase: 07-e-invoicing-transmission
 *
 * Secure storage for ASP/DCTCE credentials with AES-256-GCM encryption.
 * Follows superuser access framework requirements.
 *
 * Security features:
 * - AES-256-GCM encryption for secrets
 * - Credentials never logged or exposed
 * - MFA required for modifications
 * - Audit trail for all credential changes
 *
 * @module credential-store.service
 */

import { injectable, inject } from 'inversify';
import { PrismaClient, einvoice_credentials, TransmissionMode, TransmissionEnvironment } from '@prisma/client';
import {
  createCipheriv,
  createDecipheriv,
  randomBytes,
  scryptSync,
} from 'crypto';
import { TYPES } from '../../../di/types';
import logger from '../../logger.service';
import {
  ProviderCredentials,
  CREDENTIAL_ENCRYPTION,
  TransmissionMode as TxMode,
} from '../../../types/einvoice-transmission.types';

// ============================================================================
// TYPES
// ============================================================================

/**
 * Credential status (safe to expose, no secrets)
 */
export interface CredentialStatus {
  companyId: string;
  transmissionMode: TransmissionMode;
  activeEnvironment: TransmissionEnvironment;
  isConfigured: boolean;
  isValid: boolean;
  lastValidatedAt: Date | null;
  lastConnectionTestAt: Date | null;
  lastConnectionSuccess: boolean | null;
  configuredAt: Date | null;
  configuredBy: string | null;
}

/**
 * Credential update input (secrets will be encrypted)
 */
export interface CredentialUpdateInput {
  transmissionMode?: TransmissionMode;
  activeEnvironment?: TransmissionEnvironment;

  // DCTCE credentials
  dctceClientId?: string;
  dctceClientSecret?: string;      // Will be encrypted
  dctceTokenEndpoint?: string;
  dctceApiEndpoint?: string;

  // ASP credentials
  aspApiKey?: string;              // Will be encrypted
  aspEndpoint?: string;
  aspIdentifier?: string;
  aspProviderName?: string;
}

/**
 * Decrypted credentials (only for internal use)
 */
export interface DecryptedCredentials {
  dctceClientId?: string;
  dctceClientSecret?: string;
  dctceTokenEndpoint?: string;
  dctceApiEndpoint?: string;
  aspApiKey?: string;
  aspEndpoint?: string;
  aspIdentifier?: string;
  aspProviderName?: string;

  // Cached tokens
  accessToken?: string;
  tokenExpiresAt?: Date;
  refreshToken?: string;
}

// ============================================================================
// SERVICE
// ============================================================================

@injectable()
export class CredentialStoreService {
  private readonly encryptionKey: Buffer;

  constructor(
    @inject(TYPES.PrismaClient) private prisma: PrismaClient,
    @inject(TYPES.ComplianceAuditService) private auditService: any
  ) {
    // Derive encryption key from environment variable
    const keySource = process.env.CREDENTIAL_ENCRYPTION_KEY;
    if (!keySource) {
      throw new Error('CREDENTIAL_ENCRYPTION_KEY environment variable required');
    }

    // Use scrypt to derive a 256-bit key
    this.encryptionKey = scryptSync(keySource, 'einvoice-credentials', CREDENTIAL_ENCRYPTION.KEY_LENGTH);
  }

  // ============================================================================
  // PUBLIC METHODS
  // ============================================================================

  /**
   * Get credential status (safe - no secrets exposed)
   */
  async getCredentialStatus(companyId: string): Promise<CredentialStatus | null> {
    const credentials = await this.prisma.einvoice_credentials.findUnique({
      where: { companyId },
      include: {
        configuredBy: {
          select: { email: true },
        },
      },
    });

    if (!credentials) {
      return null;
    }

    // Return status without any secrets
    return {
      companyId: credentials.companyId,
      transmissionMode: credentials.transmissionMode,
      activeEnvironment: credentials.activeEnvironment,
      isConfigured: this.isConfigured(credentials),
      isValid: credentials.isValid,
      lastValidatedAt: credentials.lastValidatedAt,
      lastConnectionTestAt: credentials.lastConnectionTestAt,
      lastConnectionSuccess: credentials.lastConnectionSuccess,
      configuredAt: credentials.configuredAt,
      configuredBy: credentials.configuredBy?.email || null,
    };
  }

  /**
   * Set credentials (MFA required - must be verified by caller)
   *
   * SECURITY: This method assumes MFA has been verified by middleware
   */
  async setCredentials(
    companyId: string,
    input: CredentialUpdateInput,
    userId: string,
    mfaVerified: boolean
  ): Promise<CredentialStatus> {
    // Enforce MFA requirement
    if (!mfaVerified) {
      logger.security('[CredentialStore] MFA not verified for credential update', {
        companyId,
        userId,
      });
      throw new Error('MFA verification required for credential changes');
    }

    // Generate new IV for encryption
    const iv = randomBytes(CREDENTIAL_ENCRYPTION.IV_LENGTH);

    // Encrypt sensitive fields
    const encryptedData: Partial<einvoice_credentials> = {
      transmissionMode: input.transmissionMode,
      activeEnvironment: input.activeEnvironment,
      dctceClientId: input.dctceClientId,
      dctceTokenEndpoint: input.dctceTokenEndpoint,
      dctceApiEndpoint: input.dctceApiEndpoint,
      aspEndpoint: input.aspEndpoint,
      aspIdentifier: input.aspIdentifier,
      aspProviderName: input.aspProviderName,
      encryptionIv: iv.toString('hex'),
      configuredById: userId,
      configuredAt: new Date(),
      isValid: false, // Requires validation
      updatedAt: new Date(),
    };

    // Encrypt secrets if provided
    if (input.dctceClientSecret) {
      const { encrypted, authTag } = this.encrypt(input.dctceClientSecret, iv);
      encryptedData.dctceClientSecretEnc = encrypted;
      encryptedData.encryptionAuthTag = authTag;
    }

    if (input.aspApiKey) {
      const { encrypted, authTag } = this.encrypt(input.aspApiKey, iv);
      encryptedData.aspApiKeyEnc = encrypted;
      // Note: If both are set, authTag will be for aspApiKey
      // In production, use separate IVs per field
      encryptedData.encryptionAuthTag = authTag;
    }

    // Upsert credentials
    await this.prisma.einvoice_credentials.upsert({
      where: { companyId },
      update: encryptedData,
      create: {
        id: randomBytes(16).toString('hex'),
        companyId,
        ...encryptedData,
        createdAt: new Date(),
      },
    });

    // Audit log (never log actual credentials)
    await this.auditService.logWithHashChain({
      action: 'CREDENTIALS_UPDATE',
      entity: 'einvoice_credentials',
      entityId: companyId,
      userId,
      companyId,
      newValue: {
        transmissionMode: input.transmissionMode,
        activeEnvironment: input.activeEnvironment,
        fieldsUpdated: this.getUpdatedFieldNames(input),
      },
      metadata: {
        mfaVerified: true,
        timestamp: new Date().toISOString(),
      },
    });

    logger.info('[CredentialStore] Credentials updated', {
      companyId,
      userId,
      transmissionMode: input.transmissionMode,
      // Never log actual credentials
    });

    return this.getCredentialStatus(companyId) as Promise<CredentialStatus>;
  }

  /**
   * Get decrypted credentials (internal use only)
   *
   * WARNING: Returns sensitive data - never log or expose
   */
  async getDecryptedCredentials(companyId: string): Promise<DecryptedCredentials | null> {
    const credentials = await this.prisma.einvoice_credentials.findUnique({
      where: { companyId },
    });

    if (!credentials) {
      return null;
    }

    const iv = credentials.encryptionIv
      ? Buffer.from(credentials.encryptionIv, 'hex')
      : null;
    const authTag = credentials.encryptionAuthTag
      ? Buffer.from(credentials.encryptionAuthTag, 'hex')
      : null;

    const result: DecryptedCredentials = {
      dctceClientId: credentials.dctceClientId || undefined,
      dctceTokenEndpoint: credentials.dctceTokenEndpoint || undefined,
      dctceApiEndpoint: credentials.dctceApiEndpoint || undefined,
      aspEndpoint: credentials.aspEndpoint || undefined,
      aspIdentifier: credentials.aspIdentifier || undefined,
      aspProviderName: credentials.aspProviderName || undefined,
    };

    // Decrypt secrets
    if (credentials.dctceClientSecretEnc && iv && authTag) {
      try {
        result.dctceClientSecret = this.decrypt(
          credentials.dctceClientSecretEnc,
          iv,
          authTag
        );
      } catch (error) {
        logger.error('[CredentialStore] Failed to decrypt DCTCE secret', { companyId });
      }
    }

    if (credentials.aspApiKeyEnc && iv && authTag) {
      try {
        result.aspApiKey = this.decrypt(credentials.aspApiKeyEnc, iv, authTag);
      } catch (error) {
        logger.error('[CredentialStore] Failed to decrypt ASP key', { companyId });
      }
    }

    // Decrypt cached tokens
    if (credentials.accessTokenEnc && iv && authTag) {
      try {
        result.accessToken = this.decrypt(credentials.accessTokenEnc, iv, authTag);
        result.tokenExpiresAt = credentials.tokenExpiresAt || undefined;
      } catch (error) {
        // Token decryption failure - will need to refresh
      }
    }

    if (credentials.refreshTokenEnc && iv && authTag) {
      try {
        result.refreshToken = this.decrypt(credentials.refreshTokenEnc, iv, authTag);
      } catch (error) {
        // Refresh token decryption failure
      }
    }

    return result;
  }

  /**
   * Update cached OAuth tokens (encrypted)
   */
  async updateCachedTokens(
    companyId: string,
    accessToken: string,
    expiresAt: Date,
    refreshToken?: string
  ): Promise<void> {
    const credentials = await this.prisma.einvoice_credentials.findUnique({
      where: { companyId },
    });

    if (!credentials) {
      throw new Error('Credentials not found');
    }

    // Get or generate IV
    let iv = credentials.encryptionIv
      ? Buffer.from(credentials.encryptionIv, 'hex')
      : randomBytes(CREDENTIAL_ENCRYPTION.IV_LENGTH);

    const updateData: Partial<einvoice_credentials> = {
      tokenExpiresAt: expiresAt,
      updatedAt: new Date(),
    };

    // Encrypt access token
    const { encrypted: encAccessToken, authTag } = this.encrypt(accessToken, iv);
    updateData.accessTokenEnc = encAccessToken;
    updateData.encryptionAuthTag = authTag;

    // Encrypt refresh token if provided
    if (refreshToken) {
      const { encrypted: encRefreshToken } = this.encrypt(refreshToken, iv);
      updateData.refreshTokenEnc = encRefreshToken;
    }

    if (!credentials.encryptionIv) {
      updateData.encryptionIv = iv.toString('hex');
    }

    await this.prisma.einvoice_credentials.update({
      where: { companyId },
      data: updateData,
    });
  }

  /**
   * Record connection test result
   */
  async recordConnectionTest(
    companyId: string,
    success: boolean,
    error?: string
  ): Promise<void> {
    await this.prisma.einvoice_credentials.update({
      where: { companyId },
      data: {
        lastConnectionTestAt: new Date(),
        lastConnectionSuccess: success,
        lastConnectionError: error || null,
        isValid: success,
        lastValidatedAt: success ? new Date() : undefined,
        updatedAt: new Date(),
      },
    });
  }

  /**
   * Clear cached tokens (on auth failure)
   */
  async clearCachedTokens(companyId: string): Promise<void> {
    await this.prisma.einvoice_credentials.update({
      where: { companyId },
      data: {
        accessTokenEnc: null,
        tokenExpiresAt: null,
        refreshTokenEnc: null,
        updatedAt: new Date(),
      },
    });
  }

  // ============================================================================
  // PRIVATE METHODS
  // ============================================================================

  /**
   * Encrypt a string using AES-256-GCM
   */
  private encrypt(
    plaintext: string,
    iv: Buffer
  ): { encrypted: string; authTag: string } {
    const cipher = createCipheriv(
      CREDENTIAL_ENCRYPTION.ALGORITHM,
      this.encryptionKey,
      iv
    );

    let encrypted = cipher.update(plaintext, 'utf8', 'hex');
    encrypted += cipher.final('hex');
    const authTag = cipher.getAuthTag().toString('hex');

    return { encrypted, authTag };
  }

  /**
   * Decrypt a string using AES-256-GCM
   */
  private decrypt(ciphertext: string, iv: Buffer, authTag: Buffer): string {
    const decipher = createDecipheriv(
      CREDENTIAL_ENCRYPTION.ALGORITHM,
      this.encryptionKey,
      iv
    );
    decipher.setAuthTag(authTag);

    let decrypted = decipher.update(ciphertext, 'hex', 'utf8');
    decrypted += decipher.final('utf8');

    return decrypted;
  }

  /**
   * Check if credentials are configured based on mode
   */
  private isConfigured(credentials: einvoice_credentials): boolean {
    if (credentials.transmissionMode === 'DIRECT_DCTCE') {
      return !!(
        credentials.dctceClientId &&
        credentials.dctceClientSecretEnc &&
        credentials.dctceTokenEndpoint &&
        credentials.dctceApiEndpoint
      );
    }

    if (credentials.transmissionMode === 'ASP_PROVIDER') {
      return !!(
        credentials.aspApiKeyEnc &&
        credentials.aspEndpoint &&
        credentials.aspIdentifier
      );
    }

    // SANDBOX mode - minimal config needed
    return credentials.transmissionMode === 'SANDBOX';
  }

  /**
   * Get list of updated field names (for audit log)
   */
  private getUpdatedFieldNames(input: CredentialUpdateInput): string[] {
    const fields: string[] = [];

    if (input.transmissionMode) fields.push('transmissionMode');
    if (input.activeEnvironment) fields.push('activeEnvironment');
    if (input.dctceClientId) fields.push('dctceClientId');
    if (input.dctceClientSecret) fields.push('dctceClientSecret');
    if (input.dctceTokenEndpoint) fields.push('dctceTokenEndpoint');
    if (input.dctceApiEndpoint) fields.push('dctceApiEndpoint');
    if (input.aspApiKey) fields.push('aspApiKey');
    if (input.aspEndpoint) fields.push('aspEndpoint');
    if (input.aspIdentifier) fields.push('aspIdentifier');
    if (input.aspProviderName) fields.push('aspProviderName');

    return fields;
  }
}

export default CredentialStoreService;
```
  </action>
  <verify>
    - `npx tsc --noEmit` compiles successfully
    - Encryption uses AES-256-GCM with proper IV and auth tag
    - getCredentialStatus returns no secrets
    - setCredentials requires MFA verification
    - Audit logging for credential changes
  </verify>
  <done>CredentialStoreService created with AES-256-GCM encryption and MFA enforcement</done>
</task>

<task type="auto">
  <name>Task 2: Create OAuth token service with auto-refresh</name>
  <files>web-erp-app/backend/src/services/einvoice/transmission/oauth-token.service.ts</files>
  <action>
Create OAuth token management service:

```typescript
/**
 * OAuth Token Service
 * Phase: 07-e-invoicing-transmission
 *
 * Manages OAuth 2.0 tokens for DCTCE direct connection.
 * Handles token acquisition, refresh, and caching.
 *
 * Features:
 * - Client credentials flow for DCTCE
 * - Automatic token refresh before expiry
 * - Token caching in encrypted storage
 * - Axios interceptor integration
 *
 * @module oauth-token.service
 */

import { injectable, inject } from 'inversify';
import axios, { AxiosInstance, InternalAxiosRequestConfig } from 'axios';
import { TYPES } from '../../../di/types';
import logger from '../../logger.service';
import { CredentialStoreService, DecryptedCredentials } from './credential-store.service';

// ============================================================================
// TYPES
// ============================================================================

/**
 * OAuth token response from DCTCE
 */
interface OAuthTokenResponse {
  access_token: string;
  token_type: string;
  expires_in: number;
  refresh_token?: string;
  scope?: string;
}

/**
 * Token with expiry tracking
 */
interface CachedToken {
  accessToken: string;
  expiresAt: Date;
  refreshToken?: string;
}

// ============================================================================
// SERVICE
// ============================================================================

@injectable()
export class OAuthTokenService {
  private readonly TOKEN_REFRESH_BUFFER_MS = 5 * 60 * 1000; // Refresh 5 min before expiry
  private tokenRefreshPromises: Map<string, Promise<CachedToken>> = new Map();

  constructor(
    @inject(TYPES.CredentialStoreService) private credentialStore: CredentialStoreService
  ) {}

  // ============================================================================
  // PUBLIC METHODS
  // ============================================================================

  /**
   * Get valid access token for a company
   *
   * Returns cached token if valid, otherwise acquires/refreshes
   */
  async getAccessToken(companyId: string): Promise<string> {
    // Check for cached token
    const credentials = await this.credentialStore.getDecryptedCredentials(companyId);

    if (!credentials) {
      throw new Error('DCTCE credentials not configured');
    }

    // Check if cached token is still valid
    if (credentials.accessToken && credentials.tokenExpiresAt) {
      const expiresAt = new Date(credentials.tokenExpiresAt);
      const refreshThreshold = new Date(Date.now() + this.TOKEN_REFRESH_BUFFER_MS);

      if (expiresAt > refreshThreshold) {
        // Token still valid
        return credentials.accessToken;
      }

      // Try to refresh if we have a refresh token
      if (credentials.refreshToken) {
        try {
          const newToken = await this.refreshToken(companyId, credentials);
          return newToken.accessToken;
        } catch (error) {
          logger.warn('[OAuthToken] Refresh failed, acquiring new token', { companyId });
        }
      }
    }

    // Acquire new token
    const newToken = await this.acquireToken(companyId, credentials);
    return newToken.accessToken;
  }

  /**
   * Create Axios instance with auto-refresh interceptor
   */
  createAuthenticatedClient(companyId: string, baseURL: string): AxiosInstance {
    const client = axios.create({
      baseURL,
      timeout: 30000,
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
    });

    // Request interceptor - add auth header
    client.interceptors.request.use(
      async (config: InternalAxiosRequestConfig) => {
        try {
          const token = await this.getAccessToken(companyId);
          config.headers.Authorization = `Bearer ${token}`;
        } catch (error) {
          logger.error('[OAuthToken] Failed to get access token', {
            companyId,
            error: (error as Error).message,
          });
          throw error;
        }
        return config;
      },
      (error) => Promise.reject(error)
    );

    // Response interceptor - handle 401 and retry
    client.interceptors.response.use(
      (response) => response,
      async (error) => {
        const originalRequest = error.config;

        // If 401 and not already retried
        if (error.response?.status === 401 && !originalRequest._retry) {
          originalRequest._retry = true;

          try {
            // Clear cached token and get new one
            await this.credentialStore.clearCachedTokens(companyId);
            const token = await this.getAccessToken(companyId);
            originalRequest.headers.Authorization = `Bearer ${token}`;
            return client(originalRequest);
          } catch (refreshError) {
            logger.error('[OAuthToken] Token refresh on 401 failed', {
              companyId,
              error: (refreshError as Error).message,
            });
            return Promise.reject(refreshError);
          }
        }

        return Promise.reject(error);
      }
    );

    return client;
  }

  /**
   * Validate credentials by attempting token acquisition
   */
  async validateCredentials(companyId: string): Promise<boolean> {
    try {
      const credentials = await this.credentialStore.getDecryptedCredentials(companyId);

      if (!credentials) {
        return false;
      }

      // Try to acquire a token
      await this.acquireToken(companyId, credentials);

      // Record successful validation
      await this.credentialStore.recordConnectionTest(companyId, true);

      return true;
    } catch (error) {
      // Record failed validation
      await this.credentialStore.recordConnectionTest(
        companyId,
        false,
        (error as Error).message
      );

      return false;
    }
  }

  // ============================================================================
  // PRIVATE METHODS
  // ============================================================================

  /**
   * Acquire new token using client credentials flow
   */
  private async acquireToken(
    companyId: string,
    credentials: DecryptedCredentials
  ): Promise<CachedToken> {
    // Prevent concurrent token requests
    const existingPromise = this.tokenRefreshPromises.get(companyId);
    if (existingPromise) {
      return existingPromise;
    }

    const tokenPromise = this.doAcquireToken(companyId, credentials);
    this.tokenRefreshPromises.set(companyId, tokenPromise);

    try {
      return await tokenPromise;
    } finally {
      this.tokenRefreshPromises.delete(companyId);
    }
  }

  /**
   * Actual token acquisition logic
   */
  private async doAcquireToken(
    companyId: string,
    credentials: DecryptedCredentials
  ): Promise<CachedToken> {
    if (!credentials.dctceClientId || !credentials.dctceClientSecret) {
      throw new Error('DCTCE client credentials not configured');
    }

    if (!credentials.dctceTokenEndpoint) {
      throw new Error('DCTCE token endpoint not configured');
    }

    logger.info('[OAuthToken] Acquiring new token', { companyId });

    try {
      const response = await axios.post<OAuthTokenResponse>(
        credentials.dctceTokenEndpoint,
        new URLSearchParams({
          grant_type: 'client_credentials',
          client_id: credentials.dctceClientId,
          client_secret: credentials.dctceClientSecret,
          scope: 'einvoice:transmit einvoice:status',
        }).toString(),
        {
          headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
          },
          timeout: 30000,
        }
      );

      const { access_token, expires_in, refresh_token } = response.data;

      // Calculate expiry time
      const expiresAt = new Date(Date.now() + expires_in * 1000);

      // Cache encrypted token
      await this.credentialStore.updateCachedTokens(
        companyId,
        access_token,
        expiresAt,
        refresh_token
      );

      logger.info('[OAuthToken] Token acquired successfully', {
        companyId,
        expiresAt: expiresAt.toISOString(),
      });

      return {
        accessToken: access_token,
        expiresAt,
        refreshToken: refresh_token,
      };
    } catch (error) {
      logger.error('[OAuthToken] Token acquisition failed', {
        companyId,
        error: (error as Error).message,
        // Never log credentials
      });

      throw new Error(`Failed to acquire OAuth token: ${(error as Error).message}`);
    }
  }

  /**
   * Refresh token using refresh_token grant
   */
  private async refreshToken(
    companyId: string,
    credentials: DecryptedCredentials
  ): Promise<CachedToken> {
    // Prevent concurrent refresh requests
    const existingPromise = this.tokenRefreshPromises.get(companyId);
    if (existingPromise) {
      return existingPromise;
    }

    const refreshPromise = this.doRefreshToken(companyId, credentials);
    this.tokenRefreshPromises.set(companyId, refreshPromise);

    try {
      return await refreshPromise;
    } finally {
      this.tokenRefreshPromises.delete(companyId);
    }
  }

  /**
   * Actual token refresh logic
   */
  private async doRefreshToken(
    companyId: string,
    credentials: DecryptedCredentials
  ): Promise<CachedToken> {
    if (!credentials.refreshToken) {
      throw new Error('No refresh token available');
    }

    if (!credentials.dctceTokenEndpoint) {
      throw new Error('DCTCE token endpoint not configured');
    }

    logger.info('[OAuthToken] Refreshing token', { companyId });

    try {
      const response = await axios.post<OAuthTokenResponse>(
        credentials.dctceTokenEndpoint,
        new URLSearchParams({
          grant_type: 'refresh_token',
          refresh_token: credentials.refreshToken,
          client_id: credentials.dctceClientId || '',
        }).toString(),
        {
          headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
          },
          timeout: 30000,
        }
      );

      const { access_token, expires_in, refresh_token } = response.data;
      const expiresAt = new Date(Date.now() + expires_in * 1000);

      // Cache new tokens
      await this.credentialStore.updateCachedTokens(
        companyId,
        access_token,
        expiresAt,
        refresh_token
      );

      logger.info('[OAuthToken] Token refreshed successfully', {
        companyId,
        expiresAt: expiresAt.toISOString(),
      });

      return {
        accessToken: access_token,
        expiresAt,
        refreshToken: refresh_token,
      };
    } catch (error) {
      logger.error('[OAuthToken] Token refresh failed', {
        companyId,
        error: (error as Error).message,
      });

      // Clear invalid tokens
      await this.credentialStore.clearCachedTokens(companyId);

      throw new Error(`Failed to refresh OAuth token: ${(error as Error).message}`);
    }
  }
}

export default OAuthTokenService;
```
  </action>
  <verify>
    - `npx tsc --noEmit` compiles successfully
    - Token acquisition uses client_credentials flow
    - Auto-refresh 5 minutes before expiry
    - Axios interceptor handles 401 retry
    - Concurrent request deduplication
    - Never logs credentials
  </verify>
  <done>OAuthTokenService created with auto-refresh and Axios interceptor integration</done>
</task>

</tasks>

<verification>
1. Types compile: `npx tsc --noEmit` passes
2. AES-256-GCM encryption: Uses crypto.createCipheriv with proper algorithm
3. IV handling: Random IV generated per encryption operation
4. Auth tag: GCM auth tag stored and used for decryption
5. MFA enforcement: setCredentials throws if mfaVerified is false
6. No credential logging: Secrets never appear in logs
7. Audit trail: Credential changes logged via ComplianceAuditService
8. Token auto-refresh: Refresh 5 minutes before expiry
9. Concurrent deduplication: Single token request per company
</verification>

<success_criteria>
1. CredentialStoreService encrypts all secrets with AES-256-GCM
2. getCredentialStatus returns status without exposing secrets
3. setCredentials requires MFA verification flag
4. All credential changes logged to audit trail
5. OAuthTokenService implements client_credentials flow
6. Tokens auto-refresh before expiry with configurable buffer
7. Axios interceptor handles 401 response with token refresh
8. Concurrent token requests deduplicated per company
9. Failed token operations clear cached tokens
</success_criteria>

<output>
After completion, create `.planning/phases/07-e-invoicing-transmission/07-03-SUMMARY.md`
</output>
