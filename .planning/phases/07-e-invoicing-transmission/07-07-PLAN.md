---
phase: 07-e-invoicing-transmission
plan: 07
type: execute
wave: 3
depends_on: ["07-01", "07-04", "07-05", "07-06"]
files_modified:
  - web-erp-app/backend/src/services/einvoice/queue/transmission-queue.service.ts
  - web-erp-app/backend/src/services/einvoice/queue/transmission-worker.service.ts
  - web-erp-app/backend/src/services/einvoice/queue/queue.types.ts
  - web-erp-app/backend/src/jobs/einvoice-transmission.job.ts
autonomous: true

must_haves:
  truths:
    - "BullMQ queue processes transmissions with Redis backend"
    - "Auto-retry with exponential backoff (3 attempts, 1s/4s/16s)"
    - "Validation rejections marked for manual correction (no retry)"
    - "Queue dashboard accessible for monitoring"
  artifacts:
    - path: "web-erp-app/backend/src/services/einvoice/queue/transmission-queue.service.ts"
      provides: "Queue management service"
      exports: ["TransmissionQueueService"]
      min_lines: 200
    - path: "web-erp-app/backend/src/services/einvoice/queue/transmission-worker.service.ts"
      provides: "Job processor worker"
      exports: ["TransmissionWorkerService"]
      min_lines: 150
    - path: "web-erp-app/backend/src/jobs/einvoice-transmission.job.ts"
      provides: "BullMQ job processor"
      exports: ["processTransmissionJob"]
  key_links:
    - from: "transmission-queue.service.ts"
      to: "bullmq"
      via: "Queue class"
      pattern: "new Queue|Queue.add"
    - from: "transmission-worker.service.ts"
      to: "transmission-provider.interface.ts"
      via: "provider selection"
      pattern: "ITransmissionProvider|getProvider"
---

<objective>
Create the transmission queue infrastructure using BullMQ for reliable e-invoice transmission with retry logic and monitoring.

Purpose: EINV-09 requires reliable transmission - queued processing ensures invoices are transmitted even during DCTCE downtime, with proper retry handling and failure tracking.

Output:
- TransmissionQueueService for managing the queue
- TransmissionWorkerService for processing jobs
- BullMQ job processor with retry logic
- Queue monitoring dashboard endpoint
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-e-invoicing-transmission/07-CONTEXT.md
@.planning/phases/07-e-invoicing-transmission/07-RESEARCH.md
@.planning/phases/07-e-invoicing-transmission/07-05-SUMMARY.md
@.planning/phases/07-e-invoicing-transmission/07-06-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Queue Type Definitions</name>
  <files>web-erp-app/backend/src/services/einvoice/queue/queue.types.ts</files>
  <action>
Create directory and queue types:

```bash
mkdir -p web-erp-app/backend/src/services/einvoice/queue
```

Define types based on 07-RESEARCH.md queue section:

1. **TransmissionJobData interface**:
   - archiveId: string
   - einvoiceNumber: string
   - companyId: string
   - transmissionMode: TransmissionMode
   - environment: TransmissionEnvironment
   - priority: 'high' | 'normal' | 'low' (default: normal)
   - scheduledAt?: Date (for delayed transmission)
   - metadata: TransmissionMetadata

2. **TransmissionJobResult interface**:
   - success: boolean
   - transmissionId: string
   - status: EInvoiceTransmissionStatus
   - ftaReferenceNumber?: string
   - clearanceNumber?: string
   - errors?: TransmissionError[]
   - duration: number (ms)

3. **QueueConfig interface** (from RESEARCH):
   - queueName: string ('einvoice-transmission')
   - redis: { host, port, password?, db? }
   - defaultJobOptions: JobsOptions
   - workerConcurrency: number (5)
   - retryConfig: RetryConfig

4. **RetryConfig interface**:
   - maxAttempts: 3
   - baseDelay: 1000 (1s)
   - backoffMultiplier: 4 (exponential: 1s, 4s, 16s)
   - maxRetryWindow: 86400000 (24 hours)
   - noRetryOnValidation: true (validation errors don't retry)

5. **QueueStats interface**:
   - waiting: number
   - active: number
   - completed: number
   - failed: number
   - delayed: number
   - oldestJobAge?: number (ms)

6. **JOB_PRIORITIES constant**:
   - high: 1
   - normal: 5
   - low: 10

7. **QUEUE_EVENTS constant**: Event names for monitoring
   - COMPLETED: 'transmission:completed'
   - FAILED: 'transmission:failed'
   - STALLED: 'transmission:stalled'
   - PROGRESS: 'transmission:progress'

Also create index.ts for exports.
  </action>
  <verify>
    - `npx tsc --noEmit` compiles successfully
    - Queue types exported
    - Retry config matches RESEARCH specs
  </verify>
  <done>Queue types created with job data, result, and retry configuration</done>
</task>

<task type="auto">
  <name>Task 2: Create Transmission Queue Service</name>
  <files>web-erp-app/backend/src/services/einvoice/queue/transmission-queue.service.ts</files>
  <action>
Create the queue management service:

1. **TransmissionQueueService class** (@injectable):
   - Inject: QueueConfig (from env)
   - Private: Queue<TransmissionJobData, TransmissionJobResult> (BullMQ)

2. **constructor(config)**:
   - Create BullMQ Queue with config
   - Set default job options (removeOnComplete: 100, removeOnFail: 500)
   - Set up event listeners for monitoring

3. **addToQueue(data: TransmissionJobData, options?)**:
   - Validate data (archiveId, companyId required)
   - Check for duplicate (same archiveId within 1 hour)
   - Set job options: priority, delay, attempts
   - Add to queue
   - Update einvoice_transmissions status to QUEUED
   - Return job ID

4. **addBulk(jobs: TransmissionJobData[])**:
   - Validate all jobs
   - Use Queue.addBulk() for atomic add
   - Return array of job IDs

5. **getJobStatus(jobId)**:
   - Get job from queue
   - Return state (waiting, active, completed, failed, delayed)
   - Include progress, attempts, timestamps

6. **cancelJob(jobId)**:
   - Remove job if waiting/delayed
   - Update transmission status to CANCELLED
   - Return success/failure

7. **retryJob(jobId)**:
   - Get failed job
   - Re-add to queue with reset attempts
   - Return new job ID

8. **getQueueStats(): QueueStats**:
   - Get counts: waiting, active, completed, failed, delayed
   - Get oldest waiting job age
   - Return stats object

9. **getRecentJobs(status, limit)**:
   - Get jobs by status
   - Return array with job data, result, timestamps

10. **pauseQueue()** / **resumeQueue()**:
    - For maintenance windows
    - Pause/resume worker processing

11. **drainQueue()**:
    - Remove all waiting jobs
    - Used for emergency cleanup

12. **Private event handlers**:
    - onCompleted(job, result): Log, emit event
    - onFailed(job, error): Log, determine if retry
    - onStalled(jobId): Log warning, may need investigation

Use Redis connection from process.env.REDIS_URL or config.
  </action>
  <verify>
    - `npx tsc --noEmit` compiles successfully
    - Queue initialized with BullMQ
    - Duplicate detection prevents re-queueing
    - Stats endpoint returns counts
    - Event handlers log appropriately
  </verify>
  <done>TransmissionQueueService created with BullMQ integration and queue management methods</done>
</task>

<task type="auto">
  <name>Task 3: Create Transmission Worker Service and Job Processor</name>
  <files>
    web-erp-app/backend/src/services/einvoice/queue/transmission-worker.service.ts
    web-erp-app/backend/src/jobs/einvoice-transmission.job.ts
  </files>
  <action>
Create the worker service:

**transmission-worker.service.ts**:

1. **TransmissionWorkerService class** (@injectable):
   - Inject: QueueConfig, ProviderFactory, TddBuilderService, MlsHandlerService, PrismaClient
   - Private: Worker<TransmissionJobData, TransmissionJobResult>

2. **start()**:
   - Create BullMQ Worker with processor
   - Set concurrency from config (default 5)
   - Set up error handlers
   - Log worker started

3. **stop()**:
   - Close worker gracefully
   - Wait for active jobs to complete
   - Log worker stopped

4. **getWorkerStatus()**:
   - Return running state, concurrency, active job count

5. **Private processJob(job)**: Main processing logic
   - Extract job data
   - Get appropriate provider (based on transmissionMode)
   - Get archive content (XML)
   - Build TDD (for FTA reporting)
   - Call provider.transmit()
   - Handle response via MlsHandlerService
   - Return TransmissionJobResult

6. **Error handling**:
   - shouldRetry(error, attempts): boolean
     - Return false for validation errors (RE status)
     - Return false if attempts >= maxAttempts
     - Return false if job age > 24 hours
     - Return true otherwise
   - getRetryDelay(attempts): number
     - Calculate exponential backoff: 1s * 4^(attempts-1)
     - Cap at 1 hour

**einvoice-transmission.job.ts**:

```typescript
/**
 * E-Invoice Transmission Job Processor
 * BullMQ job handler for e-invoice transmission
 */

import { Job } from 'bullmq';
import { container } from '../di/container';
import { TYPES } from '../di/types';
import { TransmissionJobData, TransmissionJobResult } from '../services/einvoice/queue/queue.types';

export async function processTransmissionJob(
  job: Job<TransmissionJobData, TransmissionJobResult>
): Promise<TransmissionJobResult> {
  const startTime = Date.now();
  const { archiveId, companyId, transmissionMode, environment, metadata } = job.data;

  // Get services from DI container
  const prisma = container.get(TYPES.PrismaClient);
  const archiveService = container.get(TYPES.EInvoiceArchiveService);
  const tddBuilder = container.get(TYPES.TddBuilderService);
  const providerFactory = container.get(TYPES.TransmissionProviderFactory);
  const mlsHandler = container.get(TYPES.MlsHandlerService);

  try {
    // Update status to TRANSMITTING
    await prisma.einvoice_transmissions.update({
      where: { id: archiveId },
      data: { status: 'TRANSMITTING', lastAttemptAt: new Date() }
    });

    // Report progress
    await job.updateProgress(10);

    // Get archive with XML content
    const archive = await archiveService.getArchive(archiveId);
    if (!archive) {
      throw new Error(`Archive not found: ${archiveId}`);
    }

    await job.updateProgress(20);

    // Build TDD for reporting
    const tddResult = tddBuilder.buildFromArchive(archive);
    if (!tddResult.success) {
      throw new Error(`TDD build failed: ${tddResult.errors?.[0]?.message}`);
    }

    await job.updateProgress(40);

    // Get provider
    const provider = await providerFactory(companyId, transmissionMode);
    if (!provider.isConfigured()) {
      throw new Error(`Provider not configured: ${transmissionMode}`);
    }

    await job.updateProgress(50);

    // Transmit
    const result = await provider.transmit(archiveId, archive.xmlContent, metadata);

    await job.updateProgress(80);

    // Handle MLS response
    await mlsHandler.handleMlsResponse(archiveId, {
      submissionId: result.transmissionId,
      documentReference: metadata.einvoiceNumber,
      statusCode: result.mlsStatus || 'PENDING',
      statusMessage: result.errors?.[0]?.message || 'Submitted',
      receivedAt: new Date(),
      processedAt: new Date(),
      tddReference: result.tddReference,
      clearanceNumber: result.clearanceNumber,
      errors: result.errors,
    });

    await job.updateProgress(100);

    return {
      success: result.success,
      transmissionId: result.transmissionId,
      status: result.status,
      ftaReferenceNumber: result.ftaReferenceNumber,
      clearanceNumber: result.clearanceNumber,
      errors: result.errors,
      duration: Date.now() - startTime,
    };

  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';

    // Determine if retryable
    const isValidationError = errorMessage.includes('validation') ||
                               errorMessage.includes('PINT-AE') ||
                               errorMessage.includes('rejected');

    if (isValidationError) {
      // Don't retry validation errors
      await prisma.einvoice_transmissions.update({
        where: { id: archiveId },
        data: {
          status: 'REJECTED',
          lastAttemptAt: new Date(),
          errorMessage,
        }
      });
    }

    throw error; // Let BullMQ handle retry
  }
}
```
  </action>
  <verify>
    - `npx tsc --noEmit` compiles successfully
    - Worker uses BullMQ Worker class
    - Job processor imports from DI container
    - Progress updates at each stage
    - Validation errors don't retry
    - Exponential backoff calculated correctly
  </verify>
  <done>TransmissionWorkerService and job processor created with retry logic and progress tracking</done>
</task>

</tasks>

<verification>
1. BullMQ queue: Queue and Worker initialized with Redis
2. Job data: Includes archiveId, companyId, transmissionMode, metadata
3. Retry logic: 3 attempts with 1s/4s/16s exponential backoff
4. Validation errors: Marked rejected without retry
5. 24-hour window: Jobs expire after max retry window
6. Progress tracking: Job updates progress at each stage
7. Queue stats: waiting, active, completed, failed counts
8. Duplicate detection: Same archiveId blocked within 1 hour
</verification>

<success_criteria>
1. TransmissionQueueService.addToQueue() creates BullMQ job
2. Queue configured with Redis connection from environment
3. Worker processes jobs with configurable concurrency (default 5)
4. Retry with exponential backoff: 1s, 4s, 16s (3 attempts)
5. Validation rejections (RE status) marked for manual correction
6. Jobs over 24 hours old not retried
7. Queue stats endpoint returns accurate counts
8. Job progress reported at 10%, 20%, 40%, 50%, 80%, 100%
9. Duplicate archiveId detection prevents re-queueing
</success_criteria>

<output>
After completion, create `.planning/phases/07-e-invoicing-transmission/07-07-SUMMARY.md`
</output>
