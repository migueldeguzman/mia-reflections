---
phase: 07-e-invoicing-transmission
plan: 09
type: execute
wave: 4
depends_on: ["07-02", "07-03", "07-04", "07-05", "07-06", "07-07", "07-08"]
files_modified:
  - web-erp-app/backend/src/services/einvoice/__tests__/transmission-integration.test.ts
  - web-erp-app/backend/src/routes/einvoice-transmission.routes.ts
  - web-erp-app/backend/src/controllers/einvoice-transmission.controller.ts
  - web-erp-app/backend/prisma/seeds/einvoice-transmission.seed.ts
autonomous: true

must_haves:
  truths:
    - "Full transmission flow tested end-to-end"
    - "Permission checks enforced on all endpoints"
    - "Sandbox transmission succeeds with valid invoice"
    - "Rejection handling triggers notification"
  artifacts:
    - path: "web-erp-app/backend/src/services/einvoice/__tests__/transmission-integration.test.ts"
      provides: "Integration test suite"
      min_lines: 300
    - path: "web-erp-app/backend/src/routes/einvoice-transmission.routes.ts"
      provides: "Transmission API routes"
      exports: ["einvoiceTransmissionRoutes"]
    - path: "web-erp-app/backend/src/controllers/einvoice-transmission.controller.ts"
      provides: "Transmission controller"
      exports: ["EInvoiceTransmissionController"]
  key_links:
    - from: "einvoice-transmission.routes.ts"
      to: "einvoice-transmission.middleware.ts"
      via: "permission middleware"
      pattern: "requireEInvoiceTransmissionPermission"
    - from: "einvoice-transmission.controller.ts"
      to: "transmission-queue.service.ts"
      via: "queue submission"
      pattern: "queueService\\.addToQueue"
---

<objective>
Create integration tests and finalize transmission API routes with proper permission enforcement.

Purpose: Ensure all Phase 7 components work together correctly - from queue submission through transmission to status updates - with proper access control.

Output:
- Full integration test suite for transmission flow
- Transmission controller with all endpoints
- Routes with permission middleware
- Seed data for testing
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-e-invoicing-transmission/07-CONTEXT.md
@.planning/phases/07-e-invoicing-transmission/07-RESEARCH.md
@.planning/phases/07-e-invoicing-transmission/07-07-SUMMARY.md
@.planning/phases/07-e-invoicing-transmission/07-08-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Transmission Controller</name>
  <files>web-erp-app/backend/src/controllers/einvoice-transmission.controller.ts</files>
  <action>
Create the transmission controller with all API operations:

1. **EInvoiceTransmissionController class**:
   - Inject: TransmissionQueueService, CredentialStoreService, MlsHandlerService,
             EInvoiceExportService, ComplianceAuditService

2. **POST /submit**: Queue single invoice for transmission
   - Body: { archiveId, priority? }
   - Permission: QUEUE_SUBMIT
   - Create TransmissionJobData
   - Call queueService.addToQueue()
   - Return { success, jobId, transmissionId }

3. **POST /submit/bulk**: Queue multiple invoices
   - Body: { archiveIds: string[], priority? }
   - Permission: TRANSMIT_BULK
   - MFA required
   - Call queueService.addBulk()
   - Return { success, jobs: [{ archiveId, jobId }] }

4. **GET /queue**: Get queue status
   - Query: { status?, limit?, offset? }
   - Permission: QUEUE_VIEW
   - Return paginated list of queued transmissions

5. **GET /queue/stats**: Get queue statistics
   - Permission: QUEUE_VIEW
   - Return waiting, active, completed, failed counts

6. **POST /retry/:transmissionId**: Retry failed transmission
   - Permission: QUEUE_RETRY
   - Validate transmission exists and failed
   - Call queueService.retryJob()
   - Return { success, newJobId }

7. **POST /cancel/:transmissionId**: Cancel queued transmission
   - Permission: QUEUE_CANCEL
   - Validate transmission is queued (not active)
   - Call queueService.cancelJob()
   - Return { success }

8. **GET /status/:transmissionId**: Get transmission status
   - Permission: STATUS_VIEW
   - Return full transmission record with history

9. **POST /test-connection**: Test provider connectivity
   - Permission: CONNECTION_TEST
   - Get provider based on company config
   - Call provider.testConnection()
   - Return { connected, latencyMs, error? }

10. **GET /credentials/status**: Get credential configuration status
    - Permission: CREDENTIALS_VIEW
    - Call credentialStore.getCredentialStatus()
    - Return status (no secrets)

11. **POST /credentials**: Update credentials
    - Permission: CREDENTIALS_MANAGE
    - MFA required
    - Call credentialStore.setCredentials()
    - Return { success, status }

12. **GET /audit/:transmissionId**: Get transmission audit history
    - Permission: AUDIT_VIEW
    - Return einvoice_transmission_history records

13. **GET /dashboard/stats**: Get dashboard statistics
    - Permission: DASHBOARD_VIEW
    - Return: transmitted today, pending, failed, clearance rate

Error handling:
- All endpoints return { success, message?, error?, data? }
- Log errors with context
- Audit sensitive operations
  </action>
  <verify>
    - `npx tsc --noEmit` compiles successfully
    - All controller methods exported
    - MFA required on credentials and bulk submit
    - Audit logging for sensitive operations
  </verify>
  <done>EInvoiceTransmissionController created with all API endpoints</done>
</task>

<task type="auto">
  <name>Task 2: Create Transmission Routes</name>
  <files>web-erp-app/backend/src/routes/einvoice-transmission.routes.ts</files>
  <action>
Create the transmission routes with permission middleware:

```typescript
/**
 * E-Invoice Transmission Routes
 * Phase: 07-e-invoicing-transmission
 */

import { Router } from 'express';
import { authenticateJWT } from '../../middleware/auth.middleware';
import {
  requireEInvoiceTransmissionPermission,
  requireMfaForTransmission,
  requireAnyTransmissionPermission,
} from '../../middleware/einvoice-transmission.middleware';
import { EINVOICE_TRANSMISSION_PERMISSIONS } from '../../types/einvoice-transmission-permissions';
import { EInvoiceTransmissionController } from '../controllers/einvoice-transmission.controller';
import { container } from '../../di/container';
import { TYPES } from '../../di/types';

const router = Router();
const controller = container.get<EInvoiceTransmissionController>(TYPES.EInvoiceTransmissionController);

// Queue Management
router.get(
  '/queue',
  authenticateJWT,
  requireEInvoiceTransmissionPermission(EINVOICE_TRANSMISSION_PERMISSIONS.QUEUE_VIEW),
  controller.getQueue.bind(controller)
);

router.get(
  '/queue/stats',
  authenticateJWT,
  requireEInvoiceTransmissionPermission(EINVOICE_TRANSMISSION_PERMISSIONS.QUEUE_VIEW),
  controller.getQueueStats.bind(controller)
);

router.post(
  '/submit',
  authenticateJWT,
  requireEInvoiceTransmissionPermission(EINVOICE_TRANSMISSION_PERMISSIONS.QUEUE_SUBMIT),
  controller.submitSingle.bind(controller)
);

router.post(
  '/submit/bulk',
  authenticateJWT,
  requireEInvoiceTransmissionPermission(EINVOICE_TRANSMISSION_PERMISSIONS.TRANSMIT_BULK),
  requireMfaForTransmission(EINVOICE_TRANSMISSION_PERMISSIONS.TRANSMIT_BULK),
  controller.submitBulk.bind(controller)
);

router.post(
  '/retry/:transmissionId',
  authenticateJWT,
  requireEInvoiceTransmissionPermission(EINVOICE_TRANSMISSION_PERMISSIONS.QUEUE_RETRY),
  controller.retryTransmission.bind(controller)
);

router.post(
  '/cancel/:transmissionId',
  authenticateJWT,
  requireEInvoiceTransmissionPermission(EINVOICE_TRANSMISSION_PERMISSIONS.QUEUE_CANCEL),
  controller.cancelTransmission.bind(controller)
);

// Status & Monitoring
router.get(
  '/status/:transmissionId',
  authenticateJWT,
  requireEInvoiceTransmissionPermission(EINVOICE_TRANSMISSION_PERMISSIONS.STATUS_VIEW),
  controller.getTransmissionStatus.bind(controller)
);

router.post(
  '/test-connection',
  authenticateJWT,
  requireEInvoiceTransmissionPermission(EINVOICE_TRANSMISSION_PERMISSIONS.CONNECTION_TEST),
  controller.testConnection.bind(controller)
);

router.get(
  '/dashboard/stats',
  authenticateJWT,
  requireEInvoiceTransmissionPermission(EINVOICE_TRANSMISSION_PERMISSIONS.DASHBOARD_VIEW),
  controller.getDashboardStats.bind(controller)
);

// Credentials (Superuser)
router.get(
  '/credentials/status',
  authenticateJWT,
  requireEInvoiceTransmissionPermission(EINVOICE_TRANSMISSION_PERMISSIONS.CREDENTIALS_VIEW),
  controller.getCredentialStatus.bind(controller)
);

router.post(
  '/credentials',
  authenticateJWT,
  requireEInvoiceTransmissionPermission(EINVOICE_TRANSMISSION_PERMISSIONS.CREDENTIALS_MANAGE),
  requireMfaForTransmission(EINVOICE_TRANSMISSION_PERMISSIONS.CREDENTIALS_MANAGE),
  controller.updateCredentials.bind(controller)
);

// Audit
router.get(
  '/audit/:transmissionId',
  authenticateJWT,
  requireEInvoiceTransmissionPermission(EINVOICE_TRANSMISSION_PERMISSIONS.AUDIT_VIEW),
  controller.getAuditHistory.bind(controller)
);

export { router as einvoiceTransmissionRoutes };
```

Register routes in main einvoice routes (or app.ts):
```typescript
import { einvoiceTransmissionRoutes } from './einvoice-transmission.routes';
import { einvoiceExportRoutes } from './einvoice-export.routes';

app.use('/api/einvoice/transmission', einvoiceTransmissionRoutes);
app.use('/api/einvoice', einvoiceExportRoutes);
```
  </action>
  <verify>
    - `npx tsc --noEmit` compiles successfully
    - All routes use authenticateJWT
    - Permission middleware on each route
    - MFA middleware on bulk submit and credentials
    - Routes registered in main app
  </verify>
  <done>Transmission routes created with permission and MFA middleware</done>
</task>

<task type="auto">
  <name>Task 3: Create Integration Tests</name>
  <files>web-erp-app/backend/src/services/einvoice/__tests__/transmission-integration.test.ts</files>
  <action>
Create comprehensive integration tests:

**Test Setup**:
- Use test database (or mocked Prisma)
- Create test company with UAE_COMPLIANCE package
- Create test user with appropriate roles
- Create test e-invoice archive

**Test Suites**:

1. **Queue Submission Flow**:
   - Should add invoice to queue on /submit
   - Should update transmission status to QUEUED
   - Should reject duplicate submission within 1 hour
   - Should require QUEUE_SUBMIT permission
   - Should reject without authentication

2. **Bulk Submission**:
   - Should add multiple invoices to queue
   - Should require MFA verification
   - Should require TRANSMIT_BULK permission
   - Should validate all archiveIds exist

3. **Transmission Processing** (with mocked provider):
   - Should process queued job
   - Should call provider.transmit()
   - Should update status based on response
   - Should handle provider errors

4. **Status Updates**:
   - Should return PENDING_CLEARANCE on AB
   - Should return CLEARED on AP
   - Should return REJECTED on RE with errors
   - Should log status history

5. **Retry Logic**:
   - Should allow retry of FAILED transmission
   - Should not retry REJECTED transmission (validation error)
   - Should require QUEUE_RETRY permission
   - Should reset attempt count

6. **Cancel Operation**:
   - Should cancel QUEUED transmission
   - Should not cancel TRANSMITTING transmission
   - Should update status to CANCELLED

7. **Credential Management**:
   - Should require MFA for credential update
   - Should encrypt credentials
   - Should return status without secrets
   - Should require CREDENTIALS_MANAGE permission

8. **Export Integration**:
   - Should export XML from archived invoice
   - Should export JSON with metadata
   - Should create ZIP for bulk export
   - Should require appropriate permissions

9. **Permission Enforcement**:
   - Should deny without required permission
   - Should deny cross-company access
   - Should deny without UAE_COMPLIANCE package

10. **Error Scenarios**:
    - Should handle provider connection failure
    - Should handle queue connection failure
    - Should handle invalid archive ID
    - Should handle malformed XML

**Test Helpers**:
- createTestInvoice(options): Create e-invoice archive
- createTestUser(role): Create user with role bundle
- mockProvider(responses): Mock transmission provider
- waitForJob(jobId): Wait for job completion in tests
  </action>
  <verify>
    - Run `npm test -- --testPathPattern=transmission-integration.test.ts`
    - All tests pass
    - Coverage includes queue, transmission, status, export
    - Permission checks tested
    - Error scenarios covered
  </verify>
  <done>Integration tests created covering full transmission flow, permissions, and error scenarios</done>
</task>

<task type="auto">
  <name>Task 4: Create Transmission Seed Data</name>
  <files>web-erp-app/backend/prisma/seeds/einvoice-transmission.seed.ts</files>
  <action>
Create seed data for transmission testing:

```typescript
/**
 * E-Invoice Transmission Seed
 * Phase: 07-e-invoicing-transmission
 *
 * Seeds sample data for transmission testing:
 * - Sample company with credentials
 * - Sample e-invoice archives
 * - Sample transmission records in various states
 */

import { PrismaClient, TransmissionMode, TransmissionEnvironment } from '@prisma/client';
import { randomUUID } from 'crypto';
import { seedEInvoiceTransmissionPermissions, seedTransmissionRoles } from './einvoice-transmission-permissions.seed';

const prisma = new PrismaClient();

/**
 * Seed transmission test data
 */
export async function seedTransmissionTestData(companyId?: string): Promise<{
  companyId: string;
  archiveIds: string[];
  transmissionIds: string[];
}> {
  console.log('[Transmission Seed] Starting...');

  // Ensure permissions exist
  await seedEInvoiceTransmissionPermissions();

  // Use provided company or get first active company
  let company;
  if (companyId) {
    company = await prisma.companies.findUnique({ where: { id: companyId } });
  } else {
    company = await prisma.companies.findFirst({ where: { isActive: true } });
  }

  if (!company) {
    throw new Error('No company found for seeding');
  }

  console.log(`[Transmission Seed] Using company: ${company.name} (${company.id})`);

  // Create transmission roles for company
  await seedTransmissionRoles(company.id);

  // Create sample credentials (sandbox mode for testing)
  await prisma.einvoice_credentials.upsert({
    where: { companyId: company.id },
    update: {
      transmissionMode: TransmissionMode.SANDBOX,
      activeEnvironment: TransmissionEnvironment.SANDBOX,
      isValid: true,
      updatedAt: new Date(),
    },
    create: {
      id: randomUUID(),
      companyId: company.id,
      transmissionMode: TransmissionMode.SANDBOX,
      activeEnvironment: TransmissionEnvironment.SANDBOX,
      isValid: true,
      createdAt: new Date(),
      updatedAt: new Date(),
    },
  });

  // Create sample e-invoice archives
  const archiveIds: string[] = [];
  const sampleInvoices = [
    { number: 'INV-2026-0001', type: 'STANDARD', amount: 1050 },
    { number: 'INV-2026-0002', type: 'STANDARD', amount: 5250 },
    { number: 'CN-2026-0001', type: 'CREDIT_NOTE', amount: 525 },
  ];

  for (const inv of sampleInvoices) {
    const archiveId = randomUUID();

    await prisma.einvoice_archives.upsert({
      where: { companyId_einvoiceNumber: { companyId: company.id, einvoiceNumber: inv.number } },
      update: { updatedAt: new Date() },
      create: {
        id: archiveId,
        companyId: company.id,
        einvoiceNumber: inv.number,
        invoiceId: randomUUID(),
        invoiceType: inv.type,
        xmlContent: generateSampleXml(inv.number, inv.amount),
        xmlHash: `sha256:${randomUUID().replace(/-/g, '')}`,
        format: 'PINT_AE',
        version: '1.0',
        archivedAt: new Date(),
        createdAt: new Date(),
        updatedAt: new Date(),
      },
    });

    archiveIds.push(archiveId);
  }

  // Create sample transmission records in various states
  const transmissionIds: string[] = [];
  const transmissionStates = [
    { status: 'DRAFT', archiveIdx: 0 },
    { status: 'QUEUED', archiveIdx: 1 },
    { status: 'CLEARED', archiveIdx: 2, clearanceNumber: 'CLR-2026-001' },
  ];

  for (const state of transmissionStates) {
    const transmissionId = randomUUID();

    await prisma.einvoice_transmissions.upsert({
      where: { archiveId: archiveIds[state.archiveIdx] },
      update: {
        status: state.status,
        clearanceNumber: state.clearanceNumber,
        updatedAt: new Date(),
      },
      create: {
        id: transmissionId,
        archiveId: archiveIds[state.archiveIdx],
        companyId: company.id,
        status: state.status,
        transmissionMode: TransmissionMode.SANDBOX,
        environment: TransmissionEnvironment.SANDBOX,
        clearanceNumber: state.clearanceNumber,
        createdAt: new Date(),
        updatedAt: new Date(),
      },
    });

    transmissionIds.push(transmissionId);
  }

  console.log(`[Transmission Seed] Created ${archiveIds.length} archives, ${transmissionIds.length} transmissions`);

  return {
    companyId: company.id,
    archiveIds,
    transmissionIds,
  };
}

/**
 * Generate sample PINT-AE XML for testing
 */
function generateSampleXml(invoiceNumber: string, amount: number): string {
  const vatAmount = Math.round(amount * 5 / 105 * 100) / 100;
  const netAmount = amount - vatAmount;

  return `<?xml version="1.0" encoding="UTF-8"?>
<Invoice xmlns="urn:oasis:names:specification:ubl:schema:xsd:Invoice-2"
         xmlns:cac="urn:oasis:names:specification:ubl:schema:xsd:CommonAggregateComponents-2"
         xmlns:cbc="urn:oasis:names:specification:ubl:schema:xsd:CommonBasicComponents-2">
  <cbc:CustomizationID>urn:pint:ae:invoice:1.0</cbc:CustomizationID>
  <cbc:ID>${invoiceNumber}</cbc:ID>
  <cbc:IssueDate>2026-01-25</cbc:IssueDate>
  <cbc:InvoiceTypeCode>380</cbc:InvoiceTypeCode>
  <cbc:DocumentCurrencyCode>AED</cbc:DocumentCurrencyCode>
  <cac:AccountingSupplierParty>
    <cac:Party>
      <cac:PartyLegalEntity>
        <cbc:RegistrationName>Test Supplier LLC</cbc:RegistrationName>
      </cac:PartyLegalEntity>
      <cac:PartyTaxScheme>
        <cbc:CompanyID>100123456789012</cbc:CompanyID>
      </cac:PartyTaxScheme>
    </cac:Party>
  </cac:AccountingSupplierParty>
  <cac:AccountingCustomerParty>
    <cac:Party>
      <cac:PartyLegalEntity>
        <cbc:RegistrationName>Test Buyer Corp</cbc:RegistrationName>
      </cac:PartyLegalEntity>
    </cac:Party>
  </cac:AccountingCustomerParty>
  <cac:TaxTotal>
    <cbc:TaxAmount currencyID="AED">${vatAmount.toFixed(2)}</cbc:TaxAmount>
    <cac:TaxSubtotal>
      <cbc:TaxableAmount currencyID="AED">${netAmount.toFixed(2)}</cbc:TaxableAmount>
      <cbc:TaxAmount currencyID="AED">${vatAmount.toFixed(2)}</cbc:TaxAmount>
      <cac:TaxCategory>
        <cbc:ID>S</cbc:ID>
        <cbc:Percent>5</cbc:Percent>
      </cac:TaxCategory>
    </cac:TaxSubtotal>
  </cac:TaxTotal>
  <cac:LegalMonetaryTotal>
    <cbc:TaxExclusiveAmount currencyID="AED">${netAmount.toFixed(2)}</cbc:TaxExclusiveAmount>
    <cbc:TaxInclusiveAmount currencyID="AED">${amount.toFixed(2)}</cbc:TaxInclusiveAmount>
    <cbc:PayableAmount currencyID="AED">${amount.toFixed(2)}</cbc:PayableAmount>
  </cac:LegalMonetaryTotal>
</Invoice>`;
}

// CLI execution
if (require.main === module) {
  seedTransmissionTestData()
    .then((result) => {
      console.log('\n=== Transmission Seed Complete ===');
      console.log(`Company: ${result.companyId}`);
      console.log(`Archives: ${result.archiveIds.length}`);
      console.log(`Transmissions: ${result.transmissionIds.length}`);
      process.exit(0);
    })
    .catch((error) => {
      console.error('Seed failed:', error);
      process.exit(1);
    })
    .finally(() => prisma.$disconnect());
}

export default seedTransmissionTestData;
```
  </action>
  <verify>
    - Run `npx ts-node prisma/seeds/einvoice-transmission.seed.ts`
    - Seed creates credentials, archives, transmissions
    - Sample XML is valid PINT-AE structure
    - Seed is idempotent (safe to run multiple times)
  </verify>
  <done>Transmission seed created with sample data for testing</done>
</task>

</tasks>

<verification>
1. Controller: All endpoints implemented
2. Routes: Permission middleware on all routes
3. MFA: Required on bulk submit and credentials
4. Integration tests: Full flow coverage
5. Permission tests: Deny without required permission
6. Error tests: Handle failures gracefully
7. Seed: Sample data for manual testing
8. Cross-company: Deny access to other company data
</verification>

<success_criteria>
1. EInvoiceTransmissionController exports all endpoint methods
2. Routes registered at /api/einvoice/transmission/*
3. All routes require authenticateJWT
4. Permission middleware uses correct permission constants
5. MFA required on CREDENTIALS_MANAGE and TRANSMIT_BULK
6. Integration tests pass for queue, transmission, status, export
7. Permission denial tests pass (403 without permission)
8. Seed script creates valid test data
9. API returns consistent response format
</success_criteria>

<output>
After completion, create `.planning/phases/07-e-invoicing-transmission/07-09-SUMMARY.md`
</output>
