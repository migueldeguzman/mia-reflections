---
phase: 07-e-invoicing-transmission
plan: 05
type: execute
wave: 3
depends_on: ["07-01", "07-03", "07-04"]
files_modified:
  - web-erp-app/backend/src/services/einvoice/providers/transmission-provider.interface.ts
  - web-erp-app/backend/src/services/einvoice/providers/dctce-direct.provider.ts
  - web-erp-app/backend/src/services/einvoice/providers/sandbox.provider.ts
  - web-erp-app/backend/src/services/einvoice/providers/asp.provider.ts
autonomous: true

must_haves:
  truths:
    - "ITransmissionProvider interface implemented by all providers"
    - "DctceDirectProvider uses OAuth 2.0 authentication"
    - "SandboxProvider connects to FTA official sandbox"
    - "AspProvider routes through configured ASP"
  artifacts:
    - path: "web-erp-app/backend/src/services/einvoice/providers/transmission-provider.interface.ts"
      provides: "Provider interface definition"
      exports: ["ITransmissionProvider"]
    - path: "web-erp-app/backend/src/services/einvoice/providers/dctce-direct.provider.ts"
      provides: "Direct DCTCE provider"
      exports: ["DctceDirectProvider"]
      min_lines: 150
    - path: "web-erp-app/backend/src/services/einvoice/providers/sandbox.provider.ts"
      provides: "FTA sandbox provider"
      exports: ["SandboxProvider"]
    - path: "web-erp-app/backend/src/services/einvoice/providers/asp.provider.ts"
      provides: "ASP provider"
      exports: ["AspProvider"]
  key_links:
    - from: "dctce-direct.provider.ts"
      to: "oauth-token.service.ts"
      via: "service injection"
      pattern: "OAuthTokenService"
    - from: "sandbox.provider.ts"
      to: "transmission-provider.interface.ts"
      via: "interface implementation"
      pattern: "implements ITransmissionProvider"
---

<objective>
Create transmission provider implementations for DCTCE direct, ASP routing, and FTA sandbox following the provider interface pattern from 07-CONTEXT.md.

Purpose: EINV-09 (Real-time transmission) - actual transmission to DCTCE/ASP endpoints with proper authentication and error handling.

Output: DctceDirectProvider, AspProvider, and SandboxProvider implementing ITransmissionProvider.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-e-invoicing-transmission/07-CONTEXT.md
@.planning/phases/07-e-invoicing-transmission/07-RESEARCH.md
@.planning/phases/07-e-invoicing-transmission/07-03-SUMMARY.md
@.planning/phases/07-e-invoicing-transmission/07-04-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create transmission provider interface</name>
  <files>web-erp-app/backend/src/services/einvoice/providers/transmission-provider.interface.ts</files>
  <action>
Create the directory and provider interface:

```bash
mkdir -p web-erp-app/backend/src/services/einvoice/providers
```

```typescript
/**
 * Transmission Provider Interface
 * Phase: 07-e-invoicing-transmission
 *
 * Abstract interface for e-invoice transmission providers.
 * Implemented by DctceDirectProvider, AspProvider, and SandboxProvider.
 *
 * @module transmission-provider.interface
 */

import {
  TransmissionResult,
  TransmissionStatusResult,
  TransmissionMetadata,
  TransmissionMode,
  TransmissionEnvironment,
  CredentialRequirement,
  ProviderCredentials,
} from '../../../types/einvoice-transmission.types';

/**
 * Transmission provider interface
 *
 * All providers must implement this interface to ensure consistent
 * behavior across DCTCE direct, ASP, and sandbox modes.
 */
export interface ITransmissionProvider {
  /**
   * Provider identifier
   */
  readonly providerId: TransmissionMode;

  /**
   * Human-readable provider name
   */
  readonly providerName: string;

  /**
   * Transmit an e-invoice
   *
   * @param archiveId - E-invoice archive ID
   * @param xml - PINT-AE XML content
   * @param metadata - Invoice metadata
   * @returns Transmission result with status and references
   */
  transmit(
    archiveId: string,
    xml: string,
    metadata: TransmissionMetadata
  ): Promise<TransmissionResult>;

  /**
   * Check status of a previous transmission
   *
   * @param transmissionId - Provider's transmission reference
   * @returns Current status
   */
  checkStatus(transmissionId: string): Promise<TransmissionStatusResult>;

  /**
   * Cancel a pending transmission (optional - not all providers support)
   *
   * @param transmissionId - Provider's transmission reference
   * @returns Success status and message
   */
  cancelTransmission?(transmissionId: string): Promise<{
    success: boolean;
    message?: string;
  }>;

  /**
   * Get required credentials for this provider
   *
   * @returns List of credential requirements
   */
  getCredentialRequirements(): CredentialRequirement[];

  /**
   * Validate stored credentials are valid
   *
   * @param credentials - Credentials to validate
   * @returns True if credentials are valid
   */
  validateCredentials(credentials: ProviderCredentials): Promise<boolean>;

  /**
   * Test provider connectivity
   *
   * @returns Connection status with latency
   */
  testConnection(): Promise<{
    connected: boolean;
    latencyMs?: number;
    error?: string;
  }>;

  /**
   * Check if provider supports the environment
   *
   * @param env - Target environment
   * @returns True if environment is supported
   */
  supportsEnvironment(env: TransmissionEnvironment): boolean;

  /**
   * Check if provider is properly configured
   *
   * @returns True if all required credentials are set
   */
  isConfigured(): boolean;
}

/**
 * Provider factory function type
 */
export type TransmissionProviderFactory = (companyId: string) => Promise<ITransmissionProvider>;

/**
 * Base class for transmission providers with common utilities
 */
export abstract class BaseTransmissionProvider implements ITransmissionProvider {
  abstract readonly providerId: TransmissionMode;
  abstract readonly providerName: string;

  protected companyId: string;
  protected configured: boolean = false;

  constructor(companyId: string) {
    this.companyId = companyId;
  }

  abstract transmit(
    archiveId: string,
    xml: string,
    metadata: TransmissionMetadata
  ): Promise<TransmissionResult>;

  abstract checkStatus(transmissionId: string): Promise<TransmissionStatusResult>;

  abstract getCredentialRequirements(): CredentialRequirement[];

  abstract validateCredentials(credentials: ProviderCredentials): Promise<boolean>;

  abstract testConnection(): Promise<{
    connected: boolean;
    latencyMs?: number;
    error?: string;
  }>;

  abstract supportsEnvironment(env: TransmissionEnvironment): boolean;

  isConfigured(): boolean {
    return this.configured;
  }

  /**
   * Generate a unique transmission reference
   */
  protected generateTransmissionRef(): string {
    const timestamp = Date.now().toString(36);
    const random = Math.random().toString(36).substring(2, 8);
    return `TX-${timestamp}-${random}`.toUpperCase();
  }

  /**
   * Parse error response from provider
   */
  protected parseErrorResponse(error: unknown): {
    code: string;
    message: string;
    details?: unknown;
  } {
    if (error instanceof Error) {
      return {
        code: 'PROVIDER_ERROR',
        message: error.message,
      };
    }

    if (typeof error === 'object' && error !== null) {
      const e = error as Record<string, unknown>;
      return {
        code: String(e.code || 'UNKNOWN_ERROR'),
        message: String(e.message || 'Unknown error occurred'),
        details: e,
      };
    }

    return {
      code: 'UNKNOWN_ERROR',
      message: String(error),
    };
  }
}

export default ITransmissionProvider;
```
  </action>
  <verify>
    - `npx tsc --noEmit` compiles successfully
    - ITransmissionProvider interface exports all required methods
    - BaseTransmissionProvider provides common utilities
  </verify>
  <done>Transmission provider interface and base class created</done>
</task>

<task type="auto">
  <name>Task 2: Create DCTCE direct provider with OAuth</name>
  <files>web-erp-app/backend/src/services/einvoice/providers/dctce-direct.provider.ts</files>
  <action>
Create the DCTCE direct provider:

```typescript
/**
 * DCTCE Direct Provider
 * Phase: 07-e-invoicing-transmission
 *
 * Direct connection to FTA DCTCE platform using OAuth 2.0 authentication.
 *
 * @module dctce-direct.provider
 */

import { injectable, inject } from 'inversify';
import { AxiosInstance } from 'axios';
import { TYPES } from '../../../di/types';
import logger from '../../logger.service';
import {
  BaseTransmissionProvider,
  ITransmissionProvider,
} from './transmission-provider.interface';
import {
  TransmissionResult,
  TransmissionStatusResult,
  TransmissionMetadata,
  TransmissionMode,
  TransmissionEnvironment,
  CredentialRequirement,
  ProviderCredentials,
  EInvoiceTransmissionStatus,
  MlsStatusCode,
} from '../../../types/einvoice-transmission.types';
import { OAuthTokenService } from '../transmission/oauth-token.service';
import { CredentialStoreService } from '../transmission/credential-store.service';

// ============================================================================
// TYPES
// ============================================================================

/**
 * DCTCE submission response
 */
interface DctceSubmissionResponse {
  submissionId: string;
  referenceNumber: string;
  status: string;
  message?: string;
  errors?: Array<{
    code: string;
    message: string;
    field?: string;
  }>;
}

/**
 * DCTCE status response
 */
interface DctceStatusResponse {
  submissionId: string;
  status: string;
  clearanceNumber?: string;
  tddReference?: string;
  mlsStatus?: string;
  updatedAt: string;
  errors?: Array<{
    code: string;
    message: string;
    field?: string;
  }>;
}

// ============================================================================
// PROVIDER
// ============================================================================

@injectable()
export class DctceDirectProvider extends BaseTransmissionProvider implements ITransmissionProvider {
  readonly providerId = TransmissionMode.DIRECT_DCTCE;
  readonly providerName = 'FTA DCTCE Direct';

  private client: AxiosInstance | null = null;
  private apiEndpoint: string = '';

  constructor(
    companyId: string,
    @inject(TYPES.OAuthTokenService) private oauthService: OAuthTokenService,
    @inject(TYPES.CredentialStoreService) private credentialStore: CredentialStoreService
  ) {
    super(companyId);
  }

  /**
   * Initialize provider with credentials
   */
  async initialize(): Promise<void> {
    const credentials = await this.credentialStore.getDecryptedCredentials(this.companyId);

    if (!credentials?.dctceApiEndpoint) {
      this.configured = false;
      return;
    }

    this.apiEndpoint = credentials.dctceApiEndpoint;
    this.client = this.oauthService.createAuthenticatedClient(
      this.companyId,
      this.apiEndpoint
    );
    this.configured = true;

    logger.info('[DctceDirectProvider] Initialized', {
      companyId: this.companyId,
      endpoint: this.apiEndpoint,
    });
  }

  /**
   * Transmit e-invoice to DCTCE
   */
  async transmit(
    archiveId: string,
    xml: string,
    metadata: TransmissionMetadata
  ): Promise<TransmissionResult> {
    if (!this.client) {
      await this.initialize();
    }

    if (!this.client) {
      return {
        success: false,
        transmissionId: this.generateTransmissionRef(),
        status: EInvoiceTransmissionStatus.FAILED,
        errors: [{
          code: 'NOT_CONFIGURED',
          message: 'DCTCE provider not configured',
          severity: 'ERROR',
        }],
      };
    }

    const transmissionRef = this.generateTransmissionRef();

    logger.info('[DctceDirectProvider] Transmitting', {
      companyId: this.companyId,
      archiveId,
      transmissionRef,
    });

    try {
      const response = await this.client.post<DctceSubmissionResponse>(
        '/api/v1/einvoice/submit',
        {
          invoiceId: metadata.einvoiceNumber,
          supplierTrn: metadata.supplierTrn,
          recipientTrn: metadata.recipientTrn,
          invoiceType: metadata.invoiceType,
          totalAmount: metadata.totalAmount,
          vatAmount: metadata.vatAmount,
          currency: metadata.currency,
          issueDate: metadata.issueDate,
          xmlContent: Buffer.from(xml).toString('base64'),
        },
        {
          headers: {
            'Content-Type': 'application/json',
            'X-Correlation-Id': transmissionRef,
          },
        }
      );

      const data = response.data;

      if (data.errors && data.errors.length > 0) {
        return {
          success: false,
          transmissionId: data.submissionId || transmissionRef,
          status: EInvoiceTransmissionStatus.REJECTED,
          ftaReferenceNumber: data.referenceNumber,
          errors: data.errors.map((e) => ({
            code: e.code,
            message: e.message,
            field: e.field,
            severity: 'ERROR' as const,
          })),
          rawResponse: data,
        };
      }

      return {
        success: true,
        transmissionId: data.submissionId,
        status: this.mapDctceStatus(data.status),
        ftaReferenceNumber: data.referenceNumber,
        rawResponse: data,
        respondedAt: new Date(),
      };
    } catch (error: any) {
      const parsedError = this.parseErrorResponse(error.response?.data || error);

      logger.error('[DctceDirectProvider] Transmission failed', {
        companyId: this.companyId,
        archiveId,
        error: parsedError,
      });

      return {
        success: false,
        transmissionId: transmissionRef,
        status: EInvoiceTransmissionStatus.FAILED,
        errors: [{
          code: parsedError.code,
          message: parsedError.message,
          severity: 'ERROR',
        }],
        rawResponse: error.response?.data,
      };
    }
  }

  /**
   * Check transmission status
   */
  async checkStatus(transmissionId: string): Promise<TransmissionStatusResult> {
    if (!this.client) {
      await this.initialize();
    }

    if (!this.client) {
      throw new Error('DCTCE provider not configured');
    }

    try {
      const response = await this.client.get<DctceStatusResponse>(
        `/api/v1/einvoice/status/${transmissionId}`
      );

      const data = response.data;

      return {
        transmissionId: data.submissionId,
        status: this.mapDctceStatus(data.status),
        ftaReferenceNumber: data.clearanceNumber ? undefined : data.submissionId,
        clearanceNumber: data.clearanceNumber,
        tddReference: data.tddReference,
        mlsStatus: data.mlsStatus,
        lastUpdated: new Date(data.updatedAt),
        errors: data.errors?.map((e) => ({
          code: e.code,
          message: e.message,
          field: e.field,
          severity: 'ERROR' as const,
        })),
      };
    } catch (error: any) {
      throw new Error(`Failed to check status: ${error.message}`);
    }
  }

  /**
   * Get credential requirements
   */
  getCredentialRequirements(): CredentialRequirement[] {
    return [
      {
        field: 'dctceClientId',
        label: 'DCTCE Client ID',
        type: 'text',
        required: true,
        description: 'OAuth 2.0 client ID from FTA developer portal',
      },
      {
        field: 'dctceClientSecret',
        label: 'DCTCE Client Secret',
        type: 'password',
        required: true,
        description: 'OAuth 2.0 client secret (will be encrypted)',
      },
      {
        field: 'dctceTokenEndpoint',
        label: 'Token Endpoint URL',
        type: 'url',
        required: true,
        description: 'OAuth token endpoint (e.g., https://auth.dctce.gov.ae/oauth/token)',
        validation: /^https:\/\/.+/,
      },
      {
        field: 'dctceApiEndpoint',
        label: 'API Endpoint URL',
        type: 'url',
        required: true,
        description: 'DCTCE API base URL (e.g., https://api.dctce.gov.ae)',
        validation: /^https:\/\/.+/,
      },
    ];
  }

  /**
   * Validate credentials
   */
  async validateCredentials(credentials: ProviderCredentials): Promise<boolean> {
    return this.oauthService.validateCredentials(this.companyId);
  }

  /**
   * Test connection
   */
  async testConnection(): Promise<{
    connected: boolean;
    latencyMs?: number;
    error?: string;
  }> {
    if (!this.client) {
      await this.initialize();
    }

    if (!this.client) {
      return {
        connected: false,
        error: 'Provider not configured',
      };
    }

    const startTime = Date.now();

    try {
      await this.client.get('/api/v1/health');
      const latencyMs = Date.now() - startTime;

      return {
        connected: true,
        latencyMs,
      };
    } catch (error: any) {
      return {
        connected: false,
        latencyMs: Date.now() - startTime,
        error: error.message,
      };
    }
  }

  /**
   * Check environment support
   */
  supportsEnvironment(env: TransmissionEnvironment): boolean {
    // DCTCE Direct supports both sandbox and production
    return true;
  }

  // ============================================================================
  // PRIVATE METHODS
  // ============================================================================

  /**
   * Map DCTCE status to internal status
   */
  private mapDctceStatus(dctceStatus: string): EInvoiceTransmissionStatus {
    const statusMap: Record<string, EInvoiceTransmissionStatus> = {
      'RECEIVED': EInvoiceTransmissionStatus.PENDING_CLEARANCE,
      'PROCESSING': EInvoiceTransmissionStatus.PENDING_CLEARANCE,
      'VALIDATED': EInvoiceTransmissionStatus.PENDING_CLEARANCE,
      'PENDING_CLEARANCE': EInvoiceTransmissionStatus.PENDING_CLEARANCE,
      'CLEARED': EInvoiceTransmissionStatus.CLEARED,
      'APPROVED': EInvoiceTransmissionStatus.CLEARED,
      'REJECTED': EInvoiceTransmissionStatus.REJECTED,
      'FAILED': EInvoiceTransmissionStatus.FAILED,
      'ERROR': EInvoiceTransmissionStatus.FAILED,
    };

    return statusMap[dctceStatus.toUpperCase()] || EInvoiceTransmissionStatus.PENDING_CLEARANCE;
  }
}

export default DctceDirectProvider;
```
  </action>
  <verify>
    - `npx tsc --noEmit` compiles successfully
    - OAuth authentication via OAuthTokenService
    - Status mapping from DCTCE vocabulary
    - Error parsing and reporting
  </verify>
  <done>DctceDirectProvider created with OAuth 2.0 authentication</done>
</task>

<task type="auto">
  <name>Task 3: Create Sandbox and ASP providers</name>
  <files>
    web-erp-app/backend/src/services/einvoice/providers/sandbox.provider.ts
    web-erp-app/backend/src/services/einvoice/providers/asp.provider.ts
  </files>
  <action>
Create the sandbox provider:

```typescript
/**
 * Sandbox Provider
 * Phase: 07-e-invoicing-transmission
 *
 * FTA official sandbox for testing e-invoice transmission.
 * No local mocking - uses real FTA sandbox environment.
 *
 * @module sandbox.provider
 */

import { injectable, inject } from 'inversify';
import axios, { AxiosInstance } from 'axios';
import { TYPES } from '../../../di/types';
import logger from '../../logger.service';
import {
  BaseTransmissionProvider,
  ITransmissionProvider,
} from './transmission-provider.interface';
import {
  TransmissionResult,
  TransmissionStatusResult,
  TransmissionMetadata,
  TransmissionMode,
  TransmissionEnvironment,
  CredentialRequirement,
  ProviderCredentials,
  EInvoiceTransmissionStatus,
} from '../../../types/einvoice-transmission.types';

// FTA Sandbox configuration
const FTA_SANDBOX_URL = process.env.FTA_SANDBOX_URL || 'https://sandbox.dctce.gov.ae';

@injectable()
export class SandboxProvider extends BaseTransmissionProvider implements ITransmissionProvider {
  readonly providerId = TransmissionMode.SANDBOX;
  readonly providerName = 'FTA Sandbox';

  private client: AxiosInstance;

  constructor(companyId: string) {
    super(companyId);

    this.client = axios.create({
      baseURL: FTA_SANDBOX_URL,
      timeout: 30000,
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
    });

    // Sandbox is always configured
    this.configured = true;
  }

  /**
   * Transmit to FTA sandbox
   */
  async transmit(
    archiveId: string,
    xml: string,
    metadata: TransmissionMetadata
  ): Promise<TransmissionResult> {
    const transmissionRef = this.generateTransmissionRef();

    logger.info('[SandboxProvider] Transmitting to sandbox', {
      companyId: this.companyId,
      archiveId,
      transmissionRef,
    });

    try {
      // Sandbox accepts submissions without auth for testing
      const response = await this.client.post('/api/v1/sandbox/submit', {
        invoiceId: metadata.einvoiceNumber,
        supplierTrn: metadata.supplierTrn,
        recipientTrn: metadata.recipientTrn,
        invoiceType: metadata.invoiceType,
        totalAmount: metadata.totalAmount,
        vatAmount: metadata.vatAmount,
        xmlContent: Buffer.from(xml).toString('base64'),
        testMode: true,
      });

      const data = response.data;

      // Sandbox validates and returns immediate result
      if (data.validationErrors && data.validationErrors.length > 0) {
        return {
          success: false,
          transmissionId: data.submissionId || transmissionRef,
          status: EInvoiceTransmissionStatus.REJECTED,
          errors: data.validationErrors.map((e: any) => ({
            code: e.code,
            message: e.message,
            field: e.field,
            severity: 'ERROR' as const,
          })),
          rawResponse: data,
        };
      }

      return {
        success: true,
        transmissionId: data.submissionId || transmissionRef,
        status: EInvoiceTransmissionStatus.CLEARED, // Sandbox clears immediately
        ftaReferenceNumber: data.referenceNumber,
        clearanceNumber: `SB-${transmissionRef}`, // Sandbox clearance
        tddReference: data.tddReference,
        rawResponse: data,
        respondedAt: new Date(),
      };
    } catch (error: any) {
      const parsedError = this.parseErrorResponse(error.response?.data || error);

      logger.error('[SandboxProvider] Sandbox submission failed', {
        companyId: this.companyId,
        archiveId,
        error: parsedError,
      });

      return {
        success: false,
        transmissionId: transmissionRef,
        status: EInvoiceTransmissionStatus.FAILED,
        errors: [{
          code: parsedError.code,
          message: parsedError.message,
          severity: 'ERROR',
        }],
        rawResponse: error.response?.data,
      };
    }
  }

  /**
   * Check sandbox status (usually immediate)
   */
  async checkStatus(transmissionId: string): Promise<TransmissionStatusResult> {
    try {
      const response = await this.client.get(`/api/v1/sandbox/status/${transmissionId}`);
      const data = response.data;

      return {
        transmissionId,
        status: data.status === 'CLEARED' ?
          EInvoiceTransmissionStatus.CLEARED :
          EInvoiceTransmissionStatus.REJECTED,
        clearanceNumber: data.clearanceNumber,
        tddReference: data.tddReference,
        lastUpdated: new Date(),
        errors: data.errors?.map((e: any) => ({
          code: e.code,
          message: e.message,
          severity: 'ERROR' as const,
        })),
      };
    } catch (error: any) {
      throw new Error(`Failed to check sandbox status: ${error.message}`);
    }
  }

  /**
   * Sandbox doesn't require credentials
   */
  getCredentialRequirements(): CredentialRequirement[] {
    return []; // No credentials needed for sandbox
  }

  /**
   * Sandbox is always valid
   */
  async validateCredentials(_credentials: ProviderCredentials): Promise<boolean> {
    return true;
  }

  /**
   * Test sandbox connection
   */
  async testConnection(): Promise<{
    connected: boolean;
    latencyMs?: number;
    error?: string;
  }> {
    const startTime = Date.now();

    try {
      await this.client.get('/api/v1/health');
      return {
        connected: true,
        latencyMs: Date.now() - startTime,
      };
    } catch (error: any) {
      return {
        connected: false,
        latencyMs: Date.now() - startTime,
        error: error.message,
      };
    }
  }

  /**
   * Sandbox only supports SANDBOX environment
   */
  supportsEnvironment(env: TransmissionEnvironment): boolean {
    return env === TransmissionEnvironment.SANDBOX;
  }
}

export default SandboxProvider;
```

Create the ASP provider:

```typescript
/**
 * ASP Provider
 * Phase: 07-e-invoicing-transmission
 *
 * Routes e-invoices through tenant's chosen Accredited Service Provider (ASP).
 *
 * @module asp.provider
 */

import { injectable, inject } from 'inversify';
import axios, { AxiosInstance } from 'axios';
import { TYPES } from '../../../di/types';
import logger from '../../logger.service';
import {
  BaseTransmissionProvider,
  ITransmissionProvider,
} from './transmission-provider.interface';
import {
  TransmissionResult,
  TransmissionStatusResult,
  TransmissionMetadata,
  TransmissionMode,
  TransmissionEnvironment,
  CredentialRequirement,
  ProviderCredentials,
  EInvoiceTransmissionStatus,
} from '../../../types/einvoice-transmission.types';
import { CredentialStoreService } from '../transmission/credential-store.service';

@injectable()
export class AspProvider extends BaseTransmissionProvider implements ITransmissionProvider {
  readonly providerId = TransmissionMode.ASP_PROVIDER;
  readonly providerName = 'Accredited Service Provider';

  private client: AxiosInstance | null = null;
  private aspEndpoint: string = '';
  private aspProviderName: string = '';

  constructor(
    companyId: string,
    @inject(TYPES.CredentialStoreService) private credentialStore: CredentialStoreService
  ) {
    super(companyId);
  }

  /**
   * Initialize with ASP credentials
   */
  async initialize(): Promise<void> {
    const credentials = await this.credentialStore.getDecryptedCredentials(this.companyId);

    if (!credentials?.aspEndpoint || !credentials?.aspApiKey) {
      this.configured = false;
      return;
    }

    this.aspEndpoint = credentials.aspEndpoint;
    this.aspProviderName = credentials.aspProviderName || 'ASP';

    this.client = axios.create({
      baseURL: this.aspEndpoint,
      timeout: 30000,
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
        'X-API-Key': credentials.aspApiKey,
        'X-ASP-Identifier': credentials.aspIdentifier || '',
      },
    });

    this.configured = true;

    logger.info('[AspProvider] Initialized', {
      companyId: this.companyId,
      aspProvider: this.aspProviderName,
    });
  }

  /**
   * Transmit via ASP
   */
  async transmit(
    archiveId: string,
    xml: string,
    metadata: TransmissionMetadata
  ): Promise<TransmissionResult> {
    if (!this.client) {
      await this.initialize();
    }

    if (!this.client) {
      return {
        success: false,
        transmissionId: this.generateTransmissionRef(),
        status: EInvoiceTransmissionStatus.FAILED,
        errors: [{
          code: 'NOT_CONFIGURED',
          message: 'ASP provider not configured',
          severity: 'ERROR',
        }],
      };
    }

    const transmissionRef = this.generateTransmissionRef();

    logger.info('[AspProvider] Transmitting via ASP', {
      companyId: this.companyId,
      archiveId,
      aspProvider: this.aspProviderName,
      transmissionRef,
    });

    try {
      // ASP-specific API format (varies by provider)
      const response = await this.client.post('/einvoice/submit', {
        clientReference: transmissionRef,
        invoice: {
          number: metadata.einvoiceNumber,
          type: metadata.invoiceType,
          supplierTrn: metadata.supplierTrn,
          recipientTrn: metadata.recipientTrn,
          totalAmount: metadata.totalAmount,
          vatAmount: metadata.vatAmount,
          currency: metadata.currency,
          issueDate: metadata.issueDate,
        },
        document: {
          format: 'PINT_AE',
          content: Buffer.from(xml).toString('base64'),
          encoding: 'base64',
        },
      });

      const data = response.data;

      if (data.status === 'REJECTED' || (data.errors && data.errors.length > 0)) {
        return {
          success: false,
          transmissionId: data.aspReference || transmissionRef,
          status: EInvoiceTransmissionStatus.REJECTED,
          ftaReferenceNumber: data.ftaReference,
          errors: (data.errors || []).map((e: any) => ({
            code: e.code,
            message: e.message,
            field: e.field,
            severity: 'ERROR' as const,
          })),
          rawResponse: data,
        };
      }

      return {
        success: true,
        transmissionId: data.aspReference || transmissionRef,
        status: this.mapAspStatus(data.status),
        ftaReferenceNumber: data.ftaReference,
        tddReference: data.tddReference,
        mlsStatus: data.mlsStatus,
        rawResponse: data,
        respondedAt: new Date(),
      };
    } catch (error: any) {
      const parsedError = this.parseErrorResponse(error.response?.data || error);

      logger.error('[AspProvider] ASP transmission failed', {
        companyId: this.companyId,
        archiveId,
        aspProvider: this.aspProviderName,
        error: parsedError,
      });

      return {
        success: false,
        transmissionId: transmissionRef,
        status: EInvoiceTransmissionStatus.FAILED,
        errors: [{
          code: parsedError.code,
          message: parsedError.message,
          severity: 'ERROR',
        }],
        rawResponse: error.response?.data,
      };
    }
  }

  /**
   * Check ASP status
   */
  async checkStatus(transmissionId: string): Promise<TransmissionStatusResult> {
    if (!this.client) {
      await this.initialize();
    }

    if (!this.client) {
      throw new Error('ASP provider not configured');
    }

    try {
      const response = await this.client.get(`/einvoice/status/${transmissionId}`);
      const data = response.data;

      return {
        transmissionId,
        status: this.mapAspStatus(data.status),
        ftaReferenceNumber: data.ftaReference,
        clearanceNumber: data.clearanceNumber,
        tddReference: data.tddReference,
        mlsStatus: data.mlsStatus,
        lastUpdated: new Date(data.updatedAt || Date.now()),
        errors: data.errors?.map((e: any) => ({
          code: e.code,
          message: e.message,
          severity: 'ERROR' as const,
        })),
      };
    } catch (error: any) {
      throw new Error(`Failed to check ASP status: ${error.message}`);
    }
  }

  /**
   * Cancel via ASP (if supported)
   */
  async cancelTransmission(transmissionId: string): Promise<{
    success: boolean;
    message?: string;
  }> {
    if (!this.client) {
      return { success: false, message: 'ASP provider not configured' };
    }

    try {
      await this.client.delete(`/einvoice/cancel/${transmissionId}`);
      return { success: true };
    } catch (error: any) {
      return {
        success: false,
        message: error.response?.data?.message || error.message,
      };
    }
  }

  /**
   * ASP credential requirements
   */
  getCredentialRequirements(): CredentialRequirement[] {
    return [
      {
        field: 'aspApiKey',
        label: 'ASP API Key',
        type: 'password',
        required: true,
        description: 'API key provided by your ASP (will be encrypted)',
      },
      {
        field: 'aspEndpoint',
        label: 'ASP Endpoint URL',
        type: 'url',
        required: true,
        description: 'Base URL of your ASP API',
        validation: /^https:\/\/.+/,
      },
      {
        field: 'aspIdentifier',
        label: 'ASP Client Identifier',
        type: 'text',
        required: true,
        description: 'Your unique identifier with the ASP',
      },
      {
        field: 'aspProviderName',
        label: 'ASP Provider Name',
        type: 'text',
        required: false,
        description: 'Name of your ASP (for display purposes)',
      },
    ];
  }

  /**
   * Validate ASP credentials
   */
  async validateCredentials(credentials: ProviderCredentials): Promise<boolean> {
    const result = await this.testConnection();
    return result.connected;
  }

  /**
   * Test ASP connection
   */
  async testConnection(): Promise<{
    connected: boolean;
    latencyMs?: number;
    error?: string;
  }> {
    if (!this.client) {
      await this.initialize();
    }

    if (!this.client) {
      return { connected: false, error: 'ASP provider not configured' };
    }

    const startTime = Date.now();

    try {
      await this.client.get('/health');
      return {
        connected: true,
        latencyMs: Date.now() - startTime,
      };
    } catch (error: any) {
      return {
        connected: false,
        latencyMs: Date.now() - startTime,
        error: error.message,
      };
    }
  }

  /**
   * ASP supports both environments
   */
  supportsEnvironment(env: TransmissionEnvironment): boolean {
    return true;
  }

  // ============================================================================
  // PRIVATE
  // ============================================================================

  private mapAspStatus(aspStatus: string): EInvoiceTransmissionStatus {
    const statusMap: Record<string, EInvoiceTransmissionStatus> = {
      'RECEIVED': EInvoiceTransmissionStatus.PENDING_CLEARANCE,
      'PROCESSING': EInvoiceTransmissionStatus.PENDING_CLEARANCE,
      'PENDING': EInvoiceTransmissionStatus.PENDING_CLEARANCE,
      'CLEARED': EInvoiceTransmissionStatus.CLEARED,
      'APPROVED': EInvoiceTransmissionStatus.CLEARED,
      'ACCEPTED': EInvoiceTransmissionStatus.CLEARED,
      'REJECTED': EInvoiceTransmissionStatus.REJECTED,
      'FAILED': EInvoiceTransmissionStatus.FAILED,
      'ERROR': EInvoiceTransmissionStatus.FAILED,
    };

    return statusMap[aspStatus?.toUpperCase()] || EInvoiceTransmissionStatus.PENDING_CLEARANCE;
  }
}

export default AspProvider;
```
  </action>
  <verify>
    - `npx tsc --noEmit` compiles successfully
    - SandboxProvider connects to FTA sandbox
    - AspProvider uses API key authentication
    - Both implement ITransmissionProvider interface
    - Status mapping for provider-specific vocabularies
  </verify>
  <done>SandboxProvider and AspProvider created implementing ITransmissionProvider</done>
</task>

</tasks>

<verification>
1. Types compile: `npx tsc --noEmit` passes
2. Interface: ITransmissionProvider defines all required methods
3. DctceDirectProvider: OAuth via OAuthTokenService
4. SandboxProvider: Connects to FTA_SANDBOX_URL
5. AspProvider: API key authentication from credentials
6. Status mapping: Provider-specific status to internal enum
7. Error handling: Consistent error parsing across providers
8. Connection testing: All providers implement testConnection()
</verification>

<success_criteria>
1. ITransmissionProvider interface exported with all methods
2. BaseTransmissionProvider provides common utilities
3. DctceDirectProvider uses OAuthTokenService for authentication
4. DctceDirectProvider maps DCTCE status vocabulary
5. SandboxProvider requires no credentials
6. SandboxProvider returns immediate validation results
7. AspProvider uses API key from encrypted credentials
8. AspProvider supports cancel operation
9. All providers implement testConnection() for health checks
</success_criteria>

<output>
After completion, create `.planning/phases/07-e-invoicing-transmission/07-05-SUMMARY.md`
</output>
