---
phase: 08-compliance-verification
plan: 08
type: execute
wave: 4
depends_on: ["08-01", "08-02", "08-03", "08-04", "08-05", "08-06", "08-07"]
files_modified:
  - web-erp-app/backend/src/services/compliance-portal/__tests__/compliance-portal.service.test.ts
  - web-erp-app/backend/src/services/compliance-portal/__tests__/compliance-checklist.service.test.ts
  - web-erp-app/backend/src/services/compliance-portal/__tests__/compliance-signoff.service.test.ts
  - web-erp-app/backend/prisma/seeds/compliance-portal-permissions.seed.ts
autonomous: true

must_haves:
  truths:
    - "Unit tests cover all critical service methods"
    - "Permissions exist for compliance portal operations"
    - "Tests verify company access isolation"
  artifacts:
    - path: "web-erp-app/backend/src/services/compliance-portal/__tests__/compliance-portal.service.test.ts"
      provides: "Unit tests for CompliancePortalService"
      min_lines: 100
    - path: "web-erp-app/backend/prisma/seeds/compliance-portal-permissions.seed.ts"
      provides: "Portal permission seed script"
      exports: ["seedCompliancePortalPermissions"]
  key_links:
    - from: "compliance-portal.service.test.ts"
      to: "CompliancePortalService"
      via: "jest mock and describe blocks"
      pattern: "describe.*CompliancePortalService"
---

<objective>
Create unit tests for compliance portal services and permission seed script.

Purpose: Ensure all portal services work correctly through comprehensive testing and proper RBAC setup for portal access.

Output: Test suites for core services and a permission seed script for portal operations.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-compliance-verification-portal/08-RESEARCH.md

# Prior plan summaries
@.planning/phases/08-compliance-verification-portal/08-07-SUMMARY.md

# Existing test patterns
@web-erp-app/backend/src/services/einvoice/__tests__/einvoice.service.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CompliancePortalService tests</name>
  <files>web-erp-app/backend/src/services/compliance-portal/__tests__/compliance-portal.service.test.ts</files>
  <action>
Create unit tests for CompliancePortalService:

```typescript
/**
 * CompliancePortalService Tests
 *
 * Phase: 08-compliance-verification
 * Plan: 08-08
 *
 * Tests for the compliance portal status aggregation service.
 */

import { CompliancePortalService } from '../compliance-portal.service';
import { PrismaClient } from '@prisma/client';

// Mock PrismaClient
jest.mock('@prisma/client', () => {
  const mockPrisma = {
    companies: {
      findUnique: jest.fn(),
    },
    users: {
      findUnique: jest.fn(),
    },
    fiscal_years: {
      findFirst: jest.fn(),
    },
    $queryRaw: jest.fn(),
  };

  return {
    PrismaClient: jest.fn().mockImplementation(() => mockPrisma),
  };
});

describe('CompliancePortalService', () => {
  let service: CompliancePortalService;
  let mockPrisma: jest.Mocked<PrismaClient>;

  const testCompanyId = 'test-company-uuid';
  const testUserId = 'test-user-uuid';

  beforeEach(() => {
    jest.clearAllMocks();
    mockPrisma = new PrismaClient() as jest.Mocked<PrismaClient>;
    service = new CompliancePortalService(mockPrisma);
  });

  describe('getComplianceStatus', () => {
    beforeEach(() => {
      // Setup user validation mock
      (mockPrisma.users.findUnique as jest.Mock).mockResolvedValue({
        id: testUserId,
        companyId: testCompanyId,
      });

      // Setup company mock with valid TRN
      (mockPrisma.companies.findUnique as jest.Mock).mockResolvedValue({
        id: testCompanyId,
        taxNumber: '100123456789012', // Valid TRN format
      });

      // Setup fiscal year mock
      (mockPrisma.fiscal_years.findFirst as jest.Mock).mockResolvedValue({
        id: 'fiscal-year-uuid',
        yearName: '2026',
      });

      // Setup raw query mocks
      (mockPrisma.$queryRaw as jest.Mock).mockResolvedValue([{ count: 1n }]);
    });

    it('should return compliance status for all domains', async () => {
      const status = await service.getComplianceStatus(
        testCompanyId,
        testUserId
      );

      expect(status).toBeDefined();
      expect(status.overall).toBeDefined();
      expect(status.domains.vat).toBeDefined();
      expect(status.domains.corporateTax).toBeDefined();
      expect(status.domains.wps).toBeDefined();
      expect(status.domains.eInvoice).toBeDefined();
    });

    it('should return COMPLIANT when all domains pass', async () => {
      const status = await service.getComplianceStatus(
        testCompanyId,
        testUserId
      );

      // With valid TRN and fiscal year, should have passing status
      expect(['COMPLIANT', 'WARNING']).toContain(status.overall);
    });

    it('should cache results and return cached status', async () => {
      // First call
      await service.getComplianceStatus(testCompanyId, testUserId);

      // Reset mock call counts
      jest.clearAllMocks();

      // Second call (should use cache)
      await service.getComplianceStatus(testCompanyId, testUserId, false);

      // Should not query database again
      expect(mockPrisma.companies.findUnique).not.toHaveBeenCalled();
    });

    it('should bypass cache when forceRefresh is true', async () => {
      // First call
      await service.getComplianceStatus(testCompanyId, testUserId);

      // Reset mock call counts
      (mockPrisma.users.findUnique as jest.Mock).mockResolvedValue({
        id: testUserId,
        companyId: testCompanyId,
      });
      (mockPrisma.companies.findUnique as jest.Mock).mockResolvedValue({
        id: testCompanyId,
        taxNumber: '100123456789012',
      });

      // Second call with forceRefresh
      await service.getComplianceStatus(testCompanyId, testUserId, true);

      // Should query database again
      expect(mockPrisma.companies.findUnique).toHaveBeenCalled();
    });

    it('should deny access to different company', async () => {
      (mockPrisma.users.findUnique as jest.Mock).mockResolvedValue({
        id: testUserId,
        companyId: 'different-company-uuid',
      });

      await expect(
        service.getComplianceStatus(testCompanyId, testUserId)
      ).rejects.toThrow('Access denied');
    });

    it('should handle missing user', async () => {
      (mockPrisma.users.findUnique as jest.Mock).mockResolvedValue(null);

      await expect(
        service.getComplianceStatus(testCompanyId, testUserId)
      ).rejects.toThrow('User not found');
    });
  });

  describe('getDomainStatus', () => {
    beforeEach(() => {
      (mockPrisma.companies.findUnique as jest.Mock).mockResolvedValue({
        id: testCompanyId,
        taxNumber: '100123456789012',
      });
      (mockPrisma.$queryRaw as jest.Mock).mockResolvedValue([{ count: 1n }]);
    });

    it('should return VAT status with TRN check', async () => {
      const status = await service.getDomainStatus(testCompanyId, 'VAT');

      expect(status).toBeDefined();
      expect(status.status).toBeDefined();
      expect(status.checksPassed).toBeGreaterThanOrEqual(0);
      expect(status.checksTotal).toBeGreaterThan(0);
    });

    it('should return FAIL when TRN is invalid', async () => {
      (mockPrisma.companies.findUnique as jest.Mock).mockResolvedValue({
        id: testCompanyId,
        taxNumber: 'invalid-trn',
      });

      const status = await service.getDomainStatus(testCompanyId, 'VAT');

      expect(status.status).toBe('FAIL');
      expect(status.criticalIssues.length).toBeGreaterThan(0);
    });

    it('should return CT status', async () => {
      (mockPrisma.fiscal_years.findFirst as jest.Mock).mockResolvedValue({
        id: 'fy-uuid',
        yearName: '2026',
      });

      const status = await service.getDomainStatus(testCompanyId, 'CT');

      expect(status).toBeDefined();
      expect(status.status).toBeDefined();
    });

    it('should return WPS status', async () => {
      const status = await service.getDomainStatus(testCompanyId, 'WPS');

      expect(status).toBeDefined();
      expect(status.status).toBeDefined();
    });

    it('should return EINVOICE status', async () => {
      const status = await service.getDomainStatus(testCompanyId, 'EINVOICE');

      expect(status).toBeDefined();
      expect(status.status).toBeDefined();
    });
  });

  describe('invalidateCache', () => {
    it('should clear cached status for company', async () => {
      // Setup mocks
      (mockPrisma.users.findUnique as jest.Mock).mockResolvedValue({
        id: testUserId,
        companyId: testCompanyId,
      });
      (mockPrisma.companies.findUnique as jest.Mock).mockResolvedValue({
        id: testCompanyId,
        taxNumber: '100123456789012',
      });
      (mockPrisma.$queryRaw as jest.Mock).mockResolvedValue([{ count: 1n }]);

      // Cache a result
      await service.getComplianceStatus(testCompanyId, testUserId);

      // Invalidate cache
      service.invalidateCache(testCompanyId);

      // Reset mocks
      jest.clearAllMocks();
      (mockPrisma.users.findUnique as jest.Mock).mockResolvedValue({
        id: testUserId,
        companyId: testCompanyId,
      });
      (mockPrisma.companies.findUnique as jest.Mock).mockResolvedValue({
        id: testCompanyId,
        taxNumber: '100123456789012',
      });

      // Should query again after invalidation
      await service.getComplianceStatus(testCompanyId, testUserId);
      expect(mockPrisma.companies.findUnique).toHaveBeenCalled();
    });
  });

  describe('getDashboardSummary', () => {
    beforeEach(() => {
      (mockPrisma.users.findUnique as jest.Mock).mockResolvedValue({
        id: testUserId,
        companyId: testCompanyId,
      });
      (mockPrisma.companies.findUnique as jest.Mock).mockResolvedValue({
        id: testCompanyId,
        taxNumber: '100123456789012',
      });
      (mockPrisma.$queryRaw as jest.Mock).mockResolvedValue([{ count: 1n }]);
    });

    it('should return dashboard-friendly summary', async () => {
      const summary = await service.getDashboardSummary(
        testCompanyId,
        testUserId
      );

      expect(summary.overallStatus).toBeDefined();
      expect(summary.domains).toHaveLength(4);
      expect(summary.lastUpdated).toBeInstanceOf(Date);
    });

    it('should include all four domains in summary', async () => {
      const summary = await service.getDashboardSummary(
        testCompanyId,
        testUserId
      );

      const domainNames = summary.domains.map((d) => d.name);
      expect(domainNames).toContain('VAT');
      expect(domainNames).toContain('Corporate Tax');
      expect(domainNames).toContain('WPS Payroll');
      expect(domainNames).toContain('E-Invoice');
    });
  });
});
```
  </action>
  <verify>cd web-erp-app/backend && npm test -- --testPathPattern="compliance-portal.service.test" --passWithNoTests</verify>
  <done>CompliancePortalService tests created with 12+ test cases</done>
</task>

<task type="auto">
  <name>Task 2: Create ComplianceChecklistService and SignOffService tests</name>
  <files>
    web-erp-app/backend/src/services/compliance-portal/__tests__/compliance-checklist.service.test.ts
    web-erp-app/backend/src/services/compliance-portal/__tests__/compliance-signoff.service.test.ts
  </files>
  <action>
Create additional test files:

**compliance-checklist.service.test.ts:**
```typescript
/**
 * ComplianceChecklistService Tests
 *
 * Phase: 08-compliance-verification
 * Plan: 08-08
 */

import { ComplianceChecklistService } from '../compliance-checklist.service';
import { PrismaClient } from '@prisma/client';

jest.mock('@prisma/client', () => {
  const mockPrisma = {
    companies: {
      findUnique: jest.fn(),
    },
    compliance_check_runs: {
      create: jest.fn(),
      findMany: jest.fn(),
    },
    $queryRaw: jest.fn(),
  };

  return {
    PrismaClient: jest.fn().mockImplementation(() => mockPrisma),
  };
});

describe('ComplianceChecklistService', () => {
  let service: ComplianceChecklistService;
  let mockPrisma: jest.Mocked<PrismaClient>;

  const testCompanyId = 'test-company-uuid';

  beforeEach(() => {
    jest.clearAllMocks();
    mockPrisma = new PrismaClient() as jest.Mocked<PrismaClient>;
    service = new ComplianceChecklistService(mockPrisma);
  });

  describe('getCheckDefinitions', () => {
    it('should return VAT check definitions', () => {
      const checks = service.getCheckDefinitions('VAT');
      expect(checks).toBeInstanceOf(Array);
      expect(checks.length).toBeGreaterThan(0);
      expect(checks[0].id).toMatch(/^VAT-/);
    });

    it('should return CT check definitions', () => {
      const checks = service.getCheckDefinitions('CT');
      expect(checks).toBeInstanceOf(Array);
      expect(checks[0].id).toMatch(/^CT-/);
    });

    it('should return WPS check definitions', () => {
      const checks = service.getCheckDefinitions('WPS');
      expect(checks).toBeInstanceOf(Array);
      expect(checks[0].id).toMatch(/^WPS-/);
    });

    it('should return EINVOICE check definitions', () => {
      const checks = service.getCheckDefinitions('EINVOICE');
      expect(checks).toBeInstanceOf(Array);
      expect(checks[0].id).toMatch(/^EINV-/);
    });
  });

  describe('getCheckById', () => {
    it('should find check by ID', () => {
      const check = service.getCheckById('VAT-01');
      expect(check).toBeDefined();
      expect(check?.id).toBe('VAT-01');
      expect(check?.name).toBe('TRN Validation');
    });

    it('should return undefined for unknown ID', () => {
      const check = service.getCheckById('UNKNOWN-99');
      expect(check).toBeUndefined();
    });
  });

  describe('runChecklist', () => {
    beforeEach(() => {
      (mockPrisma.companies.findUnique as jest.Mock).mockResolvedValue({
        id: testCompanyId,
        taxNumber: '100123456789012',
      });
      (mockPrisma.$queryRaw as jest.Mock).mockResolvedValue([{ count: 1n }]);
      (mockPrisma.compliance_check_runs.create as jest.Mock).mockResolvedValue({
        id: 'check-run-uuid',
      });
    });

    it('should run all VAT checks', async () => {
      const result = await service.runChecklist(testCompanyId, 'VAT');

      expect(result.checksTotal).toBeGreaterThan(0);
      expect(result.checksPassed).toBeLessThanOrEqual(result.checksTotal);
      expect(result.lastCheckedAt).toBeInstanceOf(Date);
    });

    it('should store check run results', async () => {
      await service.runChecklist(testCompanyId, 'VAT', undefined, 'user-id', 'MANUAL');

      expect(mockPrisma.compliance_check_runs.create).toHaveBeenCalled();
    });

    it('should include critical issues and warnings', async () => {
      const result = await service.runChecklist(testCompanyId, 'VAT');

      expect(result.criticalIssues).toBeInstanceOf(Array);
      expect(result.warnings).toBeInstanceOf(Array);
    });
  });

  describe('getCheckRunHistory', () => {
    it('should return check run history', async () => {
      const mockHistory = [
        {
          id: 'run-1',
          domain: 'VAT',
          status: 'PASS',
          checksPassed: 5,
          checksTotal: 5,
          triggeredBy: 'user-id',
          triggerType: 'MANUAL',
          runDurationMs: 150,
          createdAt: new Date(),
        },
      ];

      (mockPrisma.compliance_check_runs.findMany as jest.Mock).mockResolvedValue(mockHistory);

      const history = await service.getCheckRunHistory(testCompanyId, 'VAT');

      expect(history).toBeInstanceOf(Array);
      expect(history[0].domain).toBe('VAT');
    });
  });
});
```

**compliance-signoff.service.test.ts:**
```typescript
/**
 * ComplianceSignOffService Tests
 *
 * Phase: 08-compliance-verification
 * Plan: 08-08
 */

import { ComplianceSignOffService } from '../compliance-signoff.service';
import { PrismaClient } from '@prisma/client';

jest.mock('@prisma/client', () => {
  const mockPrisma = {
    users: {
      findUnique: jest.fn(),
    },
    compliance_sign_offs: {
      findFirst: jest.fn(),
      findUnique: jest.fn(),
      findMany: jest.fn(),
      create: jest.fn(),
      update: jest.fn(),
    },
    audit_logs: {
      create: jest.fn(),
    },
    approval_workflows: {
      findFirst: jest.fn(),
    },
    userRole_New: {
      findMany: jest.fn(),
    },
  };

  return {
    PrismaClient: jest.fn().mockImplementation(() => mockPrisma),
  };
});

describe('ComplianceSignOffService', () => {
  let service: ComplianceSignOffService;
  let mockPrisma: jest.Mocked<PrismaClient>;

  const testCompanyId = 'test-company-uuid';
  const testUserId = 'test-user-uuid';

  beforeEach(() => {
    jest.clearAllMocks();
    mockPrisma = new PrismaClient() as jest.Mocked<PrismaClient>;
    service = new ComplianceSignOffService(mockPrisma);

    // Default user mock
    (mockPrisma.users.findUnique as jest.Mock).mockResolvedValue({
      id: testUserId,
      companyId: testCompanyId,
      firstName: 'Test',
      lastName: 'User',
      email: 'test@example.com',
    });
  });

  describe('submitForSignOff', () => {
    const validRequest = {
      companyId: testCompanyId,
      domain: 'VAT' as const,
      periodId: 'period-uuid',
      submitterId: testUserId,
      checklistResults: {
        status: 'PASS' as const,
        checksPassed: 5,
        checksTotal: 5,
        criticalIssues: [],
        warnings: [],
        lastCheckedAt: new Date(),
      },
      previewData: {
        domain: 'VAT' as const,
        periodId: 'period-uuid',
        format: 'FORM_201' as const,
        previewHtml: '<html>...</html>',
        rawData: {},
        summary: {
          totalRecords: 10,
          totalAmount: 100000,
          totalTax: 5000,
          filingDeadline: new Date(),
        },
        validationStatus: 'VALID' as const,
        validationMessages: [],
      },
    };

    beforeEach(() => {
      (mockPrisma.compliance_sign_offs.findFirst as jest.Mock).mockResolvedValue(null);
      (mockPrisma.compliance_sign_offs.create as jest.Mock).mockResolvedValue({
        id: 'signoff-uuid',
      });
      (mockPrisma.audit_logs.create as jest.Mock).mockResolvedValue({});
      (mockPrisma.approval_workflows.findFirst as jest.Mock).mockResolvedValue(null);
    });

    it('should create sign-off record', async () => {
      const result = await service.submitForSignOff(validRequest, testUserId);

      expect(result.signOffId).toBeDefined();
      expect(result.status).toBe('PENDING_APPROVAL');
      expect(mockPrisma.compliance_sign_offs.create).toHaveBeenCalled();
    });

    it('should reject if critical checks failed', async () => {
      const failedRequest = {
        ...validRequest,
        checklistResults: {
          ...validRequest.checklistResults,
          status: 'FAIL' as const,
        },
      };

      await expect(
        service.submitForSignOff(failedRequest, testUserId)
      ).rejects.toThrow('failing critical checks');
    });

    it('should reject if pending sign-off exists', async () => {
      (mockPrisma.compliance_sign_offs.findFirst as jest.Mock).mockResolvedValue({
        id: 'existing-signoff',
        status: 'PENDING_APPROVAL',
      });

      await expect(
        service.submitForSignOff(validRequest, testUserId)
      ).rejects.toThrow('pending sign-off already exists');
    });

    it('should create audit log entry', async () => {
      await service.submitForSignOff(validRequest, testUserId);

      expect(mockPrisma.audit_logs.create).toHaveBeenCalled();
    });
  });

  describe('approveSignOff', () => {
    const mockSignOff = {
      id: 'signoff-uuid',
      companyId: testCompanyId,
      domain: 'VAT',
      periodId: 'period-uuid',
      status: 'PENDING_APPROVAL',
      approvalRecord: null,
    };

    beforeEach(() => {
      (mockPrisma.compliance_sign_offs.findUnique as jest.Mock).mockResolvedValue(mockSignOff);
      (mockPrisma.compliance_sign_offs.update as jest.Mock).mockResolvedValue({
        ...mockSignOff,
        status: 'APPROVED',
      });
      (mockPrisma.userRole_New.findMany as jest.Mock).mockResolvedValue([
        { role: { name: 'CFO' } },
      ]);
    });

    it('should approve sign-off and update status', async () => {
      const result = await service.approveSignOff('signoff-uuid', testUserId);

      expect(result.isFullyApproved).toBe(true);
      expect(mockPrisma.compliance_sign_offs.update).toHaveBeenCalledWith(
        expect.objectContaining({
          data: expect.objectContaining({ status: 'APPROVED' }),
        })
      );
    });

    it('should create audit log for approval', async () => {
      await service.approveSignOff('signoff-uuid', testUserId);

      expect(mockPrisma.audit_logs.create).toHaveBeenCalled();
    });

    it('should reject if sign-off not found', async () => {
      (mockPrisma.compliance_sign_offs.findUnique as jest.Mock).mockResolvedValue(null);

      await expect(
        service.approveSignOff('nonexistent-uuid', testUserId)
      ).rejects.toThrow('Sign-off not found');
    });

    it('should reject if already approved', async () => {
      (mockPrisma.compliance_sign_offs.findUnique as jest.Mock).mockResolvedValue({
        ...mockSignOff,
        status: 'APPROVED',
      });

      await expect(
        service.approveSignOff('signoff-uuid', testUserId)
      ).rejects.toThrow('Cannot approve');
    });
  });

  describe('rejectSignOff', () => {
    const mockSignOff = {
      id: 'signoff-uuid',
      companyId: testCompanyId,
      domain: 'VAT',
      status: 'PENDING_APPROVAL',
    };

    beforeEach(() => {
      (mockPrisma.compliance_sign_offs.findUnique as jest.Mock).mockResolvedValue(mockSignOff);
      (mockPrisma.compliance_sign_offs.update as jest.Mock).mockResolvedValue({});
    });

    it('should reject sign-off with reason', async () => {
      await service.rejectSignOff('signoff-uuid', testUserId, 'Data incomplete');

      expect(mockPrisma.compliance_sign_offs.update).toHaveBeenCalledWith(
        expect.objectContaining({
          data: expect.objectContaining({
            status: 'REJECTED',
            rejectedReason: 'Data incomplete',
          }),
        })
      );
    });

    it('should require rejection reason', async () => {
      await expect(
        service.rejectSignOff('signoff-uuid', testUserId, '')
      ).rejects.toThrow('Rejection reason is required');
    });
  });

  describe('getApprovalHistory', () => {
    it('should return approval history with filters', async () => {
      const mockHistory = [
        {
          id: 'signoff-1',
          domain: 'VAT',
          periodId: 'period-1',
          status: 'APPROVED',
          submittedAt: new Date(),
          approvedAt: new Date(),
          submittedBy: {
            id: 'user-1',
            firstName: 'John',
            lastName: 'Doe',
            email: 'john@example.com',
          },
          approvalRecord: { approvals: [] },
        },
      ];

      (mockPrisma.compliance_sign_offs.findMany as jest.Mock).mockResolvedValue(mockHistory);

      const history = await service.getApprovalHistory(
        testCompanyId,
        testUserId,
        { domain: 'VAT' }
      );

      expect(history).toBeInstanceOf(Array);
      expect(history[0].domain).toBe('VAT');
    });
  });
});
```
  </action>
  <verify>cd web-erp-app/backend && npm test -- --testPathPattern="compliance-(checklist|signoff).service.test" --passWithNoTests</verify>
  <done>Checklist and SignOff service tests created</done>
</task>

<task type="auto">
  <name>Task 3: Create permission seed script</name>
  <files>web-erp-app/backend/prisma/seeds/compliance-portal-permissions.seed.ts</files>
  <action>
Create permission seed script for compliance portal:

```typescript
/**
 * Compliance Portal Permissions Seed
 *
 * Phase: 08-compliance-verification
 * Plan: 08-08
 *
 * Creates permissions and role bundles for compliance verification portal.
 *
 * Permission structure:
 * - compliance:dashboard:view - View compliance dashboard
 * - compliance:checklist:view - View checklists
 * - compliance:checklist:run - Run compliance checks
 * - compliance:preview:view - View FTA previews
 * - compliance:sandbox:run - Run sandbox tests
 * - compliance:signoff:submit - Submit for sign-off
 * - compliance:signoff:approve - Approve sign-offs
 * - compliance:signoff:reject - Reject sign-offs
 * - compliance:history:view - View approval history
 *
 * Role bundles:
 * - COMPLIANCE_VIEWER: View-only access
 * - COMPLIANCE_OFFICER: Submit and view
 * - COMPLIANCE_MANAGER: Full access including approval
 */

import { PrismaClient } from '@prisma/client';
import { randomUUID } from 'crypto';

const prisma = new PrismaClient();

// Compliance Portal Permissions
const COMPLIANCE_PORTAL_PERMISSIONS = [
  {
    code: 'compliance:dashboard:view',
    name: 'View Compliance Dashboard',
    description: 'View unified compliance status dashboard',
    module: 'COMPLIANCE_PORTAL',
  },
  {
    code: 'compliance:checklist:view',
    name: 'View Compliance Checklists',
    description: 'View compliance check definitions and results',
    module: 'COMPLIANCE_PORTAL',
  },
  {
    code: 'compliance:checklist:run',
    name: 'Run Compliance Checks',
    description: 'Execute compliance checks on demand',
    module: 'COMPLIANCE_PORTAL',
  },
  {
    code: 'compliance:preview:view',
    name: 'View FTA Previews',
    description: 'View FTA submission previews',
    module: 'COMPLIANCE_PORTAL',
  },
  {
    code: 'compliance:sandbox:run',
    name: 'Run Sandbox Tests',
    description: 'Execute sandbox tests for compliance submissions',
    module: 'COMPLIANCE_PORTAL',
  },
  {
    code: 'compliance:signoff:submit',
    name: 'Submit for Sign-Off',
    description: 'Submit compliance periods for approval',
    module: 'COMPLIANCE_PORTAL',
  },
  {
    code: 'compliance:signoff:approve',
    name: 'Approve Sign-Offs',
    description: 'Approve compliance sign-off requests',
    module: 'COMPLIANCE_PORTAL',
  },
  {
    code: 'compliance:signoff:reject',
    name: 'Reject Sign-Offs',
    description: 'Reject compliance sign-off requests',
    module: 'COMPLIANCE_PORTAL',
  },
  {
    code: 'compliance:history:view',
    name: 'View Approval History',
    description: 'View compliance approval history',
    module: 'COMPLIANCE_PORTAL',
  },
];

// Role bundles with permission mappings
const COMPLIANCE_ROLE_BUNDLES = {
  COMPLIANCE_VIEWER: {
    name: 'Compliance Viewer',
    description: 'View-only access to compliance portal',
    permissions: [
      'compliance:dashboard:view',
      'compliance:checklist:view',
      'compliance:preview:view',
      'compliance:history:view',
    ],
  },
  COMPLIANCE_OFFICER: {
    name: 'Compliance Officer',
    description: 'Can submit compliance for approval',
    permissions: [
      'compliance:dashboard:view',
      'compliance:checklist:view',
      'compliance:checklist:run',
      'compliance:preview:view',
      'compliance:sandbox:run',
      'compliance:signoff:submit',
      'compliance:history:view',
    ],
  },
  COMPLIANCE_MANAGER: {
    name: 'Compliance Manager',
    description: 'Full compliance portal access including approvals',
    permissions: [
      'compliance:dashboard:view',
      'compliance:checklist:view',
      'compliance:checklist:run',
      'compliance:preview:view',
      'compliance:sandbox:run',
      'compliance:signoff:submit',
      'compliance:signoff:approve',
      'compliance:signoff:reject',
      'compliance:history:view',
    ],
  },
};

/**
 * Seeds compliance portal permissions
 *
 * Idempotent - safe to run multiple times
 */
export async function seedCompliancePortalPermissions(): Promise<void> {
  console.log('[Seed] Creating compliance portal permissions...');

  for (const perm of COMPLIANCE_PORTAL_PERMISSIONS) {
    const existing = await prisma.permissions.findFirst({
      where: { code: perm.code },
    });

    if (!existing) {
      await prisma.permissions.create({
        data: {
          id: randomUUID(),
          code: perm.code,
          name: perm.name,
          description: perm.description,
          module: perm.module,
          createdAt: new Date(),
          updatedAt: new Date(),
        },
      });
      console.log(`  Created permission: ${perm.code}`);
    } else {
      console.log(`  Skipped existing: ${perm.code}`);
    }
  }

  console.log(`[Seed] Created ${COMPLIANCE_PORTAL_PERMISSIONS.length} compliance portal permissions`);
}

/**
 * Seeds compliance role bundles for a company
 *
 * @param companyId - Company to create roles for
 */
export async function seedComplianceRoleBundles(companyId: string): Promise<void> {
  console.log(`[Seed] Creating compliance role bundles for company: ${companyId}`);

  for (const [bundleCode, bundle] of Object.entries(COMPLIANCE_ROLE_BUNDLES)) {
    // Check if role exists
    const existingRole = await prisma.role_New.findFirst({
      where: {
        companyId,
        name: bundle.name,
      },
    });

    if (existingRole) {
      console.log(`  Skipped existing role: ${bundle.name}`);
      continue;
    }

    // Create role
    const roleId = randomUUID();
    await prisma.role_New.create({
      data: {
        id: roleId,
        name: bundle.name,
        description: bundle.description,
        companyId,
        roleType: 'NON_DOCUMENT_ROLE',
        isSystemRole: true,
        createdAt: new Date(),
        updatedAt: new Date(),
      },
    });

    // Assign permissions to role
    for (const permCode of bundle.permissions) {
      const permission = await prisma.permissions.findFirst({
        where: { code: permCode },
      });

      if (permission) {
        await prisma.rolePermission.create({
          data: {
            id: randomUUID(),
            roleId,
            permissionId: permission.id,
            createdAt: new Date(),
            updatedAt: new Date(),
          },
        });
      }
    }

    console.log(`  Created role: ${bundle.name} with ${bundle.permissions.length} permissions`);
  }
}

/**
 * Main seed function
 */
async function main(): Promise<void> {
  try {
    await seedCompliancePortalPermissions();

    // Get first company for demo
    const company = await prisma.companies.findFirst({
      where: { isActive: true },
    });

    if (company) {
      await seedComplianceRoleBundles(company.id);
    }

    console.log('[Seed] Compliance portal permissions seeding complete');
  } catch (error) {
    console.error('[Seed] Error:', error);
    throw error;
  }
}

// Run if executed directly
if (require.main === module) {
  main()
    .catch(console.error)
    .finally(() => prisma.$disconnect());
}

export default main;
```
  </action>
  <verify>npx tsc --noEmit web-erp-app/backend/prisma/seeds/compliance-portal-permissions.seed.ts</verify>
  <done>Permission seed script created with 9 permissions and 3 role bundles</done>
</task>

</tasks>

<verification>
1. Run `npm test -- --testPathPattern="compliance"` - all tests pass
2. Run `npx tsc --noEmit` on seed script - compiles
3. Verify 9 compliance permissions defined
4. Verify 3 role bundles (Viewer, Officer, Manager) defined
</verification>

<success_criteria>
1. CompliancePortalService tests cover status aggregation, caching, access control
2. ComplianceChecklistService tests cover check definitions and execution
3. ComplianceSignOffService tests cover submit, approve, reject workflows
4. Permission seed creates 9 compliance portal permissions
5. Role bundles provide progressive access levels (Viewer < Officer < Manager)
6. Seed script is idempotent (safe to run multiple times)
</success_criteria>

<output>
After completion, create `.planning/phases/08-compliance-verification-portal/08-08-SUMMARY.md`
</output>
