---
phase: 08-compliance-verification
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - web-erp-app/backend/src/services/compliance-portal/compliance-portal.service.ts
  - web-erp-app/backend/src/services/compliance-portal/index.ts
autonomous: true

must_haves:
  truths:
    - "Dashboard shows real-time compliance status across 4 domains"
    - "Status aggregation runs domains in parallel"
    - "Overall status correctly reflects worst domain status"
  artifacts:
    - path: "web-erp-app/backend/src/services/compliance-portal/compliance-portal.service.ts"
      provides: "Status aggregation from 4 compliance domains"
      exports: ["CompliancePortalService"]
      min_lines: 150
    - path: "web-erp-app/backend/src/services/compliance-portal/index.ts"
      provides: "Barrel export for compliance portal services"
      exports: ["CompliancePortalService"]
  key_links:
    - from: "compliance-portal.service.ts"
      to: "compliance-checklist.service.ts"
      via: "runChecklist method call"
      pattern: "checklistService\\.runChecklist"
---

<objective>
Create the CompliancePortalService that aggregates compliance status from all four UAE domains (VAT, CT, WPS, E-Invoice).

Purpose: Implement VERIFY-01 (Unified compliance dashboard) by providing a central service that runs parallel status checks across all compliance domains and returns a unified compliance view.

Output: CompliancePortalService with getComplianceStatus() method that returns overall and per-domain compliance status.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-compliance-verification-portal/08-RESEARCH.md

# Type definitions (created in parallel)
@web-erp-app/backend/src/types/compliance-portal.types.ts

# DI patterns from existing services
@web-erp-app/backend/src/config/types.ts
@web-erp-app/backend/src/config/container.ts

# Existing domain services to reference
@web-erp-app/backend/src/services/corporate-tax/ct-report.service.ts
@web-erp-app/backend/src/services/payroll/payroll-cycle.service.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CompliancePortalService</name>
  <files>web-erp-app/backend/src/services/compliance-portal/compliance-portal.service.ts</files>
  <action>
Create the CompliancePortalService that aggregates status from all 4 compliance domains:

```typescript
/**
 * Compliance Portal Service
 *
 * Phase: 08-compliance-verification
 * Plan: 08-02
 * Requirement: VERIFY-01 (Unified compliance dashboard)
 *
 * Aggregates compliance status from four UAE domains:
 * - VAT (Phase 3)
 * - Corporate Tax (Phase 4)
 * - WPS Payroll (Phase 5)
 * - E-Invoice (Phase 6-7)
 *
 * Key patterns:
 * - Parallel status checking with Promise.all()
 * - Caching with configurable TTL (5 minutes default)
 * - Defense-in-depth company validation
 */

import { injectable, inject } from 'inversify';
import { PrismaClient } from '@prisma/client';
import { TYPES } from '../../config/types';
import {
  ComplianceStatus,
  DomainComplianceStatus,
  OverallComplianceStatus,
  ComplianceDomain,
  DomainStatus,
} from '../../types/compliance-portal.types';

// Cache entry type
interface CacheEntry {
  status: ComplianceStatus;
  expiresAt: Date;
}

@injectable()
export class CompliancePortalService {
  private readonly cache: Map<string, CacheEntry> = new Map();
  private readonly cacheTtlMs: number = 5 * 60 * 1000; // 5 minutes

  constructor(
    @inject(TYPES.PrismaClient) private readonly prisma: PrismaClient
  ) {}

  // ==========================================================================
  // Public Methods
  // ==========================================================================

  /**
   * Gets unified compliance status across all domains
   *
   * Runs all domain checks in parallel for performance.
   * Uses cached results if available and not expired.
   *
   * @param companyId - Company to check compliance for
   * @param userId - User requesting status (for authorization)
   * @param forceRefresh - Bypass cache and run fresh checks
   */
  async getComplianceStatus(
    companyId: string,
    userId: string,
    forceRefresh: boolean = false
  ): Promise<ComplianceStatus> {
    // Validate company access
    await this.validateCompanyAccess(userId, companyId);

    // Check cache unless forced refresh
    if (!forceRefresh) {
      const cached = this.getCachedStatus(companyId);
      if (cached) {
        return cached;
      }
    }

    // Run all domain checks in parallel
    const startTime = Date.now();

    const [vat, corporateTax, wps, eInvoice] = await Promise.all([
      this.getDomainStatus(companyId, 'VAT'),
      this.getDomainStatus(companyId, 'CT'),
      this.getDomainStatus(companyId, 'WPS'),
      this.getDomainStatus(companyId, 'EINVOICE'),
    ]);

    const domains = { vat, corporateTax, wps, eInvoice };
    const overall = this.calculateOverallStatus(domains);

    const status: ComplianceStatus = {
      overall,
      lastUpdated: new Date(),
      domains,
    };

    // Cache result
    this.setCachedStatus(companyId, status);

    // Log performance
    const durationMs = Date.now() - startTime;
    console.log('[CompliancePortal] Status aggregation:', {
      companyId,
      overall,
      durationMs,
      timestamp: new Date().toISOString(),
    });

    return status;
  }

  /**
   * Gets status for a single compliance domain
   *
   * @param companyId - Company to check
   * @param domain - Specific domain to check
   */
  async getDomainStatus(
    companyId: string,
    domain: ComplianceDomain
  ): Promise<DomainComplianceStatus> {
    // This will delegate to ComplianceChecklistService once it exists
    // For now, return placeholder that checks basic data existence

    try {
      switch (domain) {
        case 'VAT':
          return await this.getVatStatus(companyId);
        case 'CT':
          return await this.getCtStatus(companyId);
        case 'WPS':
          return await this.getWpsStatus(companyId);
        case 'EINVOICE':
          return await this.getEInvoiceStatus(companyId);
        default:
          return this.createPendingStatus();
      }
    } catch (error) {
      console.error(`[CompliancePortal] Error checking ${domain}:`, {
        companyId,
        error: error instanceof Error ? error.message : 'Unknown error',
      });
      return this.createFailedStatus(error instanceof Error ? error.message : 'Check failed');
    }
  }

  /**
   * Invalidates cached status for a company
   *
   * Should be called when compliance-related data changes.
   */
  invalidateCache(companyId: string): void {
    this.cache.delete(companyId);
  }

  /**
   * Gets compliance summary for dashboard display
   *
   * Returns simplified data suitable for UI widgets.
   */
  async getDashboardSummary(
    companyId: string,
    userId: string
  ): Promise<{
    overallStatus: OverallComplianceStatus;
    domains: Array<{
      name: string;
      status: DomainStatus;
      passed: number;
      total: number;
      issues: number;
    }>;
    lastUpdated: Date;
  }> {
    const status = await this.getComplianceStatus(companyId, userId);

    return {
      overallStatus: status.overall,
      domains: [
        {
          name: 'VAT',
          status: status.domains.vat.status,
          passed: status.domains.vat.checksPassed,
          total: status.domains.vat.checksTotal,
          issues: status.domains.vat.criticalIssues.length,
        },
        {
          name: 'Corporate Tax',
          status: status.domains.corporateTax.status,
          passed: status.domains.corporateTax.checksPassed,
          total: status.domains.corporateTax.checksTotal,
          issues: status.domains.corporateTax.criticalIssues.length,
        },
        {
          name: 'WPS Payroll',
          status: status.domains.wps.status,
          passed: status.domains.wps.checksPassed,
          total: status.domains.wps.checksTotal,
          issues: status.domains.wps.criticalIssues.length,
        },
        {
          name: 'E-Invoice',
          status: status.domains.eInvoice.status,
          passed: status.domains.eInvoice.checksPassed,
          total: status.domains.eInvoice.checksTotal,
          issues: status.domains.eInvoice.criticalIssues.length,
        },
      ],
      lastUpdated: status.lastUpdated,
    };
  }

  // ==========================================================================
  // Private Methods - Status Calculation
  // ==========================================================================

  /**
   * Calculates overall status from domain statuses
   *
   * Priority: FAIL > WARNING > PENDING > PASS
   */
  private calculateOverallStatus(
    domains: Record<string, DomainComplianceStatus>
  ): OverallComplianceStatus {
    const statuses = Object.values(domains).map((d) => d.status);

    if (statuses.some((s) => s === 'FAIL')) return 'NON_COMPLIANT';
    if (statuses.some((s) => s === 'WARNING')) return 'WARNING';
    if (statuses.some((s) => s === 'PENDING')) return 'UNKNOWN';
    return 'COMPLIANT';
  }

  // ==========================================================================
  // Private Methods - Domain Status (Placeholder implementations)
  // ==========================================================================

  /**
   * Gets VAT compliance status
   *
   * Checks: TRN valid, period configured, reconciliation complete
   */
  private async getVatStatus(companyId: string): Promise<DomainComplianceStatus> {
    // Check company has TRN configured
    const company = await this.prisma.companies.findUnique({
      where: { id: companyId },
      select: { taxNumber: true },
    });

    const hasTrn = !!company?.taxNumber && /^100\d{12}$/.test(company.taxNumber);

    // Check for VAT periods (basic check)
    const vatPeriodCount = await this.prisma.$queryRaw<[{ count: bigint }]>`
      SELECT COUNT(*) as count FROM vat_periods WHERE company_id = ${companyId}::uuid
    `.catch(() => [{ count: 0n }]);

    const hasVatPeriods = Number(vatPeriodCount[0]?.count || 0) > 0;

    const passed = (hasTrn ? 1 : 0) + (hasVatPeriods ? 1 : 0);
    const total = 2;

    return {
      status: passed === total ? 'PASS' : hasTrn ? 'WARNING' : 'FAIL',
      checksPassed: passed,
      checksTotal: total,
      criticalIssues: hasTrn ? [] : [{
        checkId: 'VAT-01',
        name: 'TRN Validation',
        message: 'Valid TRN not configured',
        remediation: 'Configure 15-digit TRN starting with 100 in Company Settings',
      }],
      warnings: hasVatPeriods ? [] : [{
        checkId: 'VAT-02',
        name: 'VAT Period',
        message: 'No VAT periods configured',
        remediation: 'Create VAT period in VAT > Periods',
      }],
      lastCheckedAt: new Date(),
    };
  }

  /**
   * Gets Corporate Tax compliance status
   *
   * Checks: CT period exists, chart mapped
   */
  private async getCtStatus(companyId: string): Promise<DomainComplianceStatus> {
    // Check for fiscal year configuration
    const fiscalYear = await this.prisma.fiscal_years.findFirst({
      where: { companyId },
    }).catch(() => null);

    const hasFiscalYear = !!fiscalYear;

    return {
      status: hasFiscalYear ? 'PASS' : 'WARNING',
      checksPassed: hasFiscalYear ? 1 : 0,
      checksTotal: 1,
      criticalIssues: [],
      warnings: hasFiscalYear ? [] : [{
        checkId: 'CT-01',
        name: 'Fiscal Year',
        message: 'No fiscal year configured',
        remediation: 'Configure fiscal year in Settings > Accounting',
      }],
      lastCheckedAt: new Date(),
    };
  }

  /**
   * Gets WPS compliance status
   *
   * Checks: IBAN valid, bank routing configured
   */
  private async getWpsStatus(companyId: string): Promise<DomainComplianceStatus> {
    // Check for WPS agent configuration
    const wpsAgentCount = await this.prisma.$queryRaw<[{ count: bigint }]>`
      SELECT COUNT(*) as count FROM wps_agents WHERE company_id = ${companyId}::uuid
    `.catch(() => [{ count: 0n }]);

    const hasWpsAgent = Number(wpsAgentCount[0]?.count || 0) > 0;

    return {
      status: hasWpsAgent ? 'PASS' : 'WARNING',
      checksPassed: hasWpsAgent ? 1 : 0,
      checksTotal: 1,
      criticalIssues: [],
      warnings: hasWpsAgent ? [] : [{
        checkId: 'WPS-01',
        name: 'WPS Agent',
        message: 'No WPS agent configured',
        remediation: 'Configure WPS bank agent in Payroll > Settings',
      }],
      lastCheckedAt: new Date(),
    };
  }

  /**
   * Gets E-Invoice compliance status
   *
   * Checks: Credentials configured, transmission enabled
   */
  private async getEInvoiceStatus(companyId: string): Promise<DomainComplianceStatus> {
    // Check for e-invoice credentials
    const credentialCount = await this.prisma.$queryRaw<[{ count: bigint }]>`
      SELECT COUNT(*) as count FROM einvoice_credentials WHERE company_id = ${companyId}::uuid
    `.catch(() => [{ count: 0n }]);

    const hasCredentials = Number(credentialCount[0]?.count || 0) > 0;

    // Check for transmission config
    const configCount = await this.prisma.$queryRaw<[{ count: bigint }]>`
      SELECT COUNT(*) as count FROM einvoice_transmission_configs WHERE company_id = ${companyId}::uuid
    `.catch(() => [{ count: 0n }]);

    const hasConfig = Number(configCount[0]?.count || 0) > 0;

    const passed = (hasCredentials ? 1 : 0) + (hasConfig ? 1 : 0);
    const total = 2;

    return {
      status: passed === total ? 'PASS' : passed > 0 ? 'WARNING' : 'FAIL',
      checksPassed: passed,
      checksTotal: total,
      criticalIssues: hasCredentials ? [] : [{
        checkId: 'EINV-01',
        name: 'E-Invoice Credentials',
        message: 'Transmission credentials not configured',
        remediation: 'Configure FTA credentials in E-Invoice > Settings',
      }],
      warnings: hasConfig ? [] : [{
        checkId: 'EINV-02',
        name: 'Transmission Config',
        message: 'Transmission settings not configured',
        remediation: 'Configure transmission mode in E-Invoice > Settings',
      }],
      lastCheckedAt: new Date(),
    };
  }

  // ==========================================================================
  // Private Methods - Helpers
  // ==========================================================================

  /**
   * Validates user has access to company
   */
  private async validateCompanyAccess(
    userId: string,
    companyId: string
  ): Promise<void> {
    const user = await this.prisma.users.findUnique({
      where: { id: userId },
      select: { companyId: true },
    });

    if (!user) {
      throw new Error('User not found');
    }

    if (user.companyId !== companyId) {
      console.error('[CompliancePortal] Access denied:', {
        userId,
        requestedCompanyId: companyId,
        userCompanyId: user.companyId,
      });
      throw new Error('Access denied: Cannot access compliance data from other company');
    }
  }

  /**
   * Gets cached status if valid
   */
  private getCachedStatus(companyId: string): ComplianceStatus | null {
    const entry = this.cache.get(companyId);
    if (entry && entry.expiresAt > new Date()) {
      return entry.status;
    }
    return null;
  }

  /**
   * Caches compliance status
   */
  private setCachedStatus(companyId: string, status: ComplianceStatus): void {
    const expiresAt = new Date(Date.now() + this.cacheTtlMs);
    this.cache.set(companyId, { status, expiresAt });
  }

  /**
   * Creates a pending status (for new domains)
   */
  private createPendingStatus(): DomainComplianceStatus {
    return {
      status: 'PENDING',
      checksPassed: 0,
      checksTotal: 0,
      criticalIssues: [],
      warnings: [],
      lastCheckedAt: new Date(),
    };
  }

  /**
   * Creates a failed status with error message
   */
  private createFailedStatus(message: string): DomainComplianceStatus {
    return {
      status: 'FAIL',
      checksPassed: 0,
      checksTotal: 1,
      criticalIssues: [{
        checkId: 'SYS-01',
        name: 'System Error',
        message,
        remediation: 'Contact system administrator',
      }],
      warnings: [],
      lastCheckedAt: new Date(),
    };
  }
}
```

Key implementation notes:
- Uses Promise.all() for parallel domain checks (performance requirement)
- Implements 5-minute caching with invalidation support
- Defense-in-depth company access validation
- Graceful error handling per domain (one failure doesn't break all)
- Placeholder domain checks that will be replaced by ComplianceChecklistService
  </action>
  <verify>npx tsc --noEmit web-erp-app/backend/src/services/compliance-portal/compliance-portal.service.ts</verify>
  <done>CompliancePortalService compiles and exports getComplianceStatus, getDashboardSummary methods</done>
</task>

<task type="auto">
  <name>Task 2: Create barrel export file</name>
  <files>web-erp-app/backend/src/services/compliance-portal/index.ts</files>
  <action>
Create barrel export for compliance portal services:

```typescript
/**
 * Compliance Portal Services
 *
 * Phase: 08-compliance-verification
 *
 * Barrel exports for compliance verification portal services.
 * New services added as phase progresses.
 */

// Core aggregation service
export { CompliancePortalService } from './compliance-portal.service';

// Types re-export for convenience
export type {
  ComplianceStatus,
  DomainComplianceStatus,
  OverallComplianceStatus,
  ComplianceDomain,
  DomainStatus,
  ComplianceIssue,
} from '../../types/compliance-portal.types';
```

Create the directory structure if it doesn't exist:
```bash
mkdir -p web-erp-app/backend/src/services/compliance-portal
```
  </action>
  <verify>npx tsc --noEmit web-erp-app/backend/src/services/compliance-portal/index.ts</verify>
  <done>Barrel export compiles and re-exports service and types</done>
</task>

</tasks>

<verification>
1. Run `npx tsc --noEmit` - all files compile
2. Verify CompliancePortalService has getComplianceStatus() method
3. Verify parallel execution with Promise.all()
4. Verify caching with invalidation
5. Verify company access validation
</verification>

<success_criteria>
1. CompliancePortalService aggregates status from 4 domains in parallel
2. Caching prevents repeated expensive checks (5-min TTL)
3. Company access validation prevents cross-tenant access
4. Error in one domain doesn't fail entire status check
5. Dashboard summary method returns UI-friendly data structure
</success_criteria>

<output>
After completion, create `.planning/phases/08-compliance-verification-portal/08-02-SUMMARY.md`
</output>
