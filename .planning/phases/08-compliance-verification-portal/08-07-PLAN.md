---
phase: 08-compliance-verification
plan: 07
type: execute
wave: 4
depends_on: ["08-01", "08-02", "08-03", "08-04", "08-05", "08-06"]
files_modified:
  - web-erp-app/backend/src/controllers/compliance-portal.controller.ts
  - web-erp-app/backend/src/routes/compliance-portal.routes.ts
  - web-erp-app/backend/src/config/types.ts
  - web-erp-app/backend/src/config/container.ts
  - web-erp-app/backend/src/services/compliance-portal/index.ts
autonomous: true

must_haves:
  truths:
    - "REST API endpoints exist for all portal functions"
    - "Endpoints are protected by JWT authentication"
    - "Endpoints enforce company access authorization"
  artifacts:
    - path: "web-erp-app/backend/src/controllers/compliance-portal.controller.ts"
      provides: "REST API controller for compliance portal"
      exports: ["CompliancePortalController"]
      min_lines: 200
    - path: "web-erp-app/backend/src/routes/compliance-portal.routes.ts"
      provides: "Route definitions for compliance portal"
      exports: ["router"]
      min_lines: 50
  key_links:
    - from: "compliance-portal.routes.ts"
      to: "compliance-portal.controller.ts"
      via: "controller method calls"
      pattern: "controller\\."
    - from: "container.ts"
      to: "compliance-portal services"
      via: "DI binding"
      pattern: "CompliancePortalService|ComplianceChecklistService"
---

<objective>
Create the REST API controller and routes for the compliance verification portal, plus DI configuration.

Purpose: Expose all compliance portal functionality via REST endpoints protected by JWT authentication and company authorization.

Output: CompliancePortalController, routes, and DI configuration for all Phase 8 services.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-compliance-verification-portal/08-RESEARCH.md

# Prior plan summaries
@.planning/phases/08-compliance-verification-portal/08-01-SUMMARY.md
@.planning/phases/08-compliance-verification-portal/08-02-SUMMARY.md
@.planning/phases/08-compliance-verification-portal/08-03-SUMMARY.md
@.planning/phases/08-compliance-verification-portal/08-04-SUMMARY.md
@.planning/phases/08-compliance-verification-portal/08-05-SUMMARY.md
@.planning/phases/08-compliance-verification-portal/08-06-SUMMARY.md

# Existing patterns
@web-erp-app/backend/src/config/types.ts
@web-erp-app/backend/src/config/container.ts
@web-erp-app/backend/src/controllers/dashboard.controller.ts
@web-erp-app/backend/src/routes/dashboard.routes.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add DI type symbols for compliance portal services</name>
  <files>web-erp-app/backend/src/config/types.ts</files>
  <action>
Add DI type symbols for Phase 8 compliance portal services to the existing types.ts file:

```typescript
// Add to the TYPES object, after E-Invoice Transmission Services section:

// ============================================================================
// COMPLIANCE PORTAL TYPES (Phase 08)
// ============================================================================

/**
 * DI type symbols for compliance verification portal services
 *
 * Phase: 08-compliance-verification
 * Plan: 08-07
 */
export const COMPLIANCE_PORTAL_TYPES = {
  // Core Services (08-01, 08-02)
  CompliancePortalService: Symbol.for('CompliancePortalService'),

  // Checklist Engine (08-03)
  ComplianceChecklistService: Symbol.for('ComplianceChecklistService'),

  // Preview Generation (08-04)
  CompliancePreviewService: Symbol.for('CompliancePreviewService'),

  // Sandbox Testing (08-05)
  SandboxOrchestratorService: Symbol.for('SandboxOrchestratorService'),

  // Sign-Off Workflow (08-06)
  ComplianceSignOffService: Symbol.for('ComplianceSignOffService'),

  // Controller (08-07)
  CompliancePortalController: Symbol.for('CompliancePortalController'),
} as const;
```

Also add to the main TYPES object:
```typescript
// In the TYPES object, add:
CompliancePortalService: Symbol.for('CompliancePortalService'),
ComplianceChecklistService: Symbol.for('ComplianceChecklistService'),
CompliancePreviewService: Symbol.for('CompliancePreviewService'),
SandboxOrchestratorService: Symbol.for('SandboxOrchestratorService'),
ComplianceSignOffService: Symbol.for('ComplianceSignOffService'),
CompliancePortalController: Symbol.for('CompliancePortalController'),
```
  </action>
  <verify>npx tsc --noEmit web-erp-app/backend/src/config/types.ts</verify>
  <done>DI type symbols added for all Phase 8 services</done>
</task>

<task type="auto">
  <name>Task 2: Create CompliancePortalController</name>
  <files>web-erp-app/backend/src/controllers/compliance-portal.controller.ts</files>
  <action>
Create the REST API controller for compliance portal:

```typescript
/**
 * Compliance Portal Controller
 *
 * Phase: 08-compliance-verification
 * Plan: 08-07
 *
 * REST API controller for compliance verification portal.
 * All endpoints require JWT authentication and company authorization.
 *
 * Endpoints:
 * - GET /compliance-portal/status - Overall compliance status
 * - GET /compliance-portal/dashboard - Dashboard summary
 * - GET /compliance-portal/checklists/:domain - Domain checklist
 * - POST /compliance-portal/checklists/:domain/run - Run domain checks
 * - GET /compliance-portal/preview/:domain/:periodId - FTA preview
 * - POST /compliance-portal/sandbox/test - Run sandbox test
 * - GET /compliance-portal/sandbox/history - Sandbox test history
 * - POST /compliance-portal/signoff - Submit for sign-off
 * - POST /compliance-portal/signoff/:id/approve - Approve sign-off
 * - POST /compliance-portal/signoff/:id/reject - Reject sign-off
 * - GET /compliance-portal/signoff/history - Approval history
 * - GET /compliance-portal/signoff/pending - Pending approvals
 */

import { injectable, inject } from 'inversify';
import { Request, Response } from 'express';
import { TYPES, COMPLIANCE_PORTAL_TYPES } from '../config/types';
import { CompliancePortalService } from '../services/compliance-portal/compliance-portal.service';
import { ComplianceChecklistService } from '../services/compliance-portal/compliance-checklist.service';
import { CompliancePreviewService } from '../services/compliance-portal/compliance-preview.service';
import { SandboxOrchestratorService } from '../services/compliance-portal/sandbox-orchestrator.service';
import { ComplianceSignOffService } from '../services/compliance-portal/compliance-signoff.service';
import { ComplianceDomain } from '../types/compliance-portal.types';

interface AuthRequest extends Request {
  user: {
    id: string;
    companyId: string;
    email?: string;
  };
}

@injectable()
export class CompliancePortalController {
  constructor(
    @inject(TYPES.CompliancePortalService)
    private readonly portalService: CompliancePortalService,
    @inject(TYPES.ComplianceChecklistService)
    private readonly checklistService: ComplianceChecklistService,
    @inject(TYPES.CompliancePreviewService)
    private readonly previewService: CompliancePreviewService,
    @inject(TYPES.SandboxOrchestratorService)
    private readonly sandboxService: SandboxOrchestratorService,
    @inject(TYPES.ComplianceSignOffService)
    private readonly signOffService: ComplianceSignOffService
  ) {}

  // ==========================================================================
  // Dashboard Endpoints
  // ==========================================================================

  /**
   * GET /compliance-portal/status
   * Get overall compliance status across all domains
   */
  async getComplianceStatus(req: Request, res: Response): Promise<void> {
    try {
      const authReq = req as AuthRequest;
      const { companyId } = authReq.user;
      const forceRefresh = req.query.refresh === 'true';

      const status = await this.portalService.getComplianceStatus(
        companyId,
        authReq.user.id,
        forceRefresh
      );

      res.json({
        success: true,
        data: status,
      });
    } catch (error) {
      console.error('[CompliancePortal] Status error:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to fetch compliance status',
      });
    }
  }

  /**
   * GET /compliance-portal/dashboard
   * Get dashboard summary for UI widgets
   */
  async getDashboardSummary(req: Request, res: Response): Promise<void> {
    try {
      const authReq = req as AuthRequest;
      const { companyId } = authReq.user;

      const summary = await this.portalService.getDashboardSummary(
        companyId,
        authReq.user.id
      );

      res.json({
        success: true,
        data: summary,
      });
    } catch (error) {
      console.error('[CompliancePortal] Dashboard error:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to fetch dashboard summary',
      });
    }
  }

  // ==========================================================================
  // Checklist Endpoints
  // ==========================================================================

  /**
   * GET /compliance-portal/checklists/:domain
   * Get check definitions for a domain
   */
  async getChecklist(req: Request, res: Response): Promise<void> {
    try {
      const domain = req.params.domain?.toUpperCase() as ComplianceDomain;

      if (!['VAT', 'CT', 'WPS', 'EINVOICE'].includes(domain)) {
        res.status(400).json({
          success: false,
          message: 'Invalid domain. Must be VAT, CT, WPS, or EINVOICE',
        });
        return;
      }

      const checks = this.checklistService.getCheckDefinitions(domain);

      res.json({
        success: true,
        data: {
          domain,
          checks: checks.map((c) => ({
            id: c.id,
            name: c.name,
            description: c.description,
            severity: c.severity,
            remediationGuide: c.remediationGuide,
          })),
          totalChecks: checks.length,
        },
      });
    } catch (error) {
      console.error('[CompliancePortal] Checklist error:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to fetch checklist',
      });
    }
  }

  /**
   * POST /compliance-portal/checklists/:domain/run
   * Run checks for a domain
   */
  async runChecklist(req: Request, res: Response): Promise<void> {
    try {
      const authReq = req as AuthRequest;
      const { companyId } = authReq.user;
      const domain = req.params.domain?.toUpperCase() as ComplianceDomain;
      const { periodId } = req.body;

      if (!['VAT', 'CT', 'WPS', 'EINVOICE'].includes(domain)) {
        res.status(400).json({
          success: false,
          message: 'Invalid domain',
        });
        return;
      }

      const result = await this.checklistService.runChecklist(
        companyId,
        domain,
        periodId,
        authReq.user.id,
        'MANUAL'
      );

      res.json({
        success: true,
        data: result,
      });
    } catch (error) {
      console.error('[CompliancePortal] Run checklist error:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to run checklist',
      });
    }
  }

  /**
   * GET /compliance-portal/checklists/history
   * Get check run history
   */
  async getChecklistHistory(req: Request, res: Response): Promise<void> {
    try {
      const authReq = req as AuthRequest;
      const { companyId } = authReq.user;
      const domain = req.query.domain as ComplianceDomain | undefined;
      const limit = parseInt(req.query.limit as string) || 10;

      const history = await this.checklistService.getCheckRunHistory(
        companyId,
        domain,
        limit
      );

      res.json({
        success: true,
        data: history,
      });
    } catch (error) {
      console.error('[CompliancePortal] History error:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to fetch history',
      });
    }
  }

  // ==========================================================================
  // Preview Endpoints
  // ==========================================================================

  /**
   * GET /compliance-portal/preview/:domain/:periodId
   * Get FTA submission preview
   */
  async getPreview(req: Request, res: Response): Promise<void> {
    try {
      const authReq = req as AuthRequest;
      const { companyId } = authReq.user;
      const domain = req.params.domain?.toUpperCase() as ComplianceDomain;
      const { periodId } = req.params;

      if (!['VAT', 'CT', 'WPS', 'EINVOICE'].includes(domain)) {
        res.status(400).json({
          success: false,
          message: 'Invalid domain',
        });
        return;
      }

      const preview = await this.previewService.generatePreview(
        companyId,
        domain,
        periodId,
        authReq.user.id
      );

      res.json({
        success: true,
        data: preview,
      });
    } catch (error) {
      console.error('[CompliancePortal] Preview error:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to generate preview',
      });
    }
  }

  // ==========================================================================
  // Sandbox Endpoints
  // ==========================================================================

  /**
   * POST /compliance-portal/sandbox/test
   * Run sandbox test
   */
  async runSandboxTest(req: Request, res: Response): Promise<void> {
    try {
      const authReq = req as AuthRequest;
      const { companyId } = authReq.user;
      const { domain, testType, documentIds } = req.body;

      if (!domain) {
        res.status(400).json({
          success: false,
          message: 'Domain is required',
        });
        return;
      }

      const result = await this.sandboxService.runSandboxTest(
        companyId,
        authReq.user.id,
        {
          domain: domain.toUpperCase() as ComplianceDomain,
          testType: testType || 'QUICK',
          documentIds,
        }
      );

      res.json({
        success: true,
        data: result,
      });
    } catch (error) {
      console.error('[CompliancePortal] Sandbox test error:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to run sandbox test',
      });
    }
  }

  /**
   * GET /compliance-portal/sandbox/history
   * Get sandbox test history
   */
  async getSandboxHistory(req: Request, res: Response): Promise<void> {
    try {
      const authReq = req as AuthRequest;
      const { companyId } = authReq.user;
      const domain = req.query.domain as ComplianceDomain | undefined;
      const limit = parseInt(req.query.limit as string) || 10;

      const history = await this.sandboxService.getSandboxTestHistory(
        companyId,
        domain,
        limit
      );

      res.json({
        success: true,
        data: history,
      });
    } catch (error) {
      console.error('[CompliancePortal] Sandbox history error:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to fetch sandbox history',
      });
    }
  }

  /**
   * GET /compliance-portal/sandbox/available/:domain
   * Check if sandbox is available for domain
   */
  async checkSandboxAvailable(req: Request, res: Response): Promise<void> {
    try {
      const domain = req.params.domain?.toUpperCase() as ComplianceDomain;

      const available = await this.sandboxService.isSandboxAvailable(domain);

      res.json({
        success: true,
        data: {
          domain,
          available,
          message: available
            ? 'Sandbox testing available'
            : 'Sandbox testing not yet available for this domain',
        },
      });
    } catch (error) {
      console.error('[CompliancePortal] Sandbox check error:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to check sandbox availability',
      });
    }
  }

  // ==========================================================================
  // Sign-Off Endpoints
  // ==========================================================================

  /**
   * POST /compliance-portal/signoff
   * Submit for sign-off
   */
  async submitForSignOff(req: Request, res: Response): Promise<void> {
    try {
      const authReq = req as AuthRequest;
      const { companyId } = authReq.user;
      const { domain, periodId, checklistResults, previewData } = req.body;

      if (!domain || !periodId) {
        res.status(400).json({
          success: false,
          message: 'Domain and periodId are required',
        });
        return;
      }

      const result = await this.signOffService.submitForSignOff(
        {
          companyId,
          domain: domain.toUpperCase() as ComplianceDomain,
          periodId,
          submitterId: authReq.user.id,
          checklistResults,
          previewData,
        },
        authReq.user.id
      );

      res.json({
        success: true,
        data: result,
      });
    } catch (error) {
      console.error('[CompliancePortal] Sign-off submit error:', error);
      res.status(500).json({
        success: false,
        message: error instanceof Error ? error.message : 'Failed to submit for sign-off',
      });
    }
  }

  /**
   * POST /compliance-portal/signoff/:id/approve
   * Approve sign-off
   */
  async approveSignOff(req: Request, res: Response): Promise<void> {
    try {
      const authReq = req as AuthRequest;
      const { id } = req.params;
      const { comments } = req.body;

      const result = await this.signOffService.approveSignOff(
        id,
        authReq.user.id,
        comments
      );

      res.json({
        success: true,
        data: result,
      });
    } catch (error) {
      console.error('[CompliancePortal] Approve error:', error);
      res.status(500).json({
        success: false,
        message: error instanceof Error ? error.message : 'Failed to approve sign-off',
      });
    }
  }

  /**
   * POST /compliance-portal/signoff/:id/reject
   * Reject sign-off
   */
  async rejectSignOff(req: Request, res: Response): Promise<void> {
    try {
      const authReq = req as AuthRequest;
      const { id } = req.params;
      const { reason } = req.body;

      if (!reason) {
        res.status(400).json({
          success: false,
          message: 'Rejection reason is required',
        });
        return;
      }

      await this.signOffService.rejectSignOff(id, authReq.user.id, reason);

      res.json({
        success: true,
        message: 'Sign-off rejected',
      });
    } catch (error) {
      console.error('[CompliancePortal] Reject error:', error);
      res.status(500).json({
        success: false,
        message: error instanceof Error ? error.message : 'Failed to reject sign-off',
      });
    }
  }

  /**
   * GET /compliance-portal/signoff/:id
   * Get sign-off details
   */
  async getSignOff(req: Request, res: Response): Promise<void> {
    try {
      const { id } = req.params;

      const signOff = await this.signOffService.getSignOff(id);

      if (!signOff) {
        res.status(404).json({
          success: false,
          message: 'Sign-off not found',
        });
        return;
      }

      res.json({
        success: true,
        data: signOff,
      });
    } catch (error) {
      console.error('[CompliancePortal] Get sign-off error:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to fetch sign-off',
      });
    }
  }

  /**
   * GET /compliance-portal/signoff/history
   * Get approval history
   */
  async getApprovalHistory(req: Request, res: Response): Promise<void> {
    try {
      const authReq = req as AuthRequest;
      const { companyId } = authReq.user;
      const { domain, status, startDate, endDate, limit, offset } = req.query;

      const history = await this.signOffService.getApprovalHistory(
        companyId,
        authReq.user.id,
        {
          domain: domain as ComplianceDomain | undefined,
          status: status as any,
          startDate: startDate ? new Date(startDate as string) : undefined,
          endDate: endDate ? new Date(endDate as string) : undefined,
          limit: limit ? parseInt(limit as string) : undefined,
          offset: offset ? parseInt(offset as string) : undefined,
        }
      );

      res.json({
        success: true,
        data: history,
      });
    } catch (error) {
      console.error('[CompliancePortal] Approval history error:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to fetch approval history',
      });
    }
  }

  /**
   * GET /compliance-portal/signoff/pending
   * Get pending sign-offs for current user
   */
  async getPendingSignOffs(req: Request, res: Response): Promise<void> {
    try {
      const authReq = req as AuthRequest;
      const { companyId } = authReq.user;

      const pending = await this.signOffService.getPendingSignOffsForUser(
        companyId,
        authReq.user.id
      );

      res.json({
        success: true,
        data: pending,
      });
    } catch (error) {
      console.error('[CompliancePortal] Pending sign-offs error:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to fetch pending sign-offs',
      });
    }
  }
}
```
  </action>
  <verify>npx tsc --noEmit web-erp-app/backend/src/controllers/compliance-portal.controller.ts</verify>
  <done>CompliancePortalController compiles with all endpoint methods</done>
</task>

<task type="auto">
  <name>Task 3: Create routes and update DI container</name>
  <files>
    web-erp-app/backend/src/routes/compliance-portal.routes.ts
    web-erp-app/backend/src/config/container.ts
  </files>
  <action>
Create route definitions:

**compliance-portal.routes.ts:**
```typescript
/**
 * Compliance Portal Routes
 *
 * Phase: 08-compliance-verification
 * Plan: 08-07
 *
 * Route definitions for compliance verification portal.
 * All routes require JWT authentication.
 */

import { Router } from 'express';
import { container } from '../config/container';
import { TYPES } from '../config/types';
import { CompliancePortalController } from '../controllers/compliance-portal.controller';
import { authenticateJWT } from '../middleware/auth.middleware';

const router = Router();

// Get controller from DI container
const controller = container.get<CompliancePortalController>(
  TYPES.CompliancePortalController
);

// ==========================================================================
// Dashboard Routes
// ==========================================================================

// GET /compliance-portal/status - Overall compliance status
router.get(
  '/status',
  authenticateJWT,
  (req, res) => controller.getComplianceStatus(req, res)
);

// GET /compliance-portal/dashboard - Dashboard summary
router.get(
  '/dashboard',
  authenticateJWT,
  (req, res) => controller.getDashboardSummary(req, res)
);

// ==========================================================================
// Checklist Routes
// ==========================================================================

// GET /compliance-portal/checklists/:domain - Get check definitions
router.get(
  '/checklists/:domain',
  authenticateJWT,
  (req, res) => controller.getChecklist(req, res)
);

// POST /compliance-portal/checklists/:domain/run - Run domain checks
router.post(
  '/checklists/:domain/run',
  authenticateJWT,
  (req, res) => controller.runChecklist(req, res)
);

// GET /compliance-portal/checklists/history - Check run history
router.get(
  '/checklists/history',
  authenticateJWT,
  (req, res) => controller.getChecklistHistory(req, res)
);

// ==========================================================================
// Preview Routes
// ==========================================================================

// GET /compliance-portal/preview/:domain/:periodId - FTA preview
router.get(
  '/preview/:domain/:periodId',
  authenticateJWT,
  (req, res) => controller.getPreview(req, res)
);

// ==========================================================================
// Sandbox Routes
// ==========================================================================

// POST /compliance-portal/sandbox/test - Run sandbox test
router.post(
  '/sandbox/test',
  authenticateJWT,
  (req, res) => controller.runSandboxTest(req, res)
);

// GET /compliance-portal/sandbox/history - Sandbox test history
router.get(
  '/sandbox/history',
  authenticateJWT,
  (req, res) => controller.getSandboxHistory(req, res)
);

// GET /compliance-portal/sandbox/available/:domain - Check availability
router.get(
  '/sandbox/available/:domain',
  authenticateJWT,
  (req, res) => controller.checkSandboxAvailable(req, res)
);

// ==========================================================================
// Sign-Off Routes
// ==========================================================================

// POST /compliance-portal/signoff - Submit for sign-off
router.post(
  '/signoff',
  authenticateJWT,
  (req, res) => controller.submitForSignOff(req, res)
);

// POST /compliance-portal/signoff/:id/approve - Approve sign-off
router.post(
  '/signoff/:id/approve',
  authenticateJWT,
  (req, res) => controller.approveSignOff(req, res)
);

// POST /compliance-portal/signoff/:id/reject - Reject sign-off
router.post(
  '/signoff/:id/reject',
  authenticateJWT,
  (req, res) => controller.rejectSignOff(req, res)
);

// GET /compliance-portal/signoff/:id - Get sign-off details
router.get(
  '/signoff/:id',
  authenticateJWT,
  (req, res) => controller.getSignOff(req, res)
);

// GET /compliance-portal/signoff/history - Approval history
router.get(
  '/signoff/history',
  authenticateJWT,
  (req, res) => controller.getApprovalHistory(req, res)
);

// GET /compliance-portal/signoff/pending - Pending approvals
router.get(
  '/signoff/pending',
  authenticateJWT,
  (req, res) => controller.getPendingSignOffs(req, res)
);

export { router };
```

Update container.ts to bind Phase 8 services. Add a new section after existing bindings:

```typescript
// ============================================================================
// COMPLIANCE PORTAL SERVICES (Phase 08)
// ============================================================================

import { CompliancePortalService } from '../services/compliance-portal/compliance-portal.service';
import { ComplianceChecklistService } from '../services/compliance-portal/compliance-checklist.service';
import { CompliancePreviewService } from '../services/compliance-portal/compliance-preview.service';
import { SandboxOrchestratorService } from '../services/compliance-portal/sandbox-orchestrator.service';
import { ComplianceSignOffService } from '../services/compliance-portal/compliance-signoff.service';
import { CompliancePortalController } from '../controllers/compliance-portal.controller';

// Check if already bound to avoid duplicate binding errors
if (!container.isBound(TYPES.CompliancePortalService)) {
  container.bind(TYPES.CompliancePortalService).to(CompliancePortalService).inSingletonScope();
}

if (!container.isBound(TYPES.ComplianceChecklistService)) {
  container.bind(TYPES.ComplianceChecklistService).to(ComplianceChecklistService).inSingletonScope();
}

if (!container.isBound(TYPES.CompliancePreviewService)) {
  container.bind(TYPES.CompliancePreviewService).to(CompliancePreviewService).inSingletonScope();
}

if (!container.isBound(TYPES.SandboxOrchestratorService)) {
  container.bind(TYPES.SandboxOrchestratorService).to(SandboxOrchestratorService).inSingletonScope();
}

if (!container.isBound(TYPES.ComplianceSignOffService)) {
  container.bind(TYPES.ComplianceSignOffService).to(ComplianceSignOffService).inSingletonScope();
}

if (!container.isBound(TYPES.CompliancePortalController)) {
  container.bind(TYPES.CompliancePortalController).to(CompliancePortalController).inSingletonScope();
}
```

Register routes in the main app:
```typescript
// In src/index.ts or wherever routes are registered
import { router as compliancePortalRoutes } from './routes/compliance-portal.routes';

app.use('/api/compliance-portal', compliancePortalRoutes);
```
  </action>
  <verify>npx tsc --noEmit web-erp-app/backend/src/routes/compliance-portal.routes.ts && npx tsc --noEmit web-erp-app/backend/src/config/container.ts</verify>
  <done>Routes and DI configuration compile successfully</done>
</task>

</tasks>

<verification>
1. Run `npx tsc --noEmit` - all files compile
2. Verify all endpoints are protected by authenticateJWT middleware
3. Verify DI container binds all services as singletons
4. Verify routes use correct HTTP methods (GET for reads, POST for actions)
</verification>

<success_criteria>
1. All 15+ endpoints defined and protected by JWT auth
2. DI container binds all 5 services and controller
3. Routes organized by feature area (dashboard, checklist, preview, sandbox, signoff)
4. Error handling returns consistent response format
5. Type symbols exported for external use
</success_criteria>

<output>
After completion, create `.planning/phases/08-compliance-verification-portal/08-07-SUMMARY.md`
</output>
