# Phase 2.5: Compliance-Native Accounting Foundation - Research

**Researched:** 2026-01-24
**Domain:** Financial Accounting Infrastructure, UAE Compliance
**Confidence:** HIGH

## Summary

This phase builds the accounting infrastructure that enables UAE compliance requirements. The research focused on decimal precision libraries, inventory valuation algorithms, loan amortization formulas, UAE Labor Law gratuity calculations, cash flow statement generation, and period closing procedures.

The codebase already has solid patterns in place: Prisma's native `Decimal` type with `@prisma/client/runtime/library` import, service-layer authorization with `validateCompanyAccess()`, detailed audit logging, and a working depreciation engine that demonstrates the calculation strategy pattern. These existing patterns should be extended, not replaced.

**Primary recommendation:** Leverage existing `Prisma.Decimal` for all financial calculations (already in use), add a thin decimal-math utility wrapper for common operations, and implement the Strategy pattern (already demonstrated in depreciation.service.ts) for interest calculations and inventory valuation.

## Standard Stack

The established libraries/tools for this domain:

### Core

| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| `@prisma/client` | 6.x | ORM with native Decimal support | Already in use, `Prisma.Decimal` based on decimal.js |
| `decimal.js` | 10.x | Underlying library for Prisma.Decimal | FTA requires exact AED amounts; IEEE 754 binary floats fail |
| TypeScript | 5.x | Type safety | Already in use; essential for financial code correctness |
| Node.js | 20.x LTS | Runtime | Already in production |

### Supporting

| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| `date-fns` | 3.x | Date calculations | Period calculations, fiscal year math |
| `luxon` | 3.x | Alternative to date-fns | If timezone-aware date math needed (Dubai TZ) |

### Alternatives Considered

| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| `Prisma.Decimal` | `dinero.js` | Dinero is money-specific but Prisma.Decimal is already integrated |
| `decimal.js` | `big.js` | Big.js is simpler but decimal.js has more features (Prisma uses decimal.js) |
| Custom loan calc | `financial-js` | NPM package exists but simple enough to implement; avoids dependency |

**Installation:**
```bash
# Already installed via Prisma
# No additional packages needed for decimal math

# If date utilities needed (verify existing setup first)
npm install date-fns
```

## Architecture Patterns

### Recommended Project Structure

```
web-erp-app/backend/src/
services/
  assets/
    core/
      base-asset.interface.ts        # IAsset interface
      base-asset.abstract.ts         # Abstract base with common logic
      asset.types.ts                 # Shared types/enums
      asset-gl-integration.ts        # GL entry generation
    inventory/
      inventory-asset.service.ts     # Main service
      valuation-calculator.ts        # FIFO/LIFO/Weighted strategies
    prepaid/
      prepaid-asset.service.ts
      amortization-scheduler.ts
    fixed/
      fixed-asset.enhanced.ts        # Extends existing
      component-depreciation.ts
    investments/
      investment-asset.service.ts
      market-valuation.service.ts
    intangibles/
      intangible-asset.service.ts
  finance/
    liability.service.ts
    interest-engine.service.ts       # Strategy pattern
    amortization.service.ts
    gratuity.service.ts              # UAE Labor Law
    closing-procedure.service.ts
    year-end-close.service.ts
    cash-flow-statement.service.ts
    management-reports.service.ts
  utils/
    decimal-math.util.ts             # Thin wrapper
```

### Pattern 1: Prisma Decimal Handling (HIGH confidence)

**What:** Use `Prisma.Decimal` from `@prisma/client/runtime/library` for all financial values.

**When to use:** All currency amounts, rates, percentages in the accounting module.

**Example:**
```typescript
// Source: Existing depreciation.service.ts pattern
import { Decimal } from '@prisma/client/runtime/library';

// Converting from Prisma Decimal to number for calculations
const acquisitionCost = Number(asset.acquisitionCost);
const residualValue = Number(asset.residualValue);

// Converting back to Decimal for storage
await tx.fixed_assets.update({
  where: { id: assetId },
  data: {
    totalDepreciation: new Decimal(newTotalDepreciation),
    netBookValue: new Decimal(newNBV),
  }
});

// Rounding for currency display
private roundCurrency(value: number): number {
  return Math.round(value * 100) / 100;
}
```

### Pattern 2: Strategy Pattern for Calculations (HIGH confidence)

**What:** Use Strategy pattern for different calculation methods (already used in depreciation).

**When to use:** Inventory valuation (FIFO/LIFO/Weighted), interest calculations, amortization methods.

**Example:**
```typescript
// Source: Based on existing depreciation.service.ts switch pattern
interface IInterestStrategy {
  calculate(
    principal: Decimal,
    rate: Decimal,
    periodMonths: number
  ): { interestAmount: Decimal; principalPayment: Decimal };
}

class AmortizedLoanStrategy implements IInterestStrategy {
  calculate(principal: Decimal, rate: Decimal, periodMonths: number) {
    // PMT formula: P * (r(1+r)^n) / ((1+r)^n - 1)
    const r = Number(rate) / 12 / 100; // Monthly rate
    const n = periodMonths;
    const P = Number(principal);

    const pmt = P * (r * Math.pow(1 + r, n)) / (Math.pow(1 + r, n) - 1);
    const interestAmount = P * r;
    const principalPayment = pmt - interestAmount;

    return {
      interestAmount: new Decimal(interestAmount),
      principalPayment: new Decimal(principalPayment),
    };
  }
}

class InterestOnlyStrategy implements IInterestStrategy {
  calculate(principal: Decimal, rate: Decimal, periodMonths: number) {
    const r = Number(rate) / 12 / 100;
    const interestAmount = Number(principal) * r;

    return {
      interestAmount: new Decimal(interestAmount),
      principalPayment: new Decimal(0), // Principal at maturity
    };
  }
}
```

### Pattern 3: Multi-Tenant Validation (HIGH confidence)

**What:** Validate company access at the start of every service method.

**When to use:** Every public method in every service.

**Example:**
```typescript
// Source: Existing depreciation.service.ts and fixed-asset.service.ts
private async validateCompanyAccess(
  userId: string,
  companyId: string
): Promise<void> {
  const user = await this.prisma.users.findUnique({
    where: { id: userId },
    select: { companyId: true }
  });

  if (!user) {
    throw new Error('User not found');
  }

  if (user.companyId !== companyId) {
    logger.security('Access denied:', {
      userId,
      requestedCompanyId: companyId,
      userCompanyId: user.companyId,
      timestamp: new Date().toISOString()
    });
    throw new Error('Access denied: Cannot access data from other company');
  }
}
```

### Pattern 4: Double-Entry Validation (HIGH confidence)

**What:** Validate debits equal credits before posting any journal entry.

**When to use:** All GL entry creation, closing entries, depreciation posting.

**Example:**
```typescript
// Source: Existing accounting-entry.service.ts pattern
interface JournalLine {
  accountId: string;
  debitAmount: Decimal;
  creditAmount: Decimal;
}

function validateDoubleEntry(lines: JournalLine[]): void {
  const totalDebit = lines.reduce(
    (sum, line) => sum + Number(line.debitAmount), 0
  );
  const totalCredit = lines.reduce(
    (sum, line) => sum + Number(line.creditAmount), 0
  );

  // Allow for small rounding differences (< 0.01)
  if (Math.abs(totalDebit - totalCredit) >= 0.01) {
    throw new Error(
      `Journal entry not balanced: Debits ${totalDebit.toFixed(2)} != Credits ${totalCredit.toFixed(2)}`
    );
  }
}
```

### Pattern 5: Audit Trail Integration (HIGH confidence)

**What:** Log all financial operations through ComplianceAuditService (from Phase 2).

**When to use:** All create, update, delete, and status change operations.

**Example:**
```typescript
// Source: Phase 2 audit infrastructure
import { ComplianceAuditService } from '../compliance/compliance-audit.service';

async postClosingEntry(
  companyId: string,
  periodId: string,
  userId: string,
  auditService: ComplianceAuditService
): Promise<void> {
  // ... create closing entry ...

  await auditService.logWithHashChain({
    companyId,
    userId,
    action: 'PERIOD_CLOSE',
    entity: 'closing_procedures',
    entityId: periodId,
    newValue: { status: 'CLOSED', closedAt: new Date() },
    ipAddress: context.ipAddress,
  });
}
```

### Anti-Patterns to Avoid

- **Floating-point for money:** Never use JavaScript `number` for currency storage. Always use `Prisma.Decimal`.
- **Client-side totals:** Never trust frontend-calculated amounts. Recalculate on server.
- **Cross-company queries:** Never query without `companyId` filter. Use `validateCompanyAccess()`.
- **Direct decimal arithmetic:** Avoid `decimalA + decimalB`. Convert to Number, calculate, convert back.
- **Unbalanced entries:** Never persist GL entries without validating debits = credits.

## Don't Hand-Roll

Problems that look simple but have existing solutions:

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Decimal precision | Custom BigInt wrapper | `Prisma.Decimal` (decimal.js) | Already integrated, battle-tested |
| PMT formula | Manual math | The formula below | Standard formula, easy to get wrong |
| Amortization schedule | Custom loop | Standard algorithm | Rounding errors accumulate, final payment adjustments needed |
| FIFO/LIFO tracking | Custom linked list | Database-ordered querying | DB handles ordering efficiently |
| UAE gratuity | Hardcoded formula | Configurable service | Labor law may change, need flexibility |
| Cash flow indirect | Manual adjustment lists | Systematic categorization | IFRS/IAS 7 has specific rules |

**Key insight:** Financial calculations have decades of standardization. The formulas are well-documented but easy to implement incorrectly due to rounding, edge cases, and regulatory requirements. Use the standard formulas exactly as specified.

## Common Pitfalls

### Pitfall 1: Floating-Point Precision Loss

**What goes wrong:** `0.1 + 0.2 = 0.30000000000000004` in JavaScript
**Why it happens:** IEEE 754 binary floating-point can't represent many decimals exactly
**How to avoid:** Always use `Prisma.Decimal` for storage and convert to Number only for calculations, then round back
**Warning signs:** Pennies off in totals, reconciliation differences, audit failures

### Pitfall 2: Amortization Rounding Accumulation

**What goes wrong:** Loan balance doesn't reach exactly zero after final payment
**Why it happens:** Each monthly calculation rounds, errors compound over 60+ months
**How to avoid:** Calculate all payments, then adjust the final payment to clear the balance
**Warning signs:** Tiny residual balances, final payment differs from schedule

### Pitfall 3: FIFO/LIFO Calculation Complexity

**What goes wrong:** Incorrect COGS when purchase lots are partially consumed
**Why it happens:** Need to track remaining quantities per lot, handle partial lot consumption
**How to avoid:** Store inventory movements as individual records, query in order (ASC for FIFO, DESC for LIFO)
**Warning signs:** Negative inventory values, COGS doesn't match expected costs

### Pitfall 4: Gratuity Calculation Edge Cases

**What goes wrong:** Incorrect gratuity for partial years or mid-year terminations
**Why it happens:** UAE Labor Law specifies 21 days/year for first 5 years, 30 days thereafter, prorated
**How to avoid:** Calculate complete years first, then prorate partial year at appropriate rate
**Warning signs:** Disputes with employees, MOHRE complaints

### Pitfall 5: Period Closing Without Checklist

**What goes wrong:** Closed periods with unposted transactions, unreconciled accounts
**Why it happens:** Rushing month-end close, skipping validation steps
**How to avoid:** Enforce 9-step checklist with status tracking, block close if steps incomplete
**Warning signs:** Adjusting entries in closed periods, audit findings

### Pitfall 6: Cash Flow Statement Working Capital Signs

**What goes wrong:** Increases in receivables shown as cash inflow (should be outflow)
**Why it happens:** Confusion about sign conventions for changes in current assets/liabilities
**How to avoid:** Use rule: Asset increases = subtract, Liability increases = add
**Warning signs:** Cash flow doesn't reconcile with balance sheet cash change

## Code Examples

Verified patterns from official sources and existing codebase:

### PMT Formula for Loan Amortization

```typescript
// Source: Standard financial formula, verified against Excel PMT function
// PMT = P * [r(1+r)^n] / [(1+r)^n - 1]
// where P = principal, r = periodic rate, n = number of periods

function calculatePMT(
  principal: number,
  annualRate: number,
  termMonths: number
): number {
  if (termMonths === 0) return principal;
  if (annualRate === 0) return principal / termMonths;

  const r = annualRate / 100 / 12; // Monthly rate
  const n = termMonths;
  const P = principal;

  const pmt = P * (r * Math.pow(1 + r, n)) / (Math.pow(1 + r, n) - 1);
  return Math.round(pmt * 100) / 100; // Round to cents
}

// Generate full amortization schedule
function generateAmortizationSchedule(
  principal: number,
  annualRate: number,
  termMonths: number
): Array<{
  period: number;
  payment: number;
  principal: number;
  interest: number;
  balance: number;
}> {
  const schedule = [];
  let balance = principal;
  const pmt = calculatePMT(principal, annualRate, termMonths);
  const r = annualRate / 100 / 12;

  for (let period = 1; period <= termMonths; period++) {
    const interest = Math.round(balance * r * 100) / 100;
    let principalPayment = Math.round((pmt - interest) * 100) / 100;

    // Adjust final payment to clear balance
    if (period === termMonths) {
      principalPayment = Math.round(balance * 100) / 100;
    }

    balance = Math.round((balance - principalPayment) * 100) / 100;

    schedule.push({
      period,
      payment: period === termMonths ? interest + principalPayment : pmt,
      principal: principalPayment,
      interest,
      balance: Math.max(0, balance),
    });
  }

  return schedule;
}
```

### UAE Gratuity Calculation

```typescript
// Source: UAE Federal Decree-Law No. 33 of 2021 (UAE Labor Law)
// https://u.ae/cy/information-and-services/jobs/employment-in-the-private-sector/end-of-service-benefits-for-employees-in-the-private-sector

interface GratuityResult {
  totalDays: number;
  gratuityAmount: number;
  breakdown: {
    yearsUnder5: number;
    daysUnder5: number;
    amountUnder5: number;
    yearsOver5: number;
    daysOver5: number;
    amountOver5: number;
  };
}

function calculateUAEGratuity(
  basicSalary: number,  // Monthly basic salary (no allowances)
  yearsOfService: number,  // Can be fractional (e.g., 5.5 years)
): GratuityResult {
  // Daily rate = monthly salary / 30
  const dailyRate = basicSalary / 30;

  // First 5 years: 21 days per year
  const yearsUnder5 = Math.min(yearsOfService, 5);
  const daysUnder5 = yearsUnder5 * 21;
  const amountUnder5 = daysUnder5 * dailyRate;

  // After 5 years: 30 days per year
  const yearsOver5 = Math.max(0, yearsOfService - 5);
  const daysOver5 = yearsOver5 * 30;
  const amountOver5 = daysOver5 * dailyRate;

  const totalDays = daysUnder5 + daysOver5;
  let gratuityAmount = amountUnder5 + amountOver5;

  // Maximum cap: 24 months basic salary (Article 51(7))
  const maxGratuity = basicSalary * 24;
  gratuityAmount = Math.min(gratuityAmount, maxGratuity);

  return {
    totalDays: Math.round(totalDays * 100) / 100,
    gratuityAmount: Math.round(gratuityAmount * 100) / 100,
    breakdown: {
      yearsUnder5: Math.round(yearsUnder5 * 100) / 100,
      daysUnder5: Math.round(daysUnder5 * 100) / 100,
      amountUnder5: Math.round(amountUnder5 * 100) / 100,
      yearsOver5: Math.round(yearsOver5 * 100) / 100,
      daysOver5: Math.round(daysOver5 * 100) / 100,
      amountOver5: Math.round(amountOver5 * 100) / 100,
    },
  };
}
```

### Inventory Valuation (FIFO)

```typescript
// Source: IAS 2 Inventories / GAAP inventory costing
// FIFO: First-In, First-Out

interface InventoryLot {
  id: string;
  purchaseDate: Date;
  quantity: number;
  unitCost: number;
  remainingQuantity: number;
}

interface COGSCalculation {
  totalCost: number;
  lotsConsumed: Array<{
    lotId: string;
    quantity: number;
    unitCost: number;
    cost: number;
  }>;
  remainingInventory: InventoryLot[];
}

function calculateFIFOCost(
  lots: InventoryLot[],
  quantityNeeded: number
): COGSCalculation {
  // Sort by purchase date ascending (oldest first)
  const sortedLots = [...lots]
    .filter(lot => lot.remainingQuantity > 0)
    .sort((a, b) => a.purchaseDate.getTime() - b.purchaseDate.getTime());

  let remaining = quantityNeeded;
  let totalCost = 0;
  const lotsConsumed: COGSCalculation['lotsConsumed'] = [];
  const remainingInventory: InventoryLot[] = [];

  for (const lot of sortedLots) {
    if (remaining <= 0) {
      remainingInventory.push({ ...lot });
      continue;
    }

    const quantityFromLot = Math.min(lot.remainingQuantity, remaining);
    const costFromLot = quantityFromLot * lot.unitCost;

    totalCost += costFromLot;
    remaining -= quantityFromLot;

    lotsConsumed.push({
      lotId: lot.id,
      quantity: quantityFromLot,
      unitCost: lot.unitCost,
      cost: Math.round(costFromLot * 100) / 100,
    });

    const newRemainingQuantity = lot.remainingQuantity - quantityFromLot;
    if (newRemainingQuantity > 0) {
      remainingInventory.push({
        ...lot,
        remainingQuantity: newRemainingQuantity,
      });
    }
  }

  if (remaining > 0) {
    throw new Error(`Insufficient inventory: need ${remaining} more units`);
  }

  return {
    totalCost: Math.round(totalCost * 100) / 100,
    lotsConsumed,
    remainingInventory,
  };
}
```

### Cash Flow Statement (Indirect Method)

```typescript
// Source: IAS 7 Statement of Cash Flows
// Indirect method: Net Income + Adjustments = Operating Cash Flow

interface CashFlowStatement {
  operating: {
    netIncome: number;
    adjustments: {
      depreciation: number;
      amortization: number;
      badDebtExpense: number;
      gainOnDisposal: number; // Negative if gain
      lossOnDisposal: number;
    };
    workingCapitalChanges: {
      receivables: number;  // Increase = negative
      inventory: number;    // Increase = negative
      prepaid: number;      // Increase = negative
      payables: number;     // Increase = positive
      accruals: number;     // Increase = positive
    };
    netOperatingCash: number;
  };
  investing: {
    purchaseOfAssets: number;     // Negative
    proceedsFromDisposal: number; // Positive
    purchaseOfInvestments: number; // Negative
    netInvestingCash: number;
  };
  financing: {
    loanProceeds: number;     // Positive
    loanRepayments: number;   // Negative
    dividendsPaid: number;    // Negative
    capitalInjection: number; // Positive
    netFinancingCash: number;
  };
  netCashChange: number;
  openingCash: number;
  closingCash: number;
}

function calculateIndirectCashFlow(
  openingBalanceSheet: BalanceSheet,
  closingBalanceSheet: BalanceSheet,
  incomeStatement: IncomeStatement,
  additionalData: {
    depreciation: number;
    amortization: number;
    assetPurchases: number;
    assetDisposalProceeds: number;
    disposalGainLoss: number;
    loanProceeds: number;
    loanRepayments: number;
    dividendsPaid: number;
  }
): CashFlowStatement {
  // Working capital changes (asset increase = cash outflow)
  const receivablesChange = -(
    closingBalanceSheet.receivables - openingBalanceSheet.receivables
  );
  const inventoryChange = -(
    closingBalanceSheet.inventory - openingBalanceSheet.inventory
  );
  const prepaidChange = -(
    closingBalanceSheet.prepaid - openingBalanceSheet.prepaid
  );

  // Working capital changes (liability increase = cash inflow)
  const payablesChange =
    closingBalanceSheet.payables - openingBalanceSheet.payables;
  const accrualsChange =
    closingBalanceSheet.accruals - openingBalanceSheet.accruals;

  // Operating section
  const netOperatingCash =
    incomeStatement.netIncome +
    additionalData.depreciation +
    additionalData.amortization -
    additionalData.disposalGainLoss + // Subtract gain, add loss
    receivablesChange +
    inventoryChange +
    prepaidChange +
    payablesChange +
    accrualsChange;

  // Investing section
  const netInvestingCash =
    -additionalData.assetPurchases +
    additionalData.assetDisposalProceeds;

  // Financing section
  const netFinancingCash =
    additionalData.loanProceeds -
    additionalData.loanRepayments -
    additionalData.dividendsPaid;

  const netCashChange = netOperatingCash + netInvestingCash + netFinancingCash;
  const closingCash = openingBalanceSheet.cash + netCashChange;

  return {
    operating: {
      netIncome: incomeStatement.netIncome,
      adjustments: {
        depreciation: additionalData.depreciation,
        amortization: additionalData.amortization,
        badDebtExpense: 0, // TODO: Calculate from allowance changes
        gainOnDisposal: additionalData.disposalGainLoss < 0
          ? additionalData.disposalGainLoss : 0,
        lossOnDisposal: additionalData.disposalGainLoss > 0
          ? additionalData.disposalGainLoss : 0,
      },
      workingCapitalChanges: {
        receivables: receivablesChange,
        inventory: inventoryChange,
        prepaid: prepaidChange,
        payables: payablesChange,
        accruals: accrualsChange,
      },
      netOperatingCash,
    },
    investing: {
      purchaseOfAssets: -additionalData.assetPurchases,
      proceedsFromDisposal: additionalData.assetDisposalProceeds,
      purchaseOfInvestments: 0,
      netInvestingCash,
    },
    financing: {
      loanProceeds: additionalData.loanProceeds,
      loanRepayments: -additionalData.loanRepayments,
      dividendsPaid: -additionalData.dividendsPaid,
      capitalInjection: 0,
      netFinancingCash,
    },
    netCashChange,
    openingCash: openingBalanceSheet.cash,
    closingCash,
  };
}
```

### IFRS 16 Lease Liability Calculation

```typescript
// Source: IFRS 16 Leases (effective 2019)
// Present value of lease payments

function calculateLeaseIFRS16(
  monthlyPayment: number,
  termMonths: number,
  incrementalBorrowingRate: number // Annual %
): {
  initialLiability: number;
  initialRouAsset: number;
  schedule: Array<{
    period: number;
    openingLiability: number;
    interestExpense: number;
    payment: number;
    closingLiability: number;
    rouAssetDepreciation: number;
    rouAssetNBV: number;
  }>;
} {
  const r = incrementalBorrowingRate / 100 / 12; // Monthly rate

  // PV of annuity: PMT * [(1 - (1+r)^-n) / r]
  const pvFactor = (1 - Math.pow(1 + r, -termMonths)) / r;
  const initialLiability = Math.round(monthlyPayment * pvFactor * 100) / 100;
  const initialRouAsset = initialLiability; // Simplified, can add initial direct costs

  const monthlyDepreciation = initialRouAsset / termMonths;
  const schedule = [];
  let liability = initialLiability;
  let rouAssetNBV = initialRouAsset;

  for (let period = 1; period <= termMonths; period++) {
    const interestExpense = Math.round(liability * r * 100) / 100;
    const principalPayment = monthlyPayment - interestExpense;
    liability = Math.round((liability - principalPayment) * 100) / 100;
    rouAssetNBV = Math.round((rouAssetNBV - monthlyDepreciation) * 100) / 100;

    schedule.push({
      period,
      openingLiability: liability + principalPayment,
      interestExpense,
      payment: monthlyPayment,
      closingLiability: Math.max(0, liability),
      rouAssetDepreciation: Math.round(monthlyDepreciation * 100) / 100,
      rouAssetNBV: Math.max(0, rouAssetNBV),
    });
  }

  return {
    initialLiability,
    initialRouAsset,
    schedule,
  };
}
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Boolean `isAdmin` flags | Pack-role permission system | 2025 (this project) | Use `requirePermission()` |
| Shared single database | Multi-tenant with per-company DBs | 2025 (Phase 1) | All queries scoped to tenant |
| Native JS `number` for money | `Prisma.Decimal` (decimal.js) | Already in use | No change needed |
| Manual journal entries | Double-entry validation | Already in use | Extend for new modules |
| UTC-only timestamps | Dubai timezone awareness | Consider | Use `luxon` if needed |

**Deprecated/outdated:**
- `isCompanyAdmin` boolean: Use pack-role system
- Manual companyId filtering: Use `validateCompanyAccess()` pattern
- JavaScript `number` for currency: Use `Prisma.Decimal`

## Open Questions

Things that couldn't be fully resolved:

1. **Component Depreciation Database Design**
   - What we know: IAS 16 requires component-level depreciation for significant components
   - What's unclear: Best schema design - separate `asset_components` table vs JSON in `fixed_assets`
   - Recommendation: Use separate table for query flexibility and audit trail

2. **Bank Reconciliation Matching Algorithm**
   - What we know: Need to match bank statement lines to GL transactions
   - What's unclear: Best algorithm for fuzzy matching (amount + date tolerance)
   - Recommendation: Start with exact match, add configurable tolerance later

3. **Period 13 Audit Adjustments**
   - What we know: Auditors need adjustment period after year-end close
   - What's unclear: How to allow Period 13 entries while keeping regular year locked
   - Recommendation: Add `isAdjustmentPeriod` flag to fiscal_periods, special close logic

4. **Investment Mark-to-Market Frequency**
   - What we know: FTA may require fair value reporting for certain investments
   - What's unclear: Specific requirements for UAE Corporate Tax purposes
   - Recommendation: Support daily, monthly, quarterly valuation options

## Sources

### Primary (HIGH confidence)

- Existing codebase: `depreciation.service.ts`, `fixed-asset.service.ts` - Prisma Decimal patterns
- [Prisma Fields & Types Documentation](https://www.prisma.io/docs/orm/prisma-client/special-fields-and-types) - Decimal handling
- [UAE Federal Decree-Law No. 33 of 2021](https://u.ae/cy/information-and-services/jobs/employment-in-the-private-sector/end-of-service-benefits-for-employees-in-the-private-sector) - Gratuity calculation
- [IAS 2 Inventories](https://ifrscommunity.com/knowledge-base/fifo-lifo-weighted-average-cost/) - FIFO/LIFO methods
- [IAS 7 Statement of Cash Flows](https://www.accountingtools.com/articles/cash-flow-statement-indirect-method) - Indirect method

### Secondary (MEDIUM confidence)

- [IFRS 16 Leases](https://www.ifrs.org/issued-standards/list-of-standards/ifrs-16-leases/) - ROU asset calculations
- [PMT Formula Reference](https://support.microsoft.com/en-us/office/pmt-function-0214da64-9a63-4996-bc20-214433fa6441) - Microsoft Excel documentation
- [NetSuite Month-End Close](https://www.netsuite.com/portal/resource/articles/accounting/improve-months-end-closing.shtml) - Best practices
- [UAE Gratuity Calculator 2026](https://uaegratuity.org/) - Verification of calculation rules

### Tertiary (LOW confidence)

- WebSearch results for "decimal.js TypeScript best practices" - General patterns
- WebSearch results for "InversifyJS dependency injection" - DI patterns (not verified with official docs)

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - Verified against existing codebase patterns
- Architecture: HIGH - Based on existing service implementations
- Pitfalls: HIGH - Documented from official accounting standards
- Code examples: HIGH - PMT/gratuity verified against official sources
- IFRS 16: MEDIUM - Standard is clear but implementation patterns vary

**Research date:** 2026-01-24
**Valid until:** 2026-02-24 (30 days - stable accounting standards)

---

## Quick Reference for Planner

### Key Decisions Already Made

1. **Decimal handling:** Use `Prisma.Decimal` from `@prisma/client/runtime/library`
2. **Strategy pattern:** For interest calculations, inventory valuation (follow depreciation.service.ts)
3. **Multi-tenant:** Every service method starts with `validateCompanyAccess()`
4. **Audit trail:** All operations log through Phase 2's `ComplianceAuditService`
5. **Double-entry:** Validate debits = credits before any GL entry creation

### Critical Formulas

1. **PMT:** `P * [r(1+r)^n] / [(1+r)^n - 1]`
2. **UAE Gratuity:** 21 days/year first 5 years, 30 days/year thereafter, max 24 months
3. **IFRS 16 PV:** `PMT * [(1 - (1+r)^-n) / r]`
4. **Cash Flow Sign Rule:** Asset increase = subtract, Liability increase = add

### Files to Reference

- `/web-erp-app/backend/src/services/finance/depreciation.service.ts` - Strategy pattern example
- `/web-erp-app/backend/src/services/finance/fixed-asset.service.ts` - Asset lifecycle example
- `/web-erp-app/backend/prisma/tenant-schema.prisma` - Existing schema patterns
