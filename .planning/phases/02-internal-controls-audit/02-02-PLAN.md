---
phase: 02-internal-controls-audit
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - web-erp-app/backend/src/services/compliance/compliance-audit.service.ts
  - web-erp-app/backend/src/services/compliance/audit-integrity.service.ts
  - web-erp-app/backend/src/config/types.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Compliance audit logs include hash chain for tamper detection"
    - "Hash chain integrity can be verified on demand"
    - "Previous hash links each record to prior record"
    - "Sequence numbers are atomically assigned without gaps"
  artifacts:
    - path: "web-erp-app/backend/src/services/compliance/compliance-audit.service.ts"
      provides: "Tamper-proof audit logging with hash chain"
      exports: ["ComplianceAuditService"]
    - path: "web-erp-app/backend/src/services/compliance/audit-integrity.service.ts"
      provides: "Hash chain verification service"
      exports: ["AuditIntegrityService"]
    - path: "web-erp-app/backend/src/config/types.ts"
      provides: "DI container types for new services"
      contains: "ComplianceAuditService"
  key_links:
    - from: "compliance-audit.service.ts"
      to: "audit_logs_seq SEQUENCE"
      via: "Prisma $queryRaw for nextval"
      pattern: "nextval.*audit_logs_seq"
    - from: "compliance-audit.service.ts"
      to: "crypto.createHash"
      via: "Node.js crypto for SHA-256"
      pattern: "createHash.*sha256"
    - from: "audit-integrity.service.ts"
      to: "audit_logs table"
      via: "Sequential scan for chain verification"
      pattern: "orderBy.*sequenceNumber"
---

<objective>
Create ComplianceAuditService that extends AuditService with hash chain logic, and AuditIntegrityService for verifying audit log integrity.

Purpose: Implement the tamper-proof audit logging mechanism using hash chains. Each audit record contains SHA-256 hash of the previous record, creating an unbroken chain that can be verified. This satisfies CTRL-03 (tamper-proof logs) and enables FTA compliance verification.

Output: ComplianceAuditService with `logWithHashChain()` method, AuditIntegrityService with `verifyIntegrity()` method, and DI container integration.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-internal-controls-audit/02-RESEARCH.md
@.planning/phases/02-internal-controls-audit/02-01-PLAN.md (schema changes this depends on)
@web-erp-app/backend/src/services/audit.service.ts
@web-erp-app/backend/src/types/compliance/audit.types.ts
@web-erp-app/backend/src/config/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ComplianceAuditService with hash chain implementation</name>
  <files>
    web-erp-app/backend/src/services/compliance/compliance-audit.service.ts
  </files>
  <action>
Create ComplianceAuditService that extends AuditService with tamper-proof logging:

```typescript
/**
 * Compliance Audit Service
 * Phase: 02-internal-controls-audit
 * Requirements: CTRL-01, CTRL-02, CTRL-03
 *
 * Extends base AuditService with tamper-proof hash chain logging for FTA compliance.
 * Every FTA-sensitive audit record contains SHA-256 hash of previous record.
 */

import { PrismaClient, Prisma, AuditAction } from '@prisma/client';
import { injectable, inject } from 'inversify';
import { createHash, randomUUID } from 'crypto';
import { TYPES } from '../../config/types';
import { AuditService, AuditContext, AuditLogInput } from '../audit.service';
import {
  TamperProofAuditRecord,
  TamperProofAuditInput,
  isFtaAuditAction,
  GENESIS_HASH,
  HASH_ALGORITHM,
} from '../../types/compliance/audit.types';
import logger from '../logger.service';

/**
 * ComplianceAuditService
 *
 * Provides tamper-proof audit logging with hash chain for FTA compliance.
 * Use this service for all FTA-sensitive operations (VAT submission, TRN changes, etc.)
 *
 * Hash Chain Pattern:
 * - Each record contains SHA-256 hash of previous record (previousHash)
 * - Each record contains SHA-256 hash of its own data (recordHash)
 * - Chain can be verified by recalculating hashes sequentially
 * - Any tampering breaks the chain and is detectable
 */
@injectable()
export class ComplianceAuditService extends AuditService {
  constructor(
    @inject(TYPES.PrismaClient) prisma: PrismaClient
  ) {
    super(prisma);
  }

  /**
   * Creates tamper-proof audit log with hash chain
   * MUST be called within a Prisma transaction for atomicity
   *
   * This method:
   * 1. Gets next sequence number atomically from PostgreSQL SEQUENCE
   * 2. Fetches previous record's hash (or GENESIS for first record)
   * 3. Calculates SHA-256 hash of current record including previousHash
   * 4. Inserts record with all tamper-proof fields
   *
   * @param tx - Prisma transaction client (required for atomicity)
   * @param context - Audit context (userId, companyId, IP, etc.)
   * @param input - Audit log input (action, entity, values)
   */
  async logWithHashChain(
    tx: Prisma.TransactionClient,
    context: AuditContext,
    input: TamperProofAuditInput
  ): Promise<TamperProofAuditRecord> {
    try {
      // 1. Get next sequence number atomically
      const sequenceResult = await tx.$queryRaw<[{ nextval: bigint }]>`
        SELECT nextval('audit_logs_seq')
      `;
      const sequenceNumber = sequenceResult[0].nextval;

      // 2. Get previous record's hash (if exists)
      const previousRecord = await tx.audit_logs.findFirst({
        where: {
          sequenceNumber: { not: null },
        },
        orderBy: { sequenceNumber: 'desc' },
        select: { recordHash: true, sequenceNumber: true },
      });

      const previousHash = previousRecord?.recordHash || GENESIS_HASH;

      // 3. Prepare record data (sanitize sensitive fields)
      const id = randomUUID();
      const createdAt = new Date();
      const sanitizedOldValue = this.sanitizeData(input.oldValue);
      const sanitizedNewValue = this.sanitizeData(input.newValue);

      const recordData = {
        id,
        sequenceNumber,
        userId: context.userId,
        action: input.action,
        entity: input.entity,
        entityId: input.entityId,
        oldValue: sanitizedOldValue,
        newValue: sanitizedNewValue,
        ipAddress: context.ipAddress || null,
        userAgent: context.userAgent || null,
        createdAt: createdAt.toISOString(),
        previousHash,
      };

      // 4. Calculate record hash
      const recordHash = this.calculateRecordHash(recordData);

      // 5. Insert with all tamper-proof fields
      await tx.audit_logs.create({
        data: {
          id,
          sequenceNumber,
          previousHash,
          recordHash,
          userId: context.userId,
          action: input.action,
          entity: input.entity,
          entityId: input.entityId,
          oldValue: this.encryptSensitiveData(sanitizedOldValue),
          newValue: this.encryptSensitiveData(sanitizedNewValue),
          ipAddress: context.ipAddress,
          userAgent: context.userAgent,
          createdAt,
        },
      });

      logger.info('[ComplianceAudit] Hash chain audit log created', {
        id,
        sequenceNumber: sequenceNumber.toString(),
        action: input.action,
        entity: input.entity,
        entityId: input.entityId,
      });

      return {
        id,
        sequenceNumber,
        previousHash,
        recordHash,
        userId: context.userId,
        action: input.action,
        entity: input.entity,
        entityId: input.entityId,
        oldValue: sanitizedOldValue,
        newValue: sanitizedNewValue,
        ipAddress: context.ipAddress || null,
        userAgent: context.userAgent || null,
        createdAt,
      };
    } catch (error) {
      logger.error('[ComplianceAudit] Failed to create hash chain audit log', {
        error: error instanceof Error ? error.message : error,
        action: input.action,
        entity: input.entity,
        entityId: input.entityId,
      });
      throw error;
    }
  }

  /**
   * Smart log method - uses hash chain for FTA actions, standard log otherwise
   * Automatically determines if hash chain is needed based on action type
   */
  async logSmart(
    tx: Prisma.TransactionClient,
    context: AuditContext,
    input: AuditLogInput
  ): Promise<void> {
    if (isFtaAuditAction(input.action)) {
      await this.logWithHashChain(tx, context, input);
    } else {
      // Use parent class standard logging
      await this.log(tx, context, input);
    }
  }

  /**
   * Calculates SHA-256 hash of record data
   * Deterministic - same input always produces same hash
   *
   * @param recordData - Record fields to hash (includes previousHash for chain)
   * @returns Hexadecimal SHA-256 hash string (64 chars)
   */
  private calculateRecordHash(recordData: Record<string, unknown>): string {
    // Sort keys for deterministic JSON stringification
    const sortedData = this.sortObjectKeys(recordData);
    const dataString = JSON.stringify(sortedData);
    return createHash(HASH_ALGORITHM).update(dataString).digest('hex');
  }

  /**
   * Recursively sorts object keys for deterministic JSON
   */
  private sortObjectKeys(obj: unknown): unknown {
    if (obj === null || typeof obj !== 'object') {
      return obj;
    }

    if (Array.isArray(obj)) {
      return obj.map((item) => this.sortObjectKeys(item));
    }

    const sorted: Record<string, unknown> = {};
    const keys = Object.keys(obj as Record<string, unknown>).sort();
    for (const key of keys) {
      sorted[key] = this.sortObjectKeys((obj as Record<string, unknown>)[key]);
    }
    return sorted;
  }

  /**
   * Sanitizes data by removing sensitive fields (passwords, tokens, etc.)
   * Wraps parent class sanitize method
   */
  private sanitizeData(data: unknown): Record<string, unknown> | null {
    if (!data || typeof data !== 'object') return null;
    // Access parent's sanitize via prototype if needed, or duplicate logic
    return this.sanitize(data);
  }

  /**
   * Encrypts sensitive fields in data (PII, financial data)
   * Wraps parent class encryption
   */
  private encryptSensitiveData(data: unknown): Record<string, unknown> | null {
    if (!data || typeof data !== 'object') return null;
    return this.encryptSensitiveFields(data);
  }

  /**
   * Protected wrapper to access parent's sanitize method
   */
  protected sanitize(data: unknown): Record<string, unknown> {
    // Re-implement sanitization logic from parent
    if (!data || typeof data !== 'object') return data as Record<string, unknown>;

    const sensitive = ['password', 'token', 'secret', 'apikey', 'authorization'];
    const sanitized = Array.isArray(data) ? [...data] : { ...data };

    for (const key of Object.keys(sanitized)) {
      const lowerKey = key.toLowerCase();
      if (sensitive.some((s) => lowerKey.includes(s))) {
        (sanitized as Record<string, unknown>)[key] = '[REDACTED]';
      } else if (typeof (sanitized as Record<string, unknown>)[key] === 'object' && (sanitized as Record<string, unknown>)[key] !== null) {
        (sanitized as Record<string, unknown>)[key] = this.sanitize((sanitized as Record<string, unknown>)[key]);
      }
    }

    return sanitized as Record<string, unknown>;
  }

  /**
   * Protected wrapper to access parent's encryptSensitiveFields method
   */
  protected encryptSensitiveFields(data: unknown): Record<string, unknown> {
    // Delegate to parent's encryption logic if available
    // For now, return data as-is since parent method is private
    // In production, call parent's method or use shared encryption utility
    return data as Record<string, unknown>;
  }

  /**
   * Gets the latest sequence number for reference
   */
  async getLatestSequenceNumber(): Promise<bigint | null> {
    const latest = await (this as any).prisma.audit_logs.findFirst({
      where: { sequenceNumber: { not: null } },
      orderBy: { sequenceNumber: 'desc' },
      select: { sequenceNumber: true },
    });
    return latest?.sequenceNumber || null;
  }

  /**
   * Gets audit log by sequence number
   */
  async getBySequenceNumber(sequenceNumber: bigint): Promise<TamperProofAuditRecord | null> {
    const record = await (this as any).prisma.audit_logs.findFirst({
      where: { sequenceNumber },
    });

    if (!record) return null;

    return {
      id: record.id,
      sequenceNumber: record.sequenceNumber,
      previousHash: record.previousHash,
      recordHash: record.recordHash,
      userId: record.userId,
      action: record.action,
      entity: record.entity,
      entityId: record.entityId,
      oldValue: record.oldValue as Record<string, unknown> | null,
      newValue: record.newValue as Record<string, unknown> | null,
      ipAddress: record.ipAddress,
      userAgent: record.userAgent,
      createdAt: record.createdAt,
    };
  }
}
```

IMPORTANT: Create the directory first:
```bash
mkdir -p web-erp-app/backend/src/services/compliance
```
  </action>
  <verify>
1. File exists at src/services/compliance/compliance-audit.service.ts
2. TypeScript compiles without errors: `npx tsc --noEmit src/services/compliance/compliance-audit.service.ts`
3. Class extends AuditService
4. logWithHashChain method uses SEQUENCE for atomic numbering
5. calculateRecordHash uses SHA-256
  </verify>
  <done>
ComplianceAuditService created with: logWithHashChain() for tamper-proof logging, logSmart() for automatic hash chain detection, calculateRecordHash() for SHA-256, getLatestSequenceNumber() and getBySequenceNumber() for queries. Uses PostgreSQL SEQUENCE via $queryRaw for atomic numbering.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create AuditIntegrityService for hash chain verification</name>
  <files>
    web-erp-app/backend/src/services/compliance/audit-integrity.service.ts
  </files>
  <action>
Create AuditIntegrityService for verifying hash chain integrity:

```typescript
/**
 * Audit Integrity Service
 * Phase: 02-internal-controls-audit
 * Requirements: CTRL-03 (tamper-proof logs verification)
 *
 * Provides hash chain verification to detect any tampering with audit logs.
 * Run periodically or on-demand for FTA compliance verification.
 */

import { PrismaClient, AuditAction } from '@prisma/client';
import { injectable, inject } from 'inversify';
import { createHash } from 'crypto';
import { TYPES } from '../../config/types';
import {
  AuditIntegrityResult,
  HashChainVerificationOptions,
  GENESIS_HASH,
  HASH_ALGORITHM,
} from '../../types/compliance/audit.types';
import logger from '../logger.service';

/**
 * Audit log record structure for verification
 */
interface AuditLogRecord {
  id: string;
  sequenceNumber: bigint | null;
  previousHash: string | null;
  recordHash: string | null;
  userId: string | null;
  action: AuditAction;
  entity: string;
  entityId: string;
  oldValue: unknown;
  newValue: unknown;
  ipAddress: string | null;
  userAgent: string | null;
  createdAt: Date;
}

/**
 * AuditIntegrityService
 *
 * Verifies the integrity of the audit log hash chain.
 * Detects:
 * - Modified records (hash mismatch)
 * - Deleted records (chain break)
 * - Inserted records (sequence/hash anomaly)
 */
@injectable()
export class AuditIntegrityService {
  constructor(
    @inject(TYPES.PrismaClient) private readonly prisma: PrismaClient
  ) {}

  /**
   * Verifies hash chain integrity for audit logs
   * Scans records sequentially and validates each hash
   *
   * @param options - Verification options (date range, batch size)
   * @returns Verification result with validity status and details
   */
  async verifyIntegrity(
    options?: HashChainVerificationOptions
  ): Promise<AuditIntegrityResult> {
    const startTime = new Date();
    const {
      startSequence,
      endSequence,
      startDate,
      endDate,
      batchSize = 1000,
    } = options || {};

    try {
      // Build where clause based on options
      const whereClause: Record<string, unknown> = {
        sequenceNumber: { not: null },
        recordHash: { not: null },
      };

      if (startSequence !== undefined) {
        whereClause.sequenceNumber = { ...whereClause.sequenceNumber as object, gte: startSequence };
      }
      if (endSequence !== undefined) {
        whereClause.sequenceNumber = { ...whereClause.sequenceNumber as object, lte: endSequence };
      }
      if (startDate) {
        whereClause.createdAt = { gte: startDate };
      }
      if (endDate) {
        whereClause.createdAt = { ...whereClause.createdAt as object, lte: endDate };
      }

      // Count total records to verify
      const totalCount = await this.prisma.audit_logs.count({
        where: whereClause,
      });

      if (totalCount === 0) {
        return {
          valid: true,
          checkedCount: 0,
          verificationTimestamp: startTime,
        };
      }

      // Process in batches to handle large tables
      let checkedCount = 0;
      let lastSequence: bigint | null = null;
      let previousHash = GENESIS_HASH;

      // Get the first record to establish starting previousHash
      if (startSequence !== undefined && startSequence > 1) {
        const priorRecord = await this.prisma.audit_logs.findFirst({
          where: { sequenceNumber: BigInt(startSequence - 1) },
          select: { recordHash: true },
        });
        if (priorRecord?.recordHash) {
          previousHash = priorRecord.recordHash;
        }
      }

      while (checkedCount < totalCount) {
        const batch = await this.prisma.audit_logs.findMany({
          where: {
            ...whereClause,
            ...(lastSequence !== null && { sequenceNumber: { gt: lastSequence } }),
          },
          orderBy: { sequenceNumber: 'asc' },
          take: batchSize,
        }) as AuditLogRecord[];

        if (batch.length === 0) break;

        for (const record of batch) {
          if (!record.sequenceNumber || !record.recordHash) {
            continue; // Skip pre-tamperproof records
          }

          // 1. Verify chain continuity (previousHash matches)
          if (record.previousHash !== previousHash) {
            logger.warn('[AuditIntegrity] Chain break detected', {
              sequenceNumber: record.sequenceNumber.toString(),
              expectedPreviousHash: previousHash,
              actualPreviousHash: record.previousHash,
            });

            return {
              valid: false,
              checkedCount,
              firstInvalidSequence: Number(record.sequenceNumber),
              error: `Chain break at sequence ${record.sequenceNumber}: previousHash mismatch`,
              verificationTimestamp: startTime,
            };
          }

          // 2. Recalculate and verify record hash
          const expectedHash = this.calculateRecordHash(record);
          if (record.recordHash !== expectedHash) {
            logger.warn('[AuditIntegrity] Hash mismatch detected', {
              sequenceNumber: record.sequenceNumber.toString(),
              expectedHash,
              actualHash: record.recordHash,
            });

            return {
              valid: false,
              checkedCount,
              firstInvalidSequence: Number(record.sequenceNumber),
              error: `Hash mismatch at sequence ${record.sequenceNumber}: record may have been tampered`,
              verificationTimestamp: startTime,
            };
          }

          // Update for next iteration
          previousHash = record.recordHash;
          lastSequence = record.sequenceNumber;
          checkedCount++;
        }
      }

      logger.info('[AuditIntegrity] Verification completed successfully', {
        checkedCount,
        durationMs: Date.now() - startTime.getTime(),
      });

      return {
        valid: true,
        checkedCount,
        verificationTimestamp: startTime,
      };
    } catch (error) {
      logger.error('[AuditIntegrity] Verification failed with error', {
        error: error instanceof Error ? error.message : error,
      });

      return {
        valid: false,
        checkedCount: 0,
        error: `Verification failed: ${error instanceof Error ? error.message : 'Unknown error'}`,
        verificationTimestamp: startTime,
      };
    }
  }

  /**
   * Quick integrity check - verifies only the last N records
   * Useful for frequent automated checks
   *
   * @param count - Number of recent records to verify (default: 100)
   */
  async verifyRecentRecords(count: number = 100): Promise<AuditIntegrityResult> {
    const startTime = new Date();

    try {
      // Get the latest N records
      const records = await this.prisma.audit_logs.findMany({
        where: {
          sequenceNumber: { not: null },
          recordHash: { not: null },
        },
        orderBy: { sequenceNumber: 'desc' },
        take: count,
      }) as AuditLogRecord[];

      if (records.length === 0) {
        return {
          valid: true,
          checkedCount: 0,
          verificationTimestamp: startTime,
        };
      }

      // Reverse to process in sequence order
      records.reverse();

      // Get the previousHash for the first record in our range
      const firstRecord = records[0];
      let previousHash = GENESIS_HASH;

      if (firstRecord.sequenceNumber && firstRecord.sequenceNumber > BigInt(1)) {
        const priorRecord = await this.prisma.audit_logs.findFirst({
          where: { sequenceNumber: firstRecord.sequenceNumber - BigInt(1) },
          select: { recordHash: true },
        });
        if (priorRecord?.recordHash) {
          previousHash = priorRecord.recordHash;
        }
      }

      // Verify the chain
      for (const record of records) {
        if (!record.sequenceNumber || !record.recordHash) {
          continue;
        }

        if (record.previousHash !== previousHash) {
          return {
            valid: false,
            checkedCount: records.indexOf(record),
            firstInvalidSequence: Number(record.sequenceNumber),
            error: `Chain break at sequence ${record.sequenceNumber}`,
            verificationTimestamp: startTime,
          };
        }

        const expectedHash = this.calculateRecordHash(record);
        if (record.recordHash !== expectedHash) {
          return {
            valid: false,
            checkedCount: records.indexOf(record),
            firstInvalidSequence: Number(record.sequenceNumber),
            error: `Hash mismatch at sequence ${record.sequenceNumber}`,
            verificationTimestamp: startTime,
          };
        }

        previousHash = record.recordHash;
      }

      return {
        valid: true,
        checkedCount: records.length,
        verificationTimestamp: startTime,
      };
    } catch (error) {
      return {
        valid: false,
        checkedCount: 0,
        error: `Verification failed: ${error instanceof Error ? error.message : 'Unknown error'}`,
        verificationTimestamp: startTime,
      };
    }
  }

  /**
   * Gets integrity statistics for compliance reporting
   */
  async getIntegrityStats(): Promise<{
    totalRecords: number;
    hashChainRecords: number;
    preTamperproofRecords: number;
    latestSequence: number | null;
    oldestHashedRecord: Date | null;
    newestHashedRecord: Date | null;
  }> {
    const [totalRecords, hashChainRecords, latestRecord, oldestHashed, newestHashed] = await Promise.all([
      this.prisma.audit_logs.count(),
      this.prisma.audit_logs.count({
        where: { sequenceNumber: { not: null }, recordHash: { not: null } },
      }),
      this.prisma.audit_logs.findFirst({
        where: { sequenceNumber: { not: null } },
        orderBy: { sequenceNumber: 'desc' },
        select: { sequenceNumber: true },
      }),
      this.prisma.audit_logs.findFirst({
        where: { sequenceNumber: { not: null } },
        orderBy: { sequenceNumber: 'asc' },
        select: { createdAt: true },
      }),
      this.prisma.audit_logs.findFirst({
        where: { sequenceNumber: { not: null } },
        orderBy: { sequenceNumber: 'desc' },
        select: { createdAt: true },
      }),
    ]);

    return {
      totalRecords,
      hashChainRecords,
      preTamperproofRecords: totalRecords - hashChainRecords,
      latestSequence: latestRecord?.sequenceNumber ? Number(latestRecord.sequenceNumber) : null,
      oldestHashedRecord: oldestHashed?.createdAt || null,
      newestHashedRecord: newestHashed?.createdAt || null,
    };
  }

  /**
   * Calculates SHA-256 hash of record data (same algorithm as ComplianceAuditService)
   */
  private calculateRecordHash(record: AuditLogRecord): string {
    const recordData = {
      id: record.id,
      sequenceNumber: record.sequenceNumber?.toString(),
      userId: record.userId,
      action: record.action,
      entity: record.entity,
      entityId: record.entityId,
      oldValue: record.oldValue,
      newValue: record.newValue,
      ipAddress: record.ipAddress,
      userAgent: record.userAgent,
      createdAt: record.createdAt.toISOString(),
      previousHash: record.previousHash,
    };

    const sortedData = this.sortObjectKeys(recordData);
    const dataString = JSON.stringify(sortedData);
    return createHash(HASH_ALGORITHM).update(dataString).digest('hex');
  }

  /**
   * Recursively sorts object keys for deterministic JSON
   */
  private sortObjectKeys(obj: unknown): unknown {
    if (obj === null || typeof obj !== 'object') {
      return obj;
    }

    if (Array.isArray(obj)) {
      return obj.map((item) => this.sortObjectKeys(item));
    }

    const sorted: Record<string, unknown> = {};
    const keys = Object.keys(obj as Record<string, unknown>).sort();
    for (const key of keys) {
      sorted[key] = this.sortObjectKeys((obj as Record<string, unknown>)[key]);
    }
    return sorted;
  }
}
```
  </action>
  <verify>
1. File exists at src/services/compliance/audit-integrity.service.ts
2. TypeScript compiles: `npx tsc --noEmit src/services/compliance/audit-integrity.service.ts`
3. verifyIntegrity method processes records in batches
4. verifyRecentRecords provides quick check option
5. Hash calculation matches ComplianceAuditService algorithm
  </verify>
  <done>
AuditIntegrityService created with: verifyIntegrity() for full chain verification, verifyRecentRecords() for quick checks, getIntegrityStats() for compliance reporting. Uses same SHA-256 algorithm as ComplianceAuditService for consistent hash calculation.
  </done>
</task>

<task type="auto">
  <name>Task 3: Register services in DI container</name>
  <files>
    web-erp-app/backend/src/config/types.ts
  </files>
  <action>
Update the DI container types to include the new compliance services. Read the existing types.ts file first, then add:

```typescript
// Add to TYPES object:
ComplianceAuditService: Symbol.for('ComplianceAuditService'),
AuditIntegrityService: Symbol.for('AuditIntegrityService'),
```

Also update the container.ts (if it exists) or create container bindings:

```typescript
// In container setup file:
import { ComplianceAuditService } from '../services/compliance/compliance-audit.service';
import { AuditIntegrityService } from '../services/compliance/audit-integrity.service';

container.bind<ComplianceAuditService>(TYPES.ComplianceAuditService).to(ComplianceAuditService);
container.bind<AuditIntegrityService>(TYPES.AuditIntegrityService).to(AuditIntegrityService);
```

If container.ts doesn't exist, create an index.ts in services/compliance/ that exports the services:

```typescript
// web-erp-app/backend/src/services/compliance/index.ts
export { ComplianceAuditService } from './compliance-audit.service';
export { AuditIntegrityService } from './audit-integrity.service';
```
  </action>
  <verify>
1. TYPES object includes ComplianceAuditService and AuditIntegrityService symbols
2. Services can be imported from services/compliance/index.ts
3. TypeScript compiles without errors
  </verify>
  <done>
DI types updated with ComplianceAuditService and AuditIntegrityService. Index file created for convenient imports. Services are ready for injection throughout the application.
  </done>
</task>

</tasks>

<verification>
After completing all tasks:

1. **Service files exist:**
   ```bash
   ls -la web-erp-app/backend/src/services/compliance/
   # Should show: compliance-audit.service.ts, audit-integrity.service.ts, index.ts
   ```

2. **TypeScript compilation:**
   ```bash
   cd web-erp-app/backend
   npx tsc --noEmit
   ```

3. **Import verification:**
   ```typescript
   // This should work:
   import { ComplianceAuditService, AuditIntegrityService } from './services/compliance';
   ```

4. **Key method signatures:**
   - ComplianceAuditService.logWithHashChain(tx, context, input): Promise<TamperProofAuditRecord>
   - AuditIntegrityService.verifyIntegrity(options?): Promise<AuditIntegrityResult>
   - AuditIntegrityService.verifyRecentRecords(count?): Promise<AuditIntegrityResult>
</verification>

<success_criteria>
1. ComplianceAuditService extends AuditService and provides logWithHashChain method
2. AuditIntegrityService provides verifyIntegrity and verifyRecentRecords methods
3. Both services use consistent SHA-256 hash calculation
4. Services are registered in DI container
5. TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-internal-controls-audit/02-02-SUMMARY.md`

Include:
- Services created (ComplianceAuditService, AuditIntegrityService)
- Key methods and their purposes
- DI registration details
- Hash chain algorithm notes
- Any deviations from plan
</output>
