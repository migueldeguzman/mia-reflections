---
phase: 02-internal-controls-audit
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - web-erp-app/backend/prisma/tenant-schema.prisma
  - web-erp-app/backend/prisma/migrations/XXX_add_audit_tamperproof/migration.sql
  - web-erp-app/backend/src/types/compliance/audit.types.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Audit logs have sequential numbering that never gaps"
    - "Audit logs have hash chain fields for tamper detection"
    - "Audit logs cannot be modified or deleted by any user"
    - "FTA-specific audit actions are available for compliance logging"
  artifacts:
    - path: "web-erp-app/backend/prisma/tenant-schema.prisma"
      provides: "Tamper-proof fields on audit_logs model"
      contains: "sequenceNumber"
    - path: "web-erp-app/backend/prisma/migrations"
      provides: "Migration with sequence, columns, and immutability trigger"
    - path: "web-erp-app/backend/src/types/compliance/audit.types.ts"
      provides: "FTA compliance audit types"
      exports: ["FtaAuditAction", "TamperProofAuditRecord"]
  key_links:
    - from: "tenant-schema.prisma audit_logs model"
      to: "PostgreSQL audit_logs_seq SEQUENCE"
      via: "migration creates SEQUENCE for atomic numbering"
      pattern: "CREATE SEQUENCE.*audit_logs_seq"
    - from: "audit_logs table"
      to: "prevent_audit_modification trigger"
      via: "PostgreSQL trigger prevents UPDATE/DELETE"
      pattern: "CREATE TRIGGER.*audit_logs_immutable"
---

<objective>
Extend audit_logs schema with tamper-proof fields (sequence number, hash chain columns) and add FTA compliance audit action types.

Purpose: Enable tamper-proof audit trail for FTA compliance by adding sequential numbering, hash chain columns, and database-level immutability constraints. This satisfies CTRL-03 (tamper-proof logs) requirement.

Output: Updated tenant-schema.prisma with tamper-proof fields, PostgreSQL migration with SEQUENCE and immutability trigger, and TypeScript types for FTA audit actions.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-internal-controls-audit/02-RESEARCH.md
@web-erp-app/backend/prisma/tenant-schema.prisma
@web-erp-app/backend/src/services/audit.service.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend audit_logs model with tamper-proof fields</name>
  <files>
    web-erp-app/backend/prisma/tenant-schema.prisma
  </files>
  <action>
Update the audit_logs model in tenant-schema.prisma to add tamper-proof fields:

```prisma
model audit_logs {
  id             String      @id @default(uuid())
  sequenceNumber BigInt?     // Sequential audit number (populated by trigger/service)
  previousHash   String?     @db.VarChar(64) // SHA-256 hash of previous record
  recordHash     String?     @db.VarChar(64) // SHA-256 hash of this record
  userId         String?
  action         AuditAction
  entity         String
  entityId       String
  oldValue       Json?
  newValue       Json?
  ipAddress      String?
  userAgent      String?
  createdAt      DateTime    @default(now())

  // Relations
  user users? @relation(fields: [userId], references: [id])

  @@unique([sequenceNumber]) // Guarantee unique sequence
  @@index([createdAt])
  @@index([entity, entityId])
  @@index([userId, createdAt])
  @@index([recordHash]) // For integrity verification lookups
}
```

Also extend the AuditAction enum with FTA compliance actions:

```prisma
enum AuditAction {
  // Existing actions
  CREATE
  UPDATE
  DELETE
  LOGIN
  LOGOUT
  POST_TRANSACTION
  VOID_TRANSACTION
  SUBMIT_RENEWAL
  APPROVE_RENEWAL
  REJECT_RENEWAL
  FEATURED_ADD
  FEATURED_REMOVE
  FEATURED_REORDER
  FEATURED_BULK_UPDATE

  // Superuser bypass actions (existing)
  SUPERUSER_BYPASS
  PERMISSION_BYPASS
  COMPANY_VALIDATION_BYPASS

  // FTA Compliance actions (NEW)
  VAT_RETURN_SUBMIT
  VAT_RETURN_AMEND
  CT_RETURN_SUBMIT
  EINVOICE_GENERATE
  EINVOICE_SUBMIT
  EINVOICE_CANCEL
  TRN_UPDATE
  COMPLIANCE_CONFIG_CHANGE
  APPROVAL_GRANTED
  APPROVAL_REJECTED
  BACKUP_CREATED
  BACKUP_RESTORED
  AUDIT_INTEGRITY_CHECK
}
```
  </action>
  <verify>
Run `npx prisma format --schema=web-erp-app/backend/prisma/tenant-schema.prisma` to validate schema syntax. Confirm audit_logs has sequenceNumber, previousHash, recordHash fields and AuditAction enum includes FTA actions.
  </verify>
  <done>
audit_logs model has 3 new tamper-proof fields (sequenceNumber BigInt?, previousHash String?, recordHash String?) with appropriate indexes. AuditAction enum includes 13 new FTA compliance actions.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create PostgreSQL migration with SEQUENCE and immutability trigger</name>
  <files>
    web-erp-app/backend/prisma/migrations/20260124000001_add_audit_tamperproof/migration.sql
  </files>
  <action>
Create a manual SQL migration file (Prisma will auto-detect it) with:

1. Create SEQUENCE for atomic audit log numbering
2. Add tamper-proof columns to audit_logs
3. Create immutability trigger to prevent UPDATE/DELETE
4. Backfill existing records with sequence numbers (mark as "pre-tamperproof era")

```sql
-- Migration: Add tamper-proof fields to audit_logs for FTA compliance
-- Phase: 02-internal-controls-audit
-- Requirement: CTRL-03 (tamper-proof audit logs)

-- 1. Create sequence for audit log numbering
-- SEQUENCE guarantees atomic increment, no gaps in normal operation
CREATE SEQUENCE IF NOT EXISTS audit_logs_seq START 1;

-- 2. Add tamper-proof columns
ALTER TABLE audit_logs
ADD COLUMN IF NOT EXISTS sequence_number BIGINT,
ADD COLUMN IF NOT EXISTS previous_hash VARCHAR(64),
ADD COLUMN IF NOT EXISTS record_hash VARCHAR(64);

-- 3. Create unique index on sequence_number (allows NULL for pre-migration records)
CREATE UNIQUE INDEX IF NOT EXISTS audit_logs_sequence_number_key
ON audit_logs(sequence_number) WHERE sequence_number IS NOT NULL;

-- 4. Create index on record_hash for integrity verification
CREATE INDEX IF NOT EXISTS audit_logs_record_hash_idx
ON audit_logs(record_hash) WHERE record_hash IS NOT NULL;

-- 5. Create immutability trigger function
-- This prevents any UPDATE or DELETE on audit_logs after insert
CREATE OR REPLACE FUNCTION prevent_audit_modification()
RETURNS TRIGGER AS $$
BEGIN
  RAISE EXCEPTION 'Audit logs cannot be modified or deleted (FTA compliance requirement CTRL-03)';
END;
$$ LANGUAGE plpgsql;

-- 6. Create trigger for immutability
-- BEFORE UPDATE OR DELETE - prevents the operation before it happens
DROP TRIGGER IF EXISTS audit_logs_immutable ON audit_logs;
CREATE TRIGGER audit_logs_immutable
BEFORE UPDATE OR DELETE ON audit_logs
FOR EACH ROW EXECUTE FUNCTION prevent_audit_modification();

-- 7. Mark existing records as pre-tamperproof era
-- Set a marker in newValue JSON to indicate these records predate hash chain
-- (Optional: Run separately if large table to avoid lock contention)
-- UPDATE audit_logs
-- SET new_value = COALESCE(new_value, '{}'::jsonb) || '{"_preTamperproof": true}'::jsonb
-- WHERE sequence_number IS NULL AND record_hash IS NULL;

-- Note: sequence_number, previous_hash, record_hash will remain NULL for pre-migration records
-- New records will have these populated by ComplianceAuditService

COMMENT ON COLUMN audit_logs.sequence_number IS 'FTA-compliant sequential audit number. NULL for pre-migration records.';
COMMENT ON COLUMN audit_logs.previous_hash IS 'SHA-256 hash of previous audit record. NULL for first record or pre-migration.';
COMMENT ON COLUMN audit_logs.record_hash IS 'SHA-256 hash of this record for integrity verification.';
```

IMPORTANT: Create the migration directory first:
```bash
mkdir -p web-erp-app/backend/prisma/migrations/20260124000001_add_audit_tamperproof
```
  </action>
  <verify>
1. Verify migration file exists and has valid SQL syntax
2. Run `npx prisma migrate diff --from-empty --to-schema-datamodel=web-erp-app/backend/prisma/tenant-schema.prisma` to see pending changes
3. Verify trigger function and trigger are defined
  </verify>
  <done>
Migration file at prisma/migrations/20260124000001_add_audit_tamperproof/migration.sql contains: SEQUENCE creation, column additions, unique index, immutability trigger function, and trigger attachment. Comments explain FTA compliance purpose.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create TypeScript types for FTA compliance audit</name>
  <files>
    web-erp-app/backend/src/types/compliance/audit.types.ts
  </files>
  <action>
Create a new TypeScript file with FTA compliance audit types that will be used by the ComplianceAuditService in Plan 02:

```typescript
/**
 * FTA Compliance Audit Types
 * Phase: 02-internal-controls-audit
 * Requirements: CTRL-01, CTRL-02, CTRL-03
 *
 * These types support tamper-proof audit logging for UAE FTA compliance.
 */

import { AuditAction } from '@prisma/client';

/**
 * FTA-specific audit actions
 * These actions require tamper-proof logging with hash chain verification
 */
export const FTA_AUDIT_ACTIONS: AuditAction[] = [
  'VAT_RETURN_SUBMIT',
  'VAT_RETURN_AMEND',
  'CT_RETURN_SUBMIT',
  'EINVOICE_GENERATE',
  'EINVOICE_SUBMIT',
  'EINVOICE_CANCEL',
  'TRN_UPDATE',
  'COMPLIANCE_CONFIG_CHANGE',
  'APPROVAL_GRANTED',
  'APPROVAL_REJECTED',
  'BACKUP_CREATED',
  'BACKUP_RESTORED',
  'AUDIT_INTEGRITY_CHECK',
];

/**
 * Type guard to check if action is FTA-sensitive
 */
export function isFtaAuditAction(action: AuditAction): boolean {
  return FTA_AUDIT_ACTIONS.includes(action);
}

/**
 * Tamper-proof audit record structure
 * Extends standard audit log with hash chain fields
 */
export interface TamperProofAuditRecord {
  id: string;
  sequenceNumber: bigint;
  previousHash: string;          // SHA-256 of previous record (or 'GENESIS' for first)
  recordHash: string;            // SHA-256 of this record's data
  userId: string | null;
  action: AuditAction;
  entity: string;
  entityId: string;
  oldValue: Record<string, unknown> | null;
  newValue: Record<string, unknown> | null;
  ipAddress: string | null;
  userAgent: string | null;
  createdAt: Date;
}

/**
 * Input for creating tamper-proof audit log
 */
export interface TamperProofAuditInput {
  action: AuditAction;
  entity: string;
  entityId: string;
  oldValue?: Record<string, unknown>;
  newValue?: Record<string, unknown>;
}

/**
 * Result of audit integrity verification
 */
export interface AuditIntegrityResult {
  valid: boolean;
  checkedCount: number;
  firstInvalidSequence?: number;
  error?: string;
  verificationTimestamp: Date;
}

/**
 * Hash chain verification options
 */
export interface HashChainVerificationOptions {
  startSequence?: number;        // Start from specific sequence (default: 1)
  endSequence?: number;          // End at specific sequence (default: latest)
  startDate?: Date;              // Alternative: start from date
  endDate?: Date;                // Alternative: end at date
  batchSize?: number;            // Records per batch (default: 1000)
}

/**
 * FTA compliance audit categories
 * Groups audit actions by compliance domain
 */
export const FTA_AUDIT_CATEGORIES = {
  VAT: ['VAT_RETURN_SUBMIT', 'VAT_RETURN_AMEND'] as AuditAction[],
  CORPORATE_TAX: ['CT_RETURN_SUBMIT'] as AuditAction[],
  EINVOICING: ['EINVOICE_GENERATE', 'EINVOICE_SUBMIT', 'EINVOICE_CANCEL'] as AuditAction[],
  COMPLIANCE_CONFIG: ['TRN_UPDATE', 'COMPLIANCE_CONFIG_CHANGE'] as AuditAction[],
  APPROVAL_WORKFLOW: ['APPROVAL_GRANTED', 'APPROVAL_REJECTED'] as AuditAction[],
  BACKUP: ['BACKUP_CREATED', 'BACKUP_RESTORED'] as AuditAction[],
  INTEGRITY: ['AUDIT_INTEGRITY_CHECK'] as AuditAction[],
} as const;

/**
 * Audit log retention period in years (FTA requirement)
 */
export const FTA_AUDIT_RETENTION_YEARS = 7;

/**
 * Genesis hash for first record in hash chain
 */
export const GENESIS_HASH = 'GENESIS';

/**
 * Hash algorithm used for tamper-proof audit
 */
export const HASH_ALGORITHM = 'sha256';
```
  </action>
  <verify>
1. Run `npx tsc --noEmit web-erp-app/backend/src/types/compliance/audit.types.ts` to verify TypeScript compiles
2. Verify file exports all required types and constants
3. Check that AuditAction import will work after Prisma generate
  </verify>
  <done>
audit.types.ts exports: FTA_AUDIT_ACTIONS array, isFtaAuditAction type guard, TamperProofAuditRecord interface, TamperProofAuditInput interface, AuditIntegrityResult interface, HashChainVerificationOptions interface, FTA_AUDIT_CATEGORIES constant, FTA_AUDIT_RETENTION_YEARS (7), GENESIS_HASH, HASH_ALGORITHM constants.
  </done>
</task>

</tasks>

<verification>
After completing all tasks:

1. **Schema validation:**
   ```bash
   cd web-erp-app/backend
   npx prisma format --schema=prisma/tenant-schema.prisma
   npx prisma validate --schema=prisma/tenant-schema.prisma
   ```

2. **Migration file exists:**
   ```bash
   ls -la prisma/migrations/20260124000001_add_audit_tamperproof/
   cat prisma/migrations/20260124000001_add_audit_tamperproof/migration.sql | head -30
   ```

3. **TypeScript compilation:**
   ```bash
   npx tsc --noEmit src/types/compliance/audit.types.ts
   ```

4. **Verify key elements:**
   - audit_logs model has sequenceNumber, previousHash, recordHash fields
   - AuditAction enum has 13 new FTA compliance actions
   - Migration creates SEQUENCE, columns, unique index, and immutability trigger
   - Types file exports all required interfaces and constants
</verification>

<success_criteria>
1. tenant-schema.prisma validates with no errors and includes tamper-proof fields
2. Migration SQL file exists with SEQUENCE, columns, indexes, and trigger
3. TypeScript types compile and export all required interfaces
4. No breaking changes to existing audit_logs usage (fields are nullable for backward compatibility)
</success_criteria>

<output>
After completion, create `.planning/phases/02-internal-controls-audit/02-01-SUMMARY.md`

Include:
- Schema changes made (3 new fields, 13 new enum values)
- Migration details (SEQUENCE, trigger)
- Types exported
- Commits created
- Any deviations from plan
</output>
