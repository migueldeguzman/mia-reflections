---
phase: 01-multi-tenant-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - web-erp-app/backend/src/services/finance/compliance-config.service.ts
  - web-erp-app/backend/src/controllers/finance/compliance-config.controller.ts
  - web-erp-app/backend/src/routes/finance/compliance-config.routes.ts
  - web-erp-app/backend/src/routes/finance/index.ts
  - web-erp-app/backend/src/types/compliance/uae-compliance.types.ts
autonomous: true

must_haves:
  truths:
    - "Service can get/create/update tenant compliance configuration"
    - "TRN is validated as 15-digit numeric before saving"
    - "Free zone selection updates both freeZoneId and denormalized freeZoneName"
    - "Industry code selection validates against reference data"
    - "Tax code mappings can be created and queried per tenant"
    - "All operations validate user belongs to tenant (data isolation)"
  artifacts:
    - path: "web-erp-app/backend/src/services/finance/compliance-config.service.ts"
      provides: "ComplianceConfigService class with CRUD operations"
      exports: ["ComplianceConfigService"]
      min_lines: 200
    - path: "web-erp-app/backend/src/controllers/finance/compliance-config.controller.ts"
      provides: "Express controller for compliance config endpoints"
      exports: ["ComplianceConfigController"]
      min_lines: 100
    - path: "web-erp-app/backend/src/routes/finance/compliance-config.routes.ts"
      provides: "Express router with permission middleware"
      exports: ["default"]
      min_lines: 30
    - path: "web-erp-app/backend/src/types/compliance/uae-compliance.types.ts"
      provides: "TypeScript interfaces for compliance configuration"
      exports: ["TenantComplianceConfig", "UpdateComplianceConfigInput"]
      min_lines: 50
  key_links:
    - from: "compliance-config.routes.ts"
      to: "compliance-config.controller.ts"
      via: "Express route handler"
      pattern: "controller\\."
    - from: "compliance-config.controller.ts"
      to: "compliance-config.service.ts"
      via: "Service method call"
      pattern: "service\\."
    - from: "compliance-config.service.ts"
      to: "prisma"
      via: "Prisma client queries"
      pattern: "prisma\\.tenant_compliance_config"
---

<objective>
Create the service and API layer for tenant compliance configuration management.

Purpose: Provide a complete CRUD API for managing tenant TRN, free zone status, industry classification, and tax code mappings - enabling administrators to configure UAE compliance settings.

Output:
- ComplianceConfigService with TRN validation, free zone lookup, industry code lookup
- Express controller with proper error handling
- REST API routes with permission middleware
- TypeScript types for type safety
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-multi-tenant-foundation/01-RESEARCH.md
@.planning/phases/01-multi-tenant-foundation/01-01-SUMMARY.md

Codebase patterns:
@web-erp-app/backend/src/services/finance/tax-configuration.service.ts
@web-erp-app/backend/src/controllers/finance/tax-configuration.controller.ts
@web-erp-app/backend/src/routes/finance/tax-configuration.routes.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TypeScript types for compliance configuration</name>
  <files>web-erp-app/backend/src/types/compliance/uae-compliance.types.ts</files>
  <action>
Create TypeScript interfaces for UAE compliance configuration. First create the directory:
`mkdir -p web-erp-app/backend/src/types/compliance`

```typescript
/**
 * UAE Compliance Configuration Types
 *
 * Type definitions for tenant compliance settings including:
 * - TRN (Tax Registration Number) configuration
 * - Free Zone status and designation
 * - Industry classification (DED/ISIC codes)
 * - Tax code mappings per tenant
 */

// ============================================
// Enums (mirror Prisma enums for type safety)
// ============================================

export type TrnStatus = 'UNVERIFIED' | 'VERIFIED' | 'PENDING_VERIFICATION' | 'INVALID';

export type FreeZoneStatus = 'NON_FREE_ZONE' | 'DESIGNATED_ZONE' | 'FREE_ZONE' | 'OFFSHORE';

export type FilingFrequency = 'MONTHLY' | 'QUARTERLY';

// ============================================
// Reference Data Types (Master DB)
// ============================================

export interface FreeZone {
  id: string;
  code: string;
  name: string;
  nameArabic?: string | null;
  emirate: string;
  isDesignated: boolean;
  vatTreatment: string;
  isCtQualifying: boolean;
  isActive: boolean;
}

export interface IndustryCode {
  id: string;
  dedCode?: string | null;
  isicCode: string;
  name: string;
  nameArabic?: string | null;
  category: string;
  vatDefaultRate: string;
  hasSpecialRules: boolean;
  isActive: boolean;
}

// ============================================
// Tenant Compliance Config Types
// ============================================

export interface TenantComplianceConfig {
  id: string;

  // TRN Configuration
  trnNumber: string | null;
  trnVerifiedAt: Date | null;
  trnStatus: TrnStatus;

  // Free Zone Configuration
  freeZoneStatus: FreeZoneStatus;
  freeZoneId: string | null;
  freeZoneName: string | null;
  isDesignatedZone: boolean;

  // Industry Configuration
  industryCode: string | null;
  industryName: string | null;
  secondaryIndustry: string | null;
  isicCode: string | null;

  // VAT Configuration
  vatRegistered: boolean;
  vatGroupMember: boolean;
  vatGroupTrn: string | null;
  filingFrequency: FilingFrequency;

  // Corporate Tax Configuration
  ctRegistered: boolean;
  ctQualifyingFreeZone: boolean;
  smallBusinessRelief: boolean;

  // WPS Configuration
  wpsRegistered: boolean;
  molEstablishmentId: string | null;

  // Audit
  createdAt: Date;
  updatedAt: Date;
  createdById: string | null;
  updatedById: string | null;
}

// ============================================
// Input Types for CRUD Operations
// ============================================

export interface CreateComplianceConfigInput {
  trnNumber?: string;
  freeZoneId?: string;
  industryCode?: string;
  vatRegistered?: boolean;
  filingFrequency?: FilingFrequency;
}

export interface UpdateTrnInput {
  trnNumber: string;
}

export interface UpdateFreeZoneInput {
  freeZoneId: string | null; // null to clear free zone
}

export interface UpdateIndustryInput {
  industryCode: string | null; // Primary DED code
  secondaryIndustry?: string | null;
}

export interface UpdateVatConfigInput {
  vatRegistered?: boolean;
  vatGroupMember?: boolean;
  vatGroupTrn?: string;
  filingFrequency?: FilingFrequency;
}

export interface UpdateComplianceConfigInput {
  // TRN
  trnNumber?: string;

  // Free Zone
  freeZoneId?: string | null;

  // Industry
  industryCode?: string | null;
  secondaryIndustry?: string | null;

  // VAT
  vatRegistered?: boolean;
  vatGroupMember?: boolean;
  vatGroupTrn?: string | null;
  filingFrequency?: FilingFrequency;

  // Corporate Tax
  ctRegistered?: boolean;
  ctQualifyingFreeZone?: boolean;
  smallBusinessRelief?: boolean;

  // WPS
  wpsRegistered?: boolean;
  molEstablishmentId?: string | null;
}

// ============================================
// Tax Code Mapping Types
// ============================================

export interface TaxCodeMapping {
  id: string;
  taxCodeId: string;
  effectiveRate: number;
  isApplicable: boolean;
  conditions: Record<string, unknown> | null;
  createdAt: Date;
  updatedAt: Date;

  // Joined data
  taxCode?: {
    id: string;
    code: string;
    name: string;
    rate: number;
    isDefault: boolean;
    isReverseCharge: boolean;
    isOutOfScope: boolean;
  };
}

export interface CreateTaxCodeMappingInput {
  taxCodeId: string;
  effectiveRate: number;
  isApplicable?: boolean;
  conditions?: Record<string, unknown>;
}

export interface UpdateTaxCodeMappingInput {
  effectiveRate?: number;
  isApplicable?: boolean;
  conditions?: Record<string, unknown>;
}

// ============================================
// API Response Types
// ============================================

export interface ComplianceConfigResponse {
  success: boolean;
  data: TenantComplianceConfig;
}

export interface FreeZonesListResponse {
  success: boolean;
  data: FreeZone[];
  total: number;
}

export interface IndustryCodesListResponse {
  success: boolean;
  data: IndustryCode[];
  total: number;
}

export interface TaxCodeMappingsResponse {
  success: boolean;
  data: TaxCodeMapping[];
}

// ============================================
// Validation Types
// ============================================

export interface TrnValidationResult {
  isValid: boolean;
  cleanedTrn: string;
  error?: string;
}

export interface ComplianceValidationResult {
  isValid: boolean;
  errors: string[];
  warnings: string[];
}
```

IMPORTANT: Follow existing types patterns in the codebase. Mirror Prisma enum values exactly.
  </action>
  <verify>
Run `npx tsc --noEmit web-erp-app/backend/src/types/compliance/uae-compliance.types.ts` - should compile without errors.
  </verify>
  <done>
Types file exists with interfaces for:
- TenantComplianceConfig and all input/update types
- FreeZone and IndustryCode reference data types
- TaxCodeMapping types
- API response types
- Validation result types
  </done>
</task>

<task type="auto">
  <name>Task 2: Create ComplianceConfigService</name>
  <files>web-erp-app/backend/src/services/finance/compliance-config.service.ts</files>
  <action>
Create the service following existing patterns from tax-configuration.service.ts.

```typescript
import { PrismaClient, TrnStatus, FreeZoneStatus, FilingFrequency, Prisma } from '@prisma/client';
import { PrismaClient as MasterPrismaClient } from '.prisma/master-client';
import { randomUUID } from 'crypto';
import { Decimal } from '@prisma/client/runtime/library';
import logger from '../logger.service';
import {
  TenantComplianceConfig,
  CreateComplianceConfigInput,
  UpdateComplianceConfigInput,
  UpdateTrnInput,
  UpdateFreeZoneInput,
  UpdateIndustryInput,
  TaxCodeMapping,
  CreateTaxCodeMappingInput,
  UpdateTaxCodeMappingInput,
  FreeZone,
  IndustryCode,
  TrnValidationResult,
} from '../../types/compliance/uae-compliance.types';

/**
 * Compliance Configuration Service
 *
 * Manages UAE compliance settings per tenant:
 * - TRN (Tax Registration Number) with FTA format validation
 * - Free Zone status with designated zone handling
 * - Industry classification (DED/ISIC codes)
 * - Tax code mappings per tenant
 *
 * SECURITY:
 * - All operations are tenant-isolated (no companyId filtering needed - tenant DB)
 * - User authentication validated at controller level
 *
 * UAE COMPLIANCE:
 * - TRN: 15-digit numeric (FTA specification)
 * - Designated Zones: Special VAT treatment for goods (Cabinet Decision No. 59)
 * - Free Zone vs Designated Zone: Different for VAT vs Corporate Tax
 */

// UAE TRN validation pattern (15 digits)
const UAE_TRN_PATTERN = /^\d{15}$/;

export class ComplianceConfigService {
  constructor(
    private readonly tenantPrisma: PrismaClient,
    private readonly masterPrisma: MasterPrismaClient
  ) {}

  // ============================================
  // TRN Validation
  // ============================================

  /**
   * Validates UAE TRN format
   * UAE TRN is 15 digits (no checksum algorithm published by FTA)
   */
  validateTrn(trn: string): TrnValidationResult {
    // Remove any spaces, dashes, or other separators
    const cleanedTrn = trn.replace(/[\s\-_.]/g, '');

    if (!cleanedTrn) {
      return { isValid: false, cleanedTrn: '', error: 'TRN is required' };
    }

    if (!UAE_TRN_PATTERN.test(cleanedTrn)) {
      return {
        isValid: false,
        cleanedTrn,
        error: 'Invalid TRN format. UAE TRN must be exactly 15 digits.'
      };
    }

    return { isValid: true, cleanedTrn };
  }

  // ============================================
  // Compliance Config CRUD
  // ============================================

  /**
   * Gets or creates the compliance configuration for the current tenant
   * Each tenant has exactly one compliance config record
   */
  async getOrCreateConfig(userId: string): Promise<TenantComplianceConfig> {
    // Check for existing config (tenant has max 1 record)
    let config = await this.tenantPrisma.tenant_compliance_config.findFirst();

    if (!config) {
      // Create default config
      config = await this.tenantPrisma.tenant_compliance_config.create({
        data: {
          id: randomUUID(),
          trnStatus: 'UNVERIFIED',
          freeZoneStatus: 'NON_FREE_ZONE',
          isDesignatedZone: false,
          vatRegistered: false,
          vatGroupMember: false,
          filingFrequency: 'QUARTERLY',
          ctRegistered: false,
          ctQualifyingFreeZone: false,
          smallBusinessRelief: false,
          wpsRegistered: false,
          createdById: userId,
          createdAt: new Date(),
          updatedAt: new Date(),
        },
      });

      logger.info('Created default compliance config for tenant', { userId });
    }

    return this.mapToResponse(config);
  }

  /**
   * Gets the compliance configuration for the current tenant
   * Returns null if no config exists
   */
  async getConfig(): Promise<TenantComplianceConfig | null> {
    const config = await this.tenantPrisma.tenant_compliance_config.findFirst();
    return config ? this.mapToResponse(config) : null;
  }

  /**
   * Updates the compliance configuration
   */
  async updateConfig(
    input: UpdateComplianceConfigInput,
    userId: string
  ): Promise<TenantComplianceConfig> {
    // Get existing config (or create if doesn't exist)
    const existing = await this.getOrCreateConfig(userId);

    // Build update data
    const updateData: Prisma.tenant_compliance_configUpdateInput = {
      updatedById: userId,
      updatedAt: new Date(),
    };

    // TRN update with validation
    if (input.trnNumber !== undefined) {
      const validation = this.validateTrn(input.trnNumber);
      if (!validation.isValid) {
        throw new Error(validation.error);
      }
      updateData.trnNumber = validation.cleanedTrn;
      updateData.trnStatus = 'PENDING_VERIFICATION';
    }

    // Free zone update with lookup
    if (input.freeZoneId !== undefined) {
      if (input.freeZoneId === null) {
        // Clear free zone
        updateData.freeZoneId = null;
        updateData.freeZoneName = null;
        updateData.freeZoneStatus = 'NON_FREE_ZONE';
        updateData.isDesignatedZone = false;
      } else {
        // Lookup and set free zone
        const freeZone = await this.getFreeZoneById(input.freeZoneId);
        if (!freeZone) {
          throw new Error('Free zone not found');
        }
        updateData.freeZoneId = freeZone.id;
        updateData.freeZoneName = freeZone.name;
        updateData.freeZoneStatus = freeZone.isDesignated ? 'DESIGNATED_ZONE' : 'FREE_ZONE';
        updateData.isDesignatedZone = freeZone.isDesignated;
      }
    }

    // Industry update with lookup
    if (input.industryCode !== undefined) {
      if (input.industryCode === null) {
        updateData.industryCode = null;
        updateData.industryName = null;
        updateData.isicCode = null;
      } else {
        const industry = await this.getIndustryByCode(input.industryCode);
        if (!industry) {
          throw new Error('Industry code not found');
        }
        updateData.industryCode = industry.dedCode;
        updateData.industryName = industry.name;
        updateData.isicCode = industry.isicCode;
      }
    }

    if (input.secondaryIndustry !== undefined) {
      updateData.secondaryIndustry = input.secondaryIndustry;
    }

    // VAT config
    if (input.vatRegistered !== undefined) updateData.vatRegistered = input.vatRegistered;
    if (input.vatGroupMember !== undefined) updateData.vatGroupMember = input.vatGroupMember;
    if (input.vatGroupTrn !== undefined) updateData.vatGroupTrn = input.vatGroupTrn;
    if (input.filingFrequency !== undefined) updateData.filingFrequency = input.filingFrequency;

    // CT config
    if (input.ctRegistered !== undefined) updateData.ctRegistered = input.ctRegistered;
    if (input.ctQualifyingFreeZone !== undefined) updateData.ctQualifyingFreeZone = input.ctQualifyingFreeZone;
    if (input.smallBusinessRelief !== undefined) updateData.smallBusinessRelief = input.smallBusinessRelief;

    // WPS config
    if (input.wpsRegistered !== undefined) updateData.wpsRegistered = input.wpsRegistered;
    if (input.molEstablishmentId !== undefined) updateData.molEstablishmentId = input.molEstablishmentId;

    // Perform update
    const updated = await this.tenantPrisma.tenant_compliance_config.update({
      where: { id: existing.id },
      data: updateData,
    });

    logger.info('Updated compliance config', {
      configId: updated.id,
      userId,
      changes: Object.keys(input),
    });

    return this.mapToResponse(updated);
  }

  /**
   * Updates TRN number specifically
   */
  async updateTrn(input: UpdateTrnInput, userId: string): Promise<TenantComplianceConfig> {
    const validation = this.validateTrn(input.trnNumber);
    if (!validation.isValid) {
      throw new Error(validation.error);
    }

    const config = await this.getOrCreateConfig(userId);

    const updated = await this.tenantPrisma.tenant_compliance_config.update({
      where: { id: config.id },
      data: {
        trnNumber: validation.cleanedTrn,
        trnStatus: 'PENDING_VERIFICATION',
        vatRegistered: true, // TRN implies VAT registration
        updatedById: userId,
        updatedAt: new Date(),
      },
    });

    logger.info('Updated TRN', { configId: updated.id, userId });

    return this.mapToResponse(updated);
  }

  /**
   * Marks TRN as verified (after manual FTA portal verification)
   */
  async verifyTrn(userId: string): Promise<TenantComplianceConfig> {
    const config = await this.getOrCreateConfig(userId);

    if (!config.trnNumber) {
      throw new Error('No TRN configured to verify');
    }

    const updated = await this.tenantPrisma.tenant_compliance_config.update({
      where: { id: config.id },
      data: {
        trnStatus: 'VERIFIED',
        trnVerifiedAt: new Date(),
        updatedById: userId,
        updatedAt: new Date(),
      },
    });

    logger.info('TRN marked as verified', { configId: updated.id, userId });

    return this.mapToResponse(updated);
  }

  /**
   * Updates free zone configuration
   */
  async updateFreeZone(input: UpdateFreeZoneInput, userId: string): Promise<TenantComplianceConfig> {
    return this.updateConfig({ freeZoneId: input.freeZoneId }, userId);
  }

  /**
   * Updates industry configuration
   */
  async updateIndustry(input: UpdateIndustryInput, userId: string): Promise<TenantComplianceConfig> {
    return this.updateConfig({
      industryCode: input.industryCode,
      secondaryIndustry: input.secondaryIndustry,
    }, userId);
  }

  // ============================================
  // Reference Data Lookups (Master DB)
  // ============================================

  /**
   * Lists all active free zones from master DB
   */
  async listFreeZones(options: {
    emirate?: string;
    designatedOnly?: boolean;
    ctQualifyingOnly?: boolean;
  } = {}): Promise<FreeZone[]> {
    const where: any = { isActive: true };

    if (options.emirate) {
      where.emirate = options.emirate;
    }
    if (options.designatedOnly) {
      where.isDesignated = true;
    }
    if (options.ctQualifyingOnly) {
      where.isCtQualifying = true;
    }

    const zones = await this.masterPrisma.free_zones.findMany({
      where,
      orderBy: [{ emirate: 'asc' }, { name: 'asc' }],
    });

    return zones.map(z => ({
      id: z.id,
      code: z.code,
      name: z.name,
      nameArabic: z.nameArabic,
      emirate: z.emirate,
      isDesignated: z.isDesignated,
      vatTreatment: z.vatTreatment,
      isCtQualifying: z.isCtQualifying,
      isActive: z.isActive,
    }));
  }

  /**
   * Gets a free zone by ID from master DB
   */
  async getFreeZoneById(id: string): Promise<FreeZone | null> {
    const zone = await this.masterPrisma.free_zones.findUnique({
      where: { id },
    });

    if (!zone || !zone.isActive) {
      return null;
    }

    return {
      id: zone.id,
      code: zone.code,
      name: zone.name,
      nameArabic: zone.nameArabic,
      emirate: zone.emirate,
      isDesignated: zone.isDesignated,
      vatTreatment: zone.vatTreatment,
      isCtQualifying: zone.isCtQualifying,
      isActive: zone.isActive,
    };
  }

  /**
   * Lists all active industry codes from master DB
   */
  async listIndustryCodes(options: {
    category?: string;
    hasSpecialRulesOnly?: boolean;
  } = {}): Promise<IndustryCode[]> {
    const where: any = { isActive: true };

    if (options.category) {
      where.category = options.category;
    }
    if (options.hasSpecialRulesOnly) {
      where.hasSpecialRules = true;
    }

    const codes = await this.masterPrisma.industry_codes.findMany({
      where,
      orderBy: [{ category: 'asc' }, { name: 'asc' }],
    });

    return codes.map(c => ({
      id: c.id,
      dedCode: c.dedCode,
      isicCode: c.isicCode,
      name: c.name,
      nameArabic: c.nameArabic,
      category: c.category,
      vatDefaultRate: c.vatDefaultRate,
      hasSpecialRules: c.hasSpecialRules,
      isActive: c.isActive,
    }));
  }

  /**
   * Gets an industry code by DED code from master DB
   */
  async getIndustryByCode(dedCode: string): Promise<IndustryCode | null> {
    const code = await this.masterPrisma.industry_codes.findUnique({
      where: { dedCode },
    });

    if (!code || !code.isActive) {
      return null;
    }

    return {
      id: code.id,
      dedCode: code.dedCode,
      isicCode: code.isicCode,
      name: code.name,
      nameArabic: code.nameArabic,
      category: code.category,
      vatDefaultRate: code.vatDefaultRate,
      hasSpecialRules: code.hasSpecialRules,
      isActive: code.isActive,
    };
  }

  /**
   * Gets industry categories (distinct list)
   */
  async listIndustryCategories(): Promise<string[]> {
    const result = await this.masterPrisma.industry_codes.findMany({
      where: { isActive: true },
      select: { category: true },
      distinct: ['category'],
      orderBy: { category: 'asc' },
    });

    return result.map(r => r.category);
  }

  // ============================================
  // Tax Code Mappings
  // ============================================

  /**
   * Lists tax code mappings for the tenant
   */
  async listTaxCodeMappings(): Promise<TaxCodeMapping[]> {
    const mappings = await this.tenantPrisma.tax_code_mappings.findMany({
      include: {
        taxCode: true,
      },
      orderBy: { taxCode: { code: 'asc' } },
    });

    return mappings.map(m => ({
      id: m.id,
      taxCodeId: m.taxCodeId,
      effectiveRate: m.effectiveRate.toNumber(),
      isApplicable: m.isApplicable,
      conditions: m.conditions as Record<string, unknown> | null,
      createdAt: m.createdAt,
      updatedAt: m.updatedAt,
      taxCode: m.taxCode ? {
        id: m.taxCode.id,
        code: m.taxCode.code,
        name: m.taxCode.name,
        rate: m.taxCode.rate.toNumber(),
        isDefault: m.taxCode.isDefault,
        isReverseCharge: m.taxCode.isReverseCharge,
        isOutOfScope: m.taxCode.isOutOfScope,
      } : undefined,
    }));
  }

  /**
   * Creates or updates a tax code mapping
   */
  async upsertTaxCodeMapping(
    input: CreateTaxCodeMappingInput,
    userId: string
  ): Promise<TaxCodeMapping> {
    // Verify tax code exists
    const taxCode = await this.tenantPrisma.tax_codes.findUnique({
      where: { id: input.taxCodeId },
    });

    if (!taxCode) {
      throw new Error('Tax code not found');
    }

    // Validate rate
    if (input.effectiveRate < 0 || input.effectiveRate > 100) {
      throw new Error('Effective rate must be between 0 and 100');
    }

    const mapping = await this.tenantPrisma.tax_code_mappings.upsert({
      where: { taxCodeId: input.taxCodeId },
      update: {
        effectiveRate: new Decimal(input.effectiveRate),
        isApplicable: input.isApplicable ?? true,
        conditions: input.conditions ?? Prisma.DbNull,
        updatedAt: new Date(),
      },
      create: {
        id: randomUUID(),
        taxCodeId: input.taxCodeId,
        effectiveRate: new Decimal(input.effectiveRate),
        isApplicable: input.isApplicable ?? true,
        conditions: input.conditions ?? Prisma.DbNull,
        createdAt: new Date(),
        updatedAt: new Date(),
      },
      include: { taxCode: true },
    });

    logger.info('Upserted tax code mapping', {
      mappingId: mapping.id,
      taxCodeId: input.taxCodeId,
      userId,
    });

    return {
      id: mapping.id,
      taxCodeId: mapping.taxCodeId,
      effectiveRate: mapping.effectiveRate.toNumber(),
      isApplicable: mapping.isApplicable,
      conditions: mapping.conditions as Record<string, unknown> | null,
      createdAt: mapping.createdAt,
      updatedAt: mapping.updatedAt,
      taxCode: mapping.taxCode ? {
        id: mapping.taxCode.id,
        code: mapping.taxCode.code,
        name: mapping.taxCode.name,
        rate: mapping.taxCode.rate.toNumber(),
        isDefault: mapping.taxCode.isDefault,
        isReverseCharge: mapping.taxCode.isReverseCharge,
        isOutOfScope: mapping.taxCode.isOutOfScope,
      } : undefined,
    };
  }

  /**
   * Deletes a tax code mapping
   */
  async deleteTaxCodeMapping(mappingId: string): Promise<void> {
    await this.tenantPrisma.tax_code_mappings.delete({
      where: { id: mappingId },
    });
  }

  // ============================================
  // Private Helpers
  // ============================================

  private mapToResponse(config: any): TenantComplianceConfig {
    return {
      id: config.id,
      trnNumber: config.trnNumber,
      trnVerifiedAt: config.trnVerifiedAt,
      trnStatus: config.trnStatus as TrnStatus,
      freeZoneStatus: config.freeZoneStatus as FreeZoneStatus,
      freeZoneId: config.freeZoneId,
      freeZoneName: config.freeZoneName,
      isDesignatedZone: config.isDesignatedZone,
      industryCode: config.industryCode,
      industryName: config.industryName,
      secondaryIndustry: config.secondaryIndustry,
      isicCode: config.isicCode,
      vatRegistered: config.vatRegistered,
      vatGroupMember: config.vatGroupMember,
      vatGroupTrn: config.vatGroupTrn,
      filingFrequency: config.filingFrequency as FilingFrequency,
      ctRegistered: config.ctRegistered,
      ctQualifyingFreeZone: config.ctQualifyingFreeZone,
      smallBusinessRelief: config.smallBusinessRelief,
      wpsRegistered: config.wpsRegistered,
      molEstablishmentId: config.molEstablishmentId,
      createdAt: config.createdAt,
      updatedAt: config.updatedAt,
      createdById: config.createdById,
      updatedById: config.updatedById,
    };
  }
}

export default ComplianceConfigService;
```

IMPORTANT patterns followed:
- Two Prisma clients (tenant DB + master DB) for cross-database operations
- TRN validation using 15-digit pattern (no checksum - FTA doesn't publish algorithm)
- Free zone lookup sets denormalized name to avoid cross-DB joins
- Logger service for audit trail
- Decimal handling for tax rates
  </action>
  <verify>
Run `npx tsc --noEmit web-erp-app/backend/src/services/finance/compliance-config.service.ts` - should compile without errors.
  </verify>
  <done>
Service file exists with:
- TRN validation (15-digit)
- Get/create/update compliance config
- Free zone and industry lookups from master DB
- Tax code mapping CRUD
- Proper logging and error handling
  </done>
</task>

<task type="auto">
  <name>Task 3: Create controller and routes</name>
  <files>
web-erp-app/backend/src/controllers/finance/compliance-config.controller.ts
web-erp-app/backend/src/routes/finance/compliance-config.routes.ts
web-erp-app/backend/src/routes/finance/index.ts
  </files>
  <action>
Create the Express controller and routes following existing patterns.

1. **compliance-config.controller.ts**:
```typescript
import { Request, Response } from 'express';
import { ComplianceConfigService } from '../../services/finance/compliance-config.service';
import { PrismaClient } from '@prisma/client';
import { PrismaClient as MasterPrismaClient } from '.prisma/master-client';
import logger from '../../services/logger.service';

/**
 * Compliance Configuration Controller
 *
 * Handles HTTP requests for tenant compliance settings.
 * All endpoints require authentication via JWT middleware.
 *
 * Security: Generic error messages only - no internal details exposed.
 */

// Initialize Prisma clients
const tenantPrisma = new PrismaClient();
const masterPrisma = new MasterPrismaClient();
const service = new ComplianceConfigService(tenantPrisma, masterPrisma);

// Extend Express Request with user info
interface AuthRequest extends Request {
  user?: {
    id: string;
    email: string;
    companyId?: string;
  };
}

export class ComplianceConfigController {
  /**
   * GET /api/finance/compliance/config
   * Get or create compliance configuration for current tenant
   */
  async getConfig(req: Request, res: Response): Promise<void> {
    try {
      const authReq = req as AuthRequest;
      const userId = authReq.user?.id;

      if (!userId) {
        res.status(401).json({ success: false, message: 'Authentication required' });
        return;
      }

      const config = await service.getOrCreateConfig(userId);

      res.json({ success: true, data: config });
    } catch (error) {
      logger.error('[COMPLIANCE] Get config error:', {
        userId: (req as AuthRequest).user?.id,
        error: (error as Error).message,
        timestamp: new Date().toISOString(),
      });

      res.status(500).json({ success: false, message: 'Failed to fetch compliance configuration' });
    }
  }

  /**
   * PUT /api/finance/compliance/config
   * Update compliance configuration
   */
  async updateConfig(req: Request, res: Response): Promise<void> {
    try {
      const authReq = req as AuthRequest;
      const userId = authReq.user?.id;

      if (!userId) {
        res.status(401).json({ success: false, message: 'Authentication required' });
        return;
      }

      const config = await service.updateConfig(req.body, userId);

      res.json({ success: true, data: config });
    } catch (error) {
      const message = (error as Error).message;

      // Return validation errors as 400
      if (message.includes('Invalid') || message.includes('not found')) {
        res.status(400).json({ success: false, message });
        return;
      }

      logger.error('[COMPLIANCE] Update config error:', {
        userId: (req as AuthRequest).user?.id,
        body: req.body,
        error: message,
        timestamp: new Date().toISOString(),
      });

      res.status(500).json({ success: false, message: 'Failed to update compliance configuration' });
    }
  }

  /**
   * PUT /api/finance/compliance/trn
   * Update TRN number specifically
   */
  async updateTrn(req: Request, res: Response): Promise<void> {
    try {
      const authReq = req as AuthRequest;
      const userId = authReq.user?.id;

      if (!userId) {
        res.status(401).json({ success: false, message: 'Authentication required' });
        return;
      }

      const { trnNumber } = req.body;

      if (!trnNumber) {
        res.status(400).json({ success: false, message: 'TRN number is required' });
        return;
      }

      const config = await service.updateTrn({ trnNumber }, userId);

      res.json({ success: true, data: config });
    } catch (error) {
      const message = (error as Error).message;

      if (message.includes('Invalid TRN')) {
        res.status(400).json({ success: false, message });
        return;
      }

      logger.error('[COMPLIANCE] Update TRN error:', {
        userId: (req as AuthRequest).user?.id,
        error: message,
        timestamp: new Date().toISOString(),
      });

      res.status(500).json({ success: false, message: 'Failed to update TRN' });
    }
  }

  /**
   * POST /api/finance/compliance/trn/verify
   * Mark TRN as verified (after manual FTA portal check)
   */
  async verifyTrn(req: Request, res: Response): Promise<void> {
    try {
      const authReq = req as AuthRequest;
      const userId = authReq.user?.id;

      if (!userId) {
        res.status(401).json({ success: false, message: 'Authentication required' });
        return;
      }

      const config = await service.verifyTrn(userId);

      res.json({ success: true, data: config });
    } catch (error) {
      const message = (error as Error).message;

      if (message.includes('No TRN')) {
        res.status(400).json({ success: false, message });
        return;
      }

      logger.error('[COMPLIANCE] Verify TRN error:', {
        userId: (req as AuthRequest).user?.id,
        error: message,
        timestamp: new Date().toISOString(),
      });

      res.status(500).json({ success: false, message: 'Failed to verify TRN' });
    }
  }

  /**
   * GET /api/finance/compliance/free-zones
   * List available free zones (from master DB)
   */
  async listFreeZones(req: Request, res: Response): Promise<void> {
    try {
      const { emirate, designatedOnly, ctQualifyingOnly } = req.query;

      const zones = await service.listFreeZones({
        emirate: emirate as string | undefined,
        designatedOnly: designatedOnly === 'true',
        ctQualifyingOnly: ctQualifyingOnly === 'true',
      });

      res.json({ success: true, data: zones, total: zones.length });
    } catch (error) {
      logger.error('[COMPLIANCE] List free zones error:', {
        error: (error as Error).message,
        timestamp: new Date().toISOString(),
      });

      res.status(500).json({ success: false, message: 'Failed to fetch free zones' });
    }
  }

  /**
   * GET /api/finance/compliance/industry-codes
   * List available industry codes (from master DB)
   */
  async listIndustryCodes(req: Request, res: Response): Promise<void> {
    try {
      const { category, hasSpecialRulesOnly } = req.query;

      const codes = await service.listIndustryCodes({
        category: category as string | undefined,
        hasSpecialRulesOnly: hasSpecialRulesOnly === 'true',
      });

      res.json({ success: true, data: codes, total: codes.length });
    } catch (error) {
      logger.error('[COMPLIANCE] List industry codes error:', {
        error: (error as Error).message,
        timestamp: new Date().toISOString(),
      });

      res.status(500).json({ success: false, message: 'Failed to fetch industry codes' });
    }
  }

  /**
   * GET /api/finance/compliance/industry-categories
   * List distinct industry categories
   */
  async listIndustryCategories(req: Request, res: Response): Promise<void> {
    try {
      const categories = await service.listIndustryCategories();

      res.json({ success: true, data: categories });
    } catch (error) {
      logger.error('[COMPLIANCE] List industry categories error:', {
        error: (error as Error).message,
        timestamp: new Date().toISOString(),
      });

      res.status(500).json({ success: false, message: 'Failed to fetch industry categories' });
    }
  }

  /**
   * GET /api/finance/compliance/tax-code-mappings
   * List tax code mappings for tenant
   */
  async listTaxCodeMappings(req: Request, res: Response): Promise<void> {
    try {
      const mappings = await service.listTaxCodeMappings();

      res.json({ success: true, data: mappings });
    } catch (error) {
      logger.error('[COMPLIANCE] List tax code mappings error:', {
        error: (error as Error).message,
        timestamp: new Date().toISOString(),
      });

      res.status(500).json({ success: false, message: 'Failed to fetch tax code mappings' });
    }
  }

  /**
   * POST /api/finance/compliance/tax-code-mappings
   * Create or update tax code mapping
   */
  async upsertTaxCodeMapping(req: Request, res: Response): Promise<void> {
    try {
      const authReq = req as AuthRequest;
      const userId = authReq.user?.id;

      if (!userId) {
        res.status(401).json({ success: false, message: 'Authentication required' });
        return;
      }

      const { taxCodeId, effectiveRate, isApplicable, conditions } = req.body;

      if (!taxCodeId) {
        res.status(400).json({ success: false, message: 'Tax code ID is required' });
        return;
      }

      if (effectiveRate === undefined || effectiveRate === null) {
        res.status(400).json({ success: false, message: 'Effective rate is required' });
        return;
      }

      const mapping = await service.upsertTaxCodeMapping(
        { taxCodeId, effectiveRate, isApplicable, conditions },
        userId
      );

      res.json({ success: true, data: mapping });
    } catch (error) {
      const message = (error as Error).message;

      if (message.includes('not found') || message.includes('must be')) {
        res.status(400).json({ success: false, message });
        return;
      }

      logger.error('[COMPLIANCE] Upsert tax code mapping error:', {
        userId: (req as AuthRequest).user?.id,
        body: req.body,
        error: message,
        timestamp: new Date().toISOString(),
      });

      res.status(500).json({ success: false, message: 'Failed to save tax code mapping' });
    }
  }

  /**
   * DELETE /api/finance/compliance/tax-code-mappings/:id
   * Delete tax code mapping
   */
  async deleteTaxCodeMapping(req: Request, res: Response): Promise<void> {
    try {
      const authReq = req as AuthRequest;
      const userId = authReq.user?.id;

      if (!userId) {
        res.status(401).json({ success: false, message: 'Authentication required' });
        return;
      }

      const { id } = req.params;

      await service.deleteTaxCodeMapping(id);

      res.json({ success: true, message: 'Tax code mapping deleted' });
    } catch (error) {
      logger.error('[COMPLIANCE] Delete tax code mapping error:', {
        userId: (req as AuthRequest).user?.id,
        mappingId: req.params.id,
        error: (error as Error).message,
        timestamp: new Date().toISOString(),
      });

      res.status(500).json({ success: false, message: 'Failed to delete tax code mapping' });
    }
  }
}

export default new ComplianceConfigController();
```

2. **compliance-config.routes.ts**:
```typescript
import { Router } from 'express';
import { authenticateJWT } from '../../middleware/auth.middleware';
import { requirePermission, requireAnyPermission } from '../../middleware/permission.middleware';
import controller from '../../controllers/finance/compliance-config.controller';

const router = Router();

/**
 * Compliance Configuration Routes
 *
 * All routes require JWT authentication.
 * Permission: compliance.config.view for read, compliance.config.edit for write
 */

// Get compliance configuration
router.get('/config',
  authenticateJWT,
  requirePermission('compliance.config.view'),
  (req, res) => controller.getConfig(req, res)
);

// Update compliance configuration
router.put('/config',
  authenticateJWT,
  requirePermission('compliance.config.edit'),
  (req, res) => controller.updateConfig(req, res)
);

// Update TRN specifically
router.put('/trn',
  authenticateJWT,
  requirePermission('compliance.config.edit'),
  (req, res) => controller.updateTrn(req, res)
);

// Verify TRN (after manual FTA portal check)
router.post('/trn/verify',
  authenticateJWT,
  requirePermission('compliance.config.edit'),
  (req, res) => controller.verifyTrn(req, res)
);

// List free zones (reference data - view permission only)
router.get('/free-zones',
  authenticateJWT,
  requirePermission('compliance.config.view'),
  (req, res) => controller.listFreeZones(req, res)
);

// List industry codes (reference data - view permission only)
router.get('/industry-codes',
  authenticateJWT,
  requirePermission('compliance.config.view'),
  (req, res) => controller.listIndustryCodes(req, res)
);

// List industry categories
router.get('/industry-categories',
  authenticateJWT,
  requirePermission('compliance.config.view'),
  (req, res) => controller.listIndustryCategories(req, res)
);

// Tax code mappings - list
router.get('/tax-code-mappings',
  authenticateJWT,
  requirePermission('compliance.config.view'),
  (req, res) => controller.listTaxCodeMappings(req, res)
);

// Tax code mappings - create/update
router.post('/tax-code-mappings',
  authenticateJWT,
  requirePermission('compliance.config.edit'),
  (req, res) => controller.upsertTaxCodeMapping(req, res)
);

// Tax code mappings - delete
router.delete('/tax-code-mappings/:id',
  authenticateJWT,
  requirePermission('compliance.config.edit'),
  (req, res) => controller.deleteTaxCodeMapping(req, res)
);

export default router;
```

3. **Update routes/finance/index.ts** - Add compliance routes:

Read the existing file first, then add the import and registration:

```typescript
// Add import at top with other imports:
import complianceConfigRoutes from './compliance-config.routes';

// Add route registration (find the section with other router.use calls):
router.use('/compliance', complianceConfigRoutes);
```

IMPORTANT:
- Follow existing patterns in index.ts for imports and route registration
- Use permission middleware with new permissions: compliance.config.view, compliance.config.edit
  </action>
  <verify>
Run `npx tsc --noEmit web-erp-app/backend/src/controllers/finance/compliance-config.controller.ts` - should compile.
Run `npx tsc --noEmit web-erp-app/backend/src/routes/finance/compliance-config.routes.ts` - should compile.
Check routes are registered: `grep -n "compliance" web-erp-app/backend/src/routes/finance/index.ts`
  </verify>
  <done>
Controller and routes created with:
- GET/PUT /api/finance/compliance/config
- PUT /api/finance/compliance/trn
- POST /api/finance/compliance/trn/verify
- GET /api/finance/compliance/free-zones
- GET /api/finance/compliance/industry-codes
- GET /api/finance/compliance/industry-categories
- GET/POST/DELETE /api/finance/compliance/tax-code-mappings
- All routes use authentication and permission middleware
- Routes registered in finance/index.ts
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. TypeScript compilation:
```bash
cd web-erp-app/backend
npx tsc --noEmit
```

2. ESLint (if configured):
```bash
npm run lint -- --fix
```

3. Verify route registration:
```bash
grep -rn "compliance" src/routes/
```

4. Test endpoint availability (after server restart):
```bash
# These should return 401 (auth required) not 404 (not found)
curl -s http://localhost:3000/api/finance/compliance/config | grep -q "Authentication" && echo "Route exists"
curl -s http://localhost:3000/api/finance/compliance/free-zones | grep -q "Authentication" && echo "Route exists"
```
</verification>

<success_criteria>
- TypeScript types compile without errors
- Service has all CRUD methods for compliance config
- Controller handles all error cases with proper HTTP codes
- Routes are registered under /api/finance/compliance/*
- All endpoints require authentication
- Edit operations require compliance.config.edit permission
- View operations require compliance.config.view permission
</success_criteria>

<output>
After completion, create `.planning/phases/01-multi-tenant-foundation/01-02-SUMMARY.md`
</output>
